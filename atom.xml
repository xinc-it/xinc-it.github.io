<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>无♥部落阁</title>
  
  
  <link href="https://xinc-it.github.io/atom.xml" rel="self"/>
  
  <link href="https://xinc-it.github.io/"/>
  <updated>2022-08-08T02:50:59.281Z</updated>
  <id>https://xinc-it.github.io/</id>
  
  <author>
    <name>无♥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql-行锁</title>
    <link href="https://xinc-it.github.io/2022/09/11/6!%E8%A1%8C%E9%94%81/"/>
    <id>https://xinc-it.github.io/2022/09/11/6!%E8%A1%8C%E9%94%81/</id>
    <published>2022-09-11T13:17:06.000Z</published>
    <updated>2022-08-08T02:50:59.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-两阶段锁"><a href="#1-两阶段锁" class="headerlink" title="1. 两阶段锁"></a>1. 两阶段锁</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634436939942-730ba0be-6f13-45fd-9e43-01d1e21cdcae.png#clientId=u3b414356-8e51-4&from=paste&height=284&id=tMiKr&margin=%5Bobject%20Object%5D&name=image.png&originHeight=568&originWidth=857&originalType=binary&ratio=1&size=76026&status=done&style=none&taskId=u92c3677b-e488-453e-8a85-2b6bec9261e&width=428.5" alt="image.png"><br>**下面的操作序列中，如果为两行数据加了行锁事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。</p><p>在 InnoDB 中，行锁是在需要的时候加上，在<strong>事务结束时释放。（</strong>最有可能造成锁冲突的行的读锁尽量往后放<strong>）</strong></p><p>示例：<br>顾客 A 在影院 B 买电影票<br>操作如下</p><ol><li>从顾客 A 账户余额中扣除电影票价；</li><li>给影院 B 的账户余额增加这张电影票价；</li><li>记录一条交易日志。</li></ol><p>其中多个顾客买票可能造成 B 的账户行数据冲突。因此将 B 的操作放在最后。最大程度减少了事务之间的锁等待。</p><h2 id="2-死锁和死锁检测"><a href="#2-死锁和死锁检测" class="headerlink" title="2. 死锁和死锁检测"></a>2. 死锁和死锁检测</h2><p>示例：当行锁同时锁住 id=1 和 2 的两行数据<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634437587628-d3672f2b-b62b-4ced-ac7b-dcc6de65eb02.png#clientId=u3b414356-8e51-4&from=paste&height=281&id=uf1f2e0cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=871&originalType=binary&ratio=1&size=90990&status=done&style=none&taskId=ub90e33fe-f5b8-4aab-ad45-1cf1dd6750d&width=435.5" alt="image.png"><br>在这种情况下事务 A 等待 id=2 的行锁，事务 B 等待 id=1 的行锁。事务 A 和事务 B 互相都在等待对方无法释放的资源，从而进入了死锁。</p><p>解决方法</p><ul><li>设置获取锁等待时间：设置获取锁超时时间，如果超时则锁住的线程自动退出。通过 innodb_lock_wait_timeout 来设置等待时间默认为 50s</li><li>发起死锁检测：发现死锁后主动回滚争抢锁的某一个事务。让其他事务继续执行。通过 innodb_deadlock_detect 设置为 on 表示开启逻辑。</li></ul><p>死锁检测的缺点：</p><ol><li>确保业务不会出现死锁，关闭死锁检测</li><li>控制并发度</li></ol><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><ol><li>读锁的两阶段协议：需要的时候加上、事务结束的时候释放。尽可能将影响并发度最大的锁往后放。减少其他锁的等待时间</li><li>死锁的形成，事务之间争抢不释放的锁资源。导致一直处于等待状态</li><li>死锁的解决方法：1. 设置锁等待时间 2. 开启死锁检测</li></ol><ul><li>第一种，直接执行 delete from T limit 10000;</li><li>第二种，在一个连接中循环执行 20 次 delete from T limit 500;</li><li>第三种，在 20 个连接中同时执行 delete from T limit 500。</li></ul><p>你会选择哪一种方法呢？为什么呢？<br>第二种，第三种容易造成死锁。第一种锁的范围太大导致获取锁的时间长。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-两阶段锁&quot;&gt;&lt;a href=&quot;#1-两阶段锁&quot; class=&quot;headerlink&quot; title=&quot;1. 两阶段锁&quot;&gt;&lt;/a&gt;1. 两阶段锁&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/123</summary>
      
    
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://xinc-it.github.io/tags/Mysql/"/>
    
    <category term="数据库" scheme="https://xinc-it.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="InnoDB" scheme="https://xinc-it.github.io/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-索引</title>
    <link href="https://xinc-it.github.io/2022/09/09/4!%E7%B4%A2%E5%BC%95/"/>
    <id>https://xinc-it.github.io/2022/09/09/4!%E7%B4%A2%E5%BC%95/</id>
    <published>2022-09-09T07:17:06.000Z</published>
    <updated>2022-08-08T02:50:59.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-索引常见模型"><a href="#1-索引常见模型" class="headerlink" title="1.索引常见模型"></a>1.索引常见模型</h2><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631014492663-2fed2cf8-9707-4346-bf90-06ff2a5b0d4e.png#clientId=uf02e59f4-5d80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=286&id=u7fa963ac&margin=%5Bobject%20Object%5D&name=image.png&originHeight=572&originWidth=848&originalType=binary&ratio=1&rotation=0&showTitle=false&size=173484&status=done&style=none&taskId=u6e8f087d-7794-4326-8ff8-d1cb74fcb50&title=&width=424" alt="image.png"></p><p>通过 hash 算法将 key 换算成确定的位置，然后把 value 放入到这个数组的位置。如果数组已经存在值，<br>则通过拉链法，拉出一条链表。</p><p>优点：等值查询的情况下查询效率高<br>缺点：范围查询效率低下</p><h3 id="2-有序数组"><a href="#2-有序数组" class="headerlink" title="2. 有序数组"></a>2. 有序数组</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631014718687-07087e14-d4f9-4401-9bbd-bb4dd3a0bce5.png#clientId=uf02e59f4-5d80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=219&id=u6b2951af&margin=%5Bobject%20Object%5D&name=image.png&originHeight=437&originWidth=898&originalType=binary&ratio=1&rotation=0&showTitle=false&size=108398&status=done&style=none&taskId=uf49d5f91-1a3a-48ac-aca3-80d6aec3ace&title=&width=449" alt="image.png"></p><p>优点：等值和范围查询效率高<br>缺点：插入、删除数据效率低下</p><p>场景：只适用于静态存储引擎</p><h3 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3. 二叉搜索树"></a>3. 二叉搜索树</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631014893629-805c3a90-3ccf-4fff-98f4-51ec1671c6df.png#clientId=uf02e59f4-5d80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=306&id=u38010e60&margin=%5Bobject%20Object%5D&name=image.png&originHeight=612&originWidth=865&originalType=binary&ratio=1&rotation=0&showTitle=false&size=178178&status=done&style=none&taskId=u5614456c-9189-45ca-bfb2-5fbf49f84fc&title=&width=432.5" alt="image.png"></p><p>缺点：数据量大的情况下，导致树很高，需要进行多次磁盘读取数据，比较浪费时间。</p><h2 id="2-InnoDB-索引模型"><a href="#2-InnoDB-索引模型" class="headerlink" title="2. InnoDB 索引模型"></a>2. InnoDB 索引模型</h2><p>B+树<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631015176574-c34b7b27-c5cc-4295-8de1-bdb466fe3700.png#clientId=uf02e59f4-5d80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=226&id=ud6c87e87&margin=%5Bobject%20Object%5D&name=image.png&originHeight=451&originWidth=847&originalType=binary&ratio=1&rotation=0&showTitle=false&size=121005&status=done&style=none&taskId=ue3c7c791-9710-400e-b106-8559a26769a&title=&width=423.5" alt="image.png"></p><h2 id="3-主键索引和非主键索引"><a href="#3-主键索引和非主键索引" class="headerlink" title="3. 主键索引和非主键索引"></a>3. 主键索引和非主键索引</h2><p><strong>InnoDB 里面主键索引也被称为聚簇索引</strong></p><p>非主键索引的叶子节点存储的是主键的值</p><p>主键索引和非主键索引的区别</p><ol><li>主键查询： 只需要查询主键索引的 B+树,查询出对应的数据</li><li>非主键索引：查询非主键索引的树，获得对应的主键值，然后通过主键值查询主键索引的 B+树</li></ol><h2 id="4-索引维护"><a href="#4-索引维护" class="headerlink" title="4. 索引维护"></a>4. 索引维护</h2><p>概念： 当数据页中数据存储满了，会生成一个新的数据页，然后原有数据也中的部分数据会移到新的数据也中。这种过程叫做页分裂。</p><p>同理页合并是两个数据页中的数据太少了，合并到一个数据页中。</p><h2 id="5-索引覆盖"><a href="#5-索引覆盖" class="headerlink" title="5. 索引覆盖"></a>5. 索引覆盖</h2><h3 id="1-回表"><a href="#1-回表" class="headerlink" title="1. 回表"></a>1. 回表</h3><p>select * from T where k between 3 and 5<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631016152383-0a030960-b98c-4af0-8eb5-c3e571988bc0.png#clientId=uf02e59f4-5d80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=QPjkB&margin=%5Bobject%20Object%5D&name=image.png&originHeight=406&originWidth=847&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119807&status=done&style=none&taskId=uc4420736-4496-455c-a039-deaab42dce4&title=&width=423.5" alt="image.png"><br>执行流程</p><ol><li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li><li>再到 ID 索引树查到 ID=300 对应的 R3；</li><li>在 k 索引树取下一个值 k=5，取得 ID=500；</li><li>再回到 ID 索引树查到 ID=500 对应的 R4；</li><li>在 k 索引树取下一个值 k=6，不满足条件，循环结束</li></ol><p><strong>回表：非主键搜索完后，回到主键索引树进行搜索的过程</strong>。（步骤 2、4）</p><h3 id="2-索引覆盖"><a href="#2-索引覆盖" class="headerlink" title="2. 索引覆盖"></a>2. 索引覆盖</h3><p>select ID from T where k between 3 and 5</p><p>对于上述通过非主键索引查询主键索引信息，由于非主键索引存放了主键的信息。<br>导致我们不需要进行回表。<strong>由于索引 k 的值覆盖了查询的字段，我们称之为覆盖索引</strong></p><p><strong>优点：减少树的搜索次数，提升查询效率</strong></p><h2 id="6-最左前缀原则"><a href="#6-最左前缀原则" class="headerlink" title="6. 最左前缀原则"></a>6. 最左前缀原则</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tuser` (</span><br><span class="line">  `id` int(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `id_card` varchar(<span class="number">32</span>) DEFAULT NULL,</span><br><span class="line">  `name` varchar(<span class="number">32</span>) DEFAULT NULL,</span><br><span class="line">  `age` int(<span class="number">11</span>) DEFAULT NULL,</span><br><span class="line">  `ismale` tinyint(<span class="number">1</span>) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `id_card` (`id_card`),</span><br><span class="line">  KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631016490840-0e048d5d-77e7-4191-83e7-026d3c1e3e6e.png#clientId=uf02e59f4-5d80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u0182df12&margin=%5Bobject%20Object%5D&name=image.png&originHeight=486&originWidth=916&originalType=binary&ratio=1&rotation=0&showTitle=false&size=185361&status=done&style=none&taskId=ubb2ba15c-29fb-469e-bca4-35d9ccce47c&title=&width=458" alt="image.png"></p><p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p><p><strong>联合索引以第一个索引为基准进行排序，然后通过第一个索引的值来进行查询</strong><br><a href="https://www.cnblogs.com/ljl150/p/12934071.html">最左前缀原则</a></p><h2 id="7-索引下推"><a href="#7-索引下推" class="headerlink" title="7. 索引下推"></a>7. 索引下推</h2><p>Mysql5.6 引入索引下推，是在最左前缀的条件小，过滤调不不符合条件的记录减少回表的次数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select * from tuser where name like &#x27;张 %&#x27; and age=<span class="number">10</span> and ismale=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631018210889-220345e3-dae5-4eb8-9170-5537631d52ef.png#clientId=uf02e59f4-5d80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=194&id=u671fa958&margin=%5Bobject%20Object%5D&name=image.png&originHeight=388&originWidth=859&originalType=binary&ratio=1&rotation=0&showTitle=false&size=183225&status=done&style=none&taskId=u26fcfa9c-8351-4a80-bb20-4dd098a028b&title=&width=429.5" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631018215910-da87dcc1-a41f-46ae-b73b-cecf9db4cf0f.png#clientId=uf02e59f4-5d80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=198&id=ue03b52df&margin=%5Bobject%20Object%5D&name=image.png&originHeight=395&originWidth=869&originalType=binary&ratio=1&rotation=0&showTitle=false&size=189030&status=done&style=none&taskId=u0df9d68d-5a7b-4383-babc-d022de12965&title=&width=434.5" alt="image.png"></p><h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h2><ol><li>索引的常见模型<ol><li>哈希表 （不支持范围查询）</li><li>有序数组（插入删除效率低）</li><li>二叉搜索树（数据量大，导致树的高度很高，需要进行多次磁盘读取）</li></ol></li><li>InnoDB 索引模型<ol><li>B+树支持范围查询，树的高度不会太高</li><li>查找数据消耗磁盘读取的时间相同</li></ol></li><li>主键索引和非主键索引<ol><li>在 InnoDB 主键索引存储索引行对应的数据</li><li>非主键索引存储的是主键索引的值，需要通过回表的方式，去查询一遍主键索引</li></ol></li><li>索引覆盖：通过非主键索引查询主键索引的值，导致不需要回到主键索引树再次进行查询的过程。</li><li>最左前缀原则</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-索引常见模型&quot;&gt;&lt;a href=&quot;#1-索引常见模型&quot; class=&quot;headerlink&quot; title=&quot;1.索引常见模型&quot;&gt;&lt;/a&gt;1.索引常见模型&lt;/h2&gt;&lt;h3 id=&quot;1-哈希表&quot;&gt;&lt;a href=&quot;#1-哈希表&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://xinc-it.github.io/tags/Mysql/"/>
    
    <category term="数据库" scheme="https://xinc-it.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="InnoDB" scheme="https://xinc-it.github.io/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-事务隔离</title>
    <link href="https://xinc-it.github.io/2022/09/07/3!%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <id>https://xinc-it.github.io/2022/09/07/3!%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</id>
    <published>2022-09-07T11:17:06.000Z</published>
    <updated>2022-08-08T02:50:59.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-隔离性和隔离级别"><a href="#1-隔离性和隔离级别" class="headerlink" title="1. 隔离性和隔离级别"></a>1. 隔离性和隔离级别</h2><h3 id="1-事务特性"><a href="#1-事务特性" class="headerlink" title="1. 事务特性"></a>1. 事务特性</h3><ol><li><strong>原子性</strong></li><li><strong>持久性</strong></li><li><strong>隔离性</strong></li><li><strong>一致性</strong></li></ol><h3 id="2-事务隔离级别"><a href="#2-事务隔离级别" class="headerlink" title="2. 事务隔离级别"></a>2. 事务隔离级别</h3><ol><li><strong>读已提交（事务未提交时，变更能被其它事务看到）</strong></li><li><strong>读未提交（事务提交后，其它事务才能看到变更）</strong></li><li><strong>可重复读（一个事务执行过程中，总是跟启动时看到的数据是一致的。未提交的变更对其它事务不可见）</strong></li><li><strong>串行化（同一行记录写会加写锁，读会读锁。当出现读写锁冲突时，后访问的事务，必须等前一个事务完成，才能执行）</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630988923063-4d56a761-7637-488b-951d-c443de806cb1.png#clientId=uf02e59f4-5d80-4&from=paste&height=381&id=uf414196c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=762&originWidth=788&originalType=binary&ratio=1&size=201874&status=done&style=none&taskId=u19543944-dee4-4fbf-bf51-efae564dfae&width=394" alt="image.png"></p><p>v1=v2=1,v3=2<br>四种事务得到的结果</p><ol><li>读未提交： v1、v2、v3=2</li><li>读已提交: v1=1 ，v2、v3=2</li><li>可重复读：v1=v2=1，v3=2</li><li>可串行化 ： v1=v2=1,v3=2</li></ol><h2 id="2-事务隔离的实现"><a href="#2-事务隔离的实现" class="headerlink" title="2. 事务隔离的实现"></a>2. 事务隔离的实现</h2><p>当一个值从 1 按顺序变成 2，3，3 那么他的日志里面就会有类似的回滚段记录<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631013980123-b4f659d1-a49a-4d6f-bffa-5c049fb7a4b5.png#clientId=uf02e59f4-5d80-4&from=paste&height=259&id=u4bd92b33&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=906&originalType=binary&ratio=1&size=104426&status=done&style=none&taskId=ub4313c28-1bd9-45bf-a56d-abe4cf1987a&width=453" alt="image.png"><br>如图事务 A、B、C 修改记录导致一个字段对应多个值。</p><p>通过 MVCC 来实现一个数据的多个版本，通过 undo log 实现数据版本的回滚<br>通过 MVCC 和 undo log 来实现事务的隔离<br>具体可以参考</p><p><a href="https://www.yuque.com/sanxingalaxys9/gwxct1/lq01qk?view=doc_embed">Mysql 实战 45 讲</a></p><p>当回滚段日志过长时，系统会自动清除。</p><h2 id="3-事务的启动方式"><a href="#3-事务的启动方式" class="headerlink" title="3. 事务的启动方式"></a>3. 事务的启动方式</h2><ol><li>set autocommit=0 关闭自动提交，只要执行 select 语句自动开启事务</li><li>begin 或是 start transaction</li></ol><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><ol><li>四大特性和隔离级别</li><li>事务隔离的实现（通过 MVCC 和 undo log)</li><li>事务的启动方式<ol><li>自动启动 select 语句执行时自动启动</li><li>手动启动 begin、 start transaction</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-隔离性和隔离级别&quot;&gt;&lt;a href=&quot;#1-隔离性和隔离级别&quot; class=&quot;headerlink&quot; title=&quot;1. 隔离性和隔离级别&quot;&gt;&lt;/a&gt;1. 隔离性和隔离级别&lt;/h2&gt;&lt;h3 id=&quot;1-事务特性&quot;&gt;&lt;a href=&quot;#1-事务特性&quot; class</summary>
      
    
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://xinc-it.github.io/tags/Mysql/"/>
    
    <category term="数据库" scheme="https://xinc-it.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="InnoDB" scheme="https://xinc-it.github.io/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-更新语句的执行</title>
    <link href="https://xinc-it.github.io/2022/09/06/2!%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
    <id>https://xinc-it.github.io/2022/09/06/2!%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C/</id>
    <published>2022-09-06T04:17:06.000Z</published>
    <updated>2022-08-08T02:50:59.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-更新语句执行流程"><a href="#1-更新语句执行流程" class="headerlink" title="1. 更新语句执行流程"></a>1. 更新语句执行流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630974533552-29681b12-3ee4-4012-ae23-882ab740984d.png#clientId=uf02e59f4-5d80-4&from=paste&height=337&id=u6f547220&margin=%5Bobject%20Object%5D&name=image.png&originHeight=674&originWidth=928&originalType=binary&ratio=1&size=239274&status=done&style=none&taskId=u902b2c56-0159-4ac1-9ecc-7c0453d9054&width=464" alt="image.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T <span class="built_in">set</span> c=c+1 <span class="built_in">where</span> ID=2;</span><br></pre></td></tr></table></figure><ol><li>客户端通过连接器连接 MySQL 服务器</li><li>将缓存中相关表的结果清空</li><li>分析器通过词法和语法分析判断是更新语句</li><li>优化器通过索引，决定使用 ID 的索引</li><li>执行器执行更新语句</li><li>进行 redo log 和 bin log 的修改</li></ol><h2 id="2-Redo-log-引擎日志"><a href="#2-Redo-log-引擎日志" class="headerlink" title="2.Redo log(引擎日志)"></a>2.Redo log(引擎日志)</h2><p>情景老板记账：先把借帐和还账记录写在黑板上，空闲时，再把黑板上账的写入到账本中。</p><p>作用： 用作数据库写入将数据磁盘的缓存，防止每次更新都要将数据写进磁盘，提高了更新效率。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630975170760-0904cfb2-ee0b-4650-a584-bb831be94070.png#clientId=uf02e59f4-5d80-4&from=paste&height=328&id=u5e5e1dba&margin=%5Bobject%20Object%5D&name=image.png&originHeight=655&originWidth=943&originalType=binary&ratio=1&size=104067&status=done&style=none&taskId=u353c490e-0715-407a-9113-50af777809c&width=471.5" alt="image.png"></p><h3 id="1-WAL-Write-Ahead-Logging"><a href="#1-WAL-Write-Ahead-Logging" class="headerlink" title="1. WAL (Write-Ahead Logging)"></a>1. WAL (Write-Ahead Logging)</h3><p><strong>先写日志，再写磁盘</strong>。<br>InnoDB 引擎会把记录写道 redo log 中，并更新内存。然后更新就算完成。引擎会在空闲时间操作记录<br>写入磁盘。<br>如果 redo log 写满了，会把一部分记录更新到磁盘中。<br>通过 write pos 和 check point 两个指针来判断日志是否写满</p><h3 id="2-crash-safe"><a href="#2-crash-safe" class="headerlink" title="2. crash-safe"></a>2. crash-safe</h3><p>当数据库发生异常时，可以通过 redo log 可以获取到之前的提交记录。<br>通过提交记录可以将未同步到数据库中数据同步到数据库中。</p><p><strong>redo log 存储的是物理变更日志，用于记录磁盘中指定地方的数值修改记录。</strong></p><h3 id="3-特点"><a href="#3-特点" class="headerlink" title="3. 特点"></a>3. 特点</h3><ol><li> 存储的物理日志（记录的是数据页上数据的更改）</li><li> 先写日志，后写磁盘</li><li> 可以 crash safe 进行数据的修复</li><li> InnoDB 引擎层日志</li><li> 空间有限会用完，通过队列的实现循环写</li></ol><h2 id="3-binlog（Server-层日志）"><a href="#3-binlog（Server-层日志）" class="headerlink" title="3. binlog（Server 层日志）"></a>3. binlog（Server 层日志）</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><ol><li>服务层日志</li><li>存储的内容是逻辑日志（记录的是语句的原始逻辑）</li><li>空间无限，通过新增文件实现追加写</li></ol><h2 id="4-执行流程"><a href="#4-执行流程" class="headerlink" title="4. 执行流程"></a>4. 执行流程</h2><ol><li>执行引擎先找到 ID=2 的这一行数据，如果内存中存在直接返回给执行器，否则从磁盘读入内存然后返回给执行器</li><li>把值加上 1，然后调用引擎接口写入数据</li><li>引擎会将新数据更新到内存中，同时更新到 redo log 中。redo log 处于 prepare 状态，告诉执行器完成了，可以提交事务了。</li><li>执行器生成更新操作的 bin log,并把 bin log 写入磁盘</li><li>执行器调用引擎的事务接口，将写入的 redo log 改成 commit 状态</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634976756709-8dbcb97a-235f-4b93-a181-f46a29389d94.png#clientId=u359acdfd-faff-4&from=paste&height=525&id=u4d800135&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1050&originWidth=686&originalType=binary&ratio=1&size=168644&status=done&style=none&taskId=u39624d17-5f0a-4d9a-931c-683c5152009&width=343" alt="image.png"></p><h2 id="5-两阶段提交"><a href="#5-两阶段提交" class="headerlink" title="5. 两阶段提交"></a>5. 两阶段提交</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630988222445-a6208d34-24c4-4e8d-89b2-8952bbb46186.png#clientId=uf02e59f4-5d80-4&from=paste&height=198&id=u6943ccfd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=396&originWidth=651&originalType=binary&ratio=1&size=113756&status=done&style=none&taskId=udaf78fe9-6800-4ea4-af49-47d717da835&width=325.5" alt="image.png"></p><p><strong>原因</strong></p><ol><li>如果发生 crash 导致系统崩溃的话，如果顺序不一致，可能导致之后无法通过 binlog 恢复到任一时刻的数据</li><li>可能导致 binlog 和 redo log 的数据不一致导致数据冲突。</li></ol><h2 id="6-两种日志的不同点"><a href="#6-两种日志的不同点" class="headerlink" title="6. 两种日志的不同点"></a>6. 两种日志的不同点</h2><ol><li>redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的</li><li>redo log 是物理日志，记录的是 <strong>在某个数据页上做了修改</strong>，binlog 是逻辑日志记录的是语句逻辑 <strong>给 ID=2 的数据进行加 1</strong></li><li>redo log 是循环写，空间大小固定。bin log 是追加写，当 bin log 文件到达一定大小后会切换到下一个，不会覆盖以前的日志</li></ol><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><ol><li>更新语句的执行流程</li><li>Redo log 的作用是用来存储 MySQL 产生更新语句的物理日志。通过 WAL 技术先将日志写入 队列中然偶后通过指定条件写入磁盘中</li><li>bin log 的作用和特点</li><li>两种日志的不同点</li><li>两阶段提交的作用<ol><li>保证数据库的数据不冲突</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-更新语句执行流程&quot;&gt;&lt;a href=&quot;#1-更新语句执行流程&quot; class=&quot;headerlink&quot; title=&quot;1. 更新语句执行流程&quot;&gt;&lt;/a&gt;1. 更新语句执行流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuqu</summary>
      
    
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://xinc-it.github.io/tags/Mysql/"/>
    
    <category term="数据库" scheme="https://xinc-it.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="InnoDB" scheme="https://xinc-it.github.io/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-锁</title>
    <link href="https://xinc-it.github.io/2021/09/10/5!%E9%94%81/"/>
    <id>https://xinc-it.github.io/2021/09/10/5!%E9%94%81/</id>
    <published>2021-09-10T12:17:06.000Z</published>
    <updated>2022-08-08T02:50:59.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-锁的分类："><a href="#1-锁的分类：" class="headerlink" title="1. 锁的分类："></a>1. 锁的分类：</h2><p><strong>根据加锁范围：</strong></p><ol><li><strong>全局锁</strong></li><li><strong>表级锁</strong></li><li><strong>行锁</strong></li></ol><h2 id="2-全局锁"><a href="#2-全局锁" class="headerlink" title="2. 全局锁"></a>2. 全局锁</h2><p>全局读锁命令<br><strong>全局锁就是对整个数据库实例加锁，Mysql 提供了一个加全局读锁的命令。可以让整个数据库处于只读状态。</strong><br>导致数据的增删改、建表修改表语句、事务的提交语句失效。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure><p>场景：<strong>全库的逻辑备份(也可以开启可重复读事务级别来进行备份)</strong><br>另一种方式是使用 mysqldump 工具使用参数-single-transaction 进行数据库备份。前提：数据库中所有的表支持可重复读。</p><p>场景：用户买课和买课后的余额。不加锁导致两个表的数据前后不一致。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631018821575-900c6793-130c-47c3-8b6c-b3533bf27c70.png#clientId=uf02e59f4-5d80-4&from=paste&height=271&id=u5e04065e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=542&originWidth=882&originalType=binary&ratio=1&size=204494&status=done&style=none&taskId=uadb7ab82-ba93-48d1-a88f-e117005dcaf&width=441" alt="image.png"></p><h2 id="3-表级锁"><a href="#3-表级锁" class="headerlink" title="3. 表级锁"></a>3. 表级锁</h2><ol><li>两种表锁</li></ol><ul><li>表锁</li><li>元数据锁</li></ul><ol start="2"><li>表锁</li></ol><p>作用：<strong>锁定表只能进行读或读和写操作。不允许操作其他表。（处理并发的常用方式）</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock tables t1 read, t2 write;</span><br></pre></td></tr></table></figure><p>只能对 t1 表进行读，t2 表进行读和写。直到执行<strong>unlock tables</strong>之前不允许对其他表进行读写操作。</p><ol start="3"><li>MDL ( meatadata lock)</li></ol><p>作用：保证读写的正确性。防止 DDL(加字段等修改表结构的操作)和 DML 冲突（增删改数据）<br>特点： 自动加上，不需要使用 sql 语句。在对表进行数据的增删改查操作时加读锁。修改表结构时，加写锁。</p><p>读读锁共存、读写锁、写写锁互斥。</p><p><strong>示例</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634388295266-c5897d57-05ac-4ac9-b910-e2d9950d6f1e.png#clientId=ubaf7a982-8eca-4&from=paste&height=261&id=u0e8aeaeb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=521&originWidth=834&originalType=binary&ratio=1&size=78640&status=done&style=none&taskId=u2b78eb8a-f57d-433e-935f-d586ac65ede&width=417" alt="image.png"></p><p>在多个事务开启且未结束的过程中给某个表添加个字段导致读写锁冲突。</p><p>解决方法<br>在 information_schema 库中 innodb_trx 表中查询出正在执行事务，可以暂停表变更事务、或者是长事务。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><ol><li><p>全局锁主要是用来逻辑备份，有两种方式一种是通过命令 flush tables with read lock;。另一种需要支持库中所有的表支持可重复读事务，使用 mysqldump -single-transaction 进行备份。</p></li><li><p>表锁通过 sql 语句限制指定表只能进行读、读/写操作,且不允许对其他表操作在解锁前。</p></li><li><p>MDL 是自动加上的，不需要通过 sql 语句。存在读写锁、写写锁互斥情况。锁在事务提交后释放。作用是为了防止 DDL 和 DML 操作冲突。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-锁的分类：&quot;&gt;&lt;a href=&quot;#1-锁的分类：&quot; class=&quot;headerlink&quot; title=&quot;1. 锁的分类：&quot;&gt;&lt;/a&gt;1. 锁的分类：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;根据加锁范围：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;全局</summary>
      
    
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://xinc-it.github.io/tags/Mysql/"/>
    
    <category term="数据库" scheme="https://xinc-it.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="InnoDB" scheme="https://xinc-it.github.io/tags/InnoDB/"/>
    
  </entry>
  
</feed>
