<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>无♥部落阁</title>
  
  
  <link href="https://xinc-it.github.io/atom.xml" rel="self"/>
  
  <link href="https://xinc-it.github.io/"/>
  <updated>2024-11-21T17:02:44.670Z</updated>
  <id>https://xinc-it.github.io/</id>
  
  <author>
    <name>无♥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-求二叉树的最大深度</title>
    <link href="https://xinc-it.github.io/2024/11/21/LeetCode-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>https://xinc-it.github.io/2024/11/21/LeetCode-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2024-11-21T17:02:44.670Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h1><p><img src="https://img-blog.csdnimg.cn/20210117094814654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70"><br><strong>题目链接：</strong><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></p><h1 id="一、解题思路"><a href="#一、解题思路" class="headerlink" title="一、解题思路"></a>一、解题思路</h1><p>通过递归的方式，不断遍历其树的每一个节点。然后判断当前节点是否为空，不为空高度加 1,同时遍历当前节点的子节点，然后比较左右两节点的高度，返回最大的节点高度。反之则直接返回上一节点的高度。</p><h1 id="二、解题步骤"><a href="#二、解题步骤" class="headerlink" title="二、解题步骤"></a>二、解题步骤</h1><h2 id="1-详细步骤"><a href="#1-详细步骤" class="headerlink" title="1.详细步骤"></a>1.详细步骤</h2><ol><li>判断当前节点是否为空<ul><li>如果为空，直接返回上一节点的高度</li><li>反之高度加 1 ，并执行下一步</li></ul></li><li>继续递归调用该函数，将其节点设置为当前节点，同时高度设置为当前节点的高度。并设置变量用于获取函数的返回值。</li><li>比较左右两个节点函数返回值，取其最大值。</li></ol><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeight(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxHeight</span><span class="params">(TreeNode root,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            height++;</span><br><span class="line">            <span class="keyword">int</span> leftHeight=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> rightHeight=<span class="number">0</span>;</span><br><span class="line">            leftHeight=maxHeight(root.left,height);</span><br><span class="line">            rightHeight=maxHeight(root.right,height);</span><br><span class="line">            <span class="keyword">return</span> leftHeight&gt;rightHeight?leftHeight:rightHeight;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>这里面主要用到了递归的思想。递归在与树有关的很多的题目都可以使用该思想。通过该思想可以很大程度上简化代码。但是也不是没有缺点，如果递归次数过多的话，可能会造成堆栈溢出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目详情&quot;&gt;&lt;a href=&quot;#题目详情&quot; class=&quot;headerlink&quot; title=&quot;题目详情&quot;&gt;&lt;/a&gt;题目详情&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117094814654.png?x-</summary>
      
    
    
    
    <category term="算法" scheme="https://xinc-it.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://xinc-it.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://xinc-it.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-汉明距离</title>
    <link href="https://xinc-it.github.io/2024/11/21/LeetCode-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    <id>https://xinc-it.github.io/2024/11/21/LeetCode-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</id>
    <published>2024-11-21T17:02:44.670Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/eb8bf20167f1cc2d7f1d9c054ec9d21b.png"></p><h1 id="一、解题思路"><a href="#一、解题思路" class="headerlink" title="一、解题思路"></a>一、解题思路</h1><p>这里有两种解题思路</p><h2 id="1-位运算法"><a href="#1-位运算法" class="headerlink" title="1. 位运算法"></a>1. 位运算法</h2><p><strong>位运算</strong>如果你不了解的话，可以看下第二种解题思路。但是整体代码有点冗余，而且效率也不高。<br><code>^</code>的运算规则二进制位中各个位上数就是相同为 0，不同为 1。<br><code>&amp;</code>的运算规则是都为 1 时结果为 1，反之全为 0。<br><code>|</code>的运算规则是只要有 1 结果为 1，反之为 0。<br><code>&gt;&gt;</code>当前数二级制向右移一位，同时最高位根据数的正负来补 0 或 1<br><code>&lt;&lt;</code> 当前数二进制向左移一位，同时最低位补 0。</p><p><strong>位运算法</strong></p><ol><li> 将两个数<code>^</code>运算</li><li>判断运算结果中 1 的个数。即为两个数二进制中各个位的值不同的个数<br> 这里有两种计算 1 个数的方法<br> 2.1.1   将运算结果按 2 求余，如果为 1 就个数加 1。反之就忽略<br> 2.1.2 将运算结果右移一位。并重复上述步骤 32 次。<br> 2.2.1 将运算结果和运算结果-1 进行<code>&amp;</code>运算，然后将值返回作为新的运算结果。1 的个数加 1。<br> 2.2.2 直到运算结果为 0 时跳出循环</li></ol><h2 id="2-暴力破解法"><a href="#2-暴力破解法" class="headerlink" title="2. 暴力破解法"></a>2. 暴力破解法</h2><ol><li>将上述两个数将其二进制位分别放入到不同的 List 容器中</li><li>判断两个容器的长度，将长度较大的容器作为遍历次数</li><li>获取两个容器中当前索引的值，并判断是否相等，如果不等距离加 1</li><li>如果较小容器遍历完了的话，就判断较大容器中的值是否等于 0。如果不等距离加 1</li><li>最后得到的距离即为结果</li></ol><h1 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h1><h2 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1.位运算"></a>1.位运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> res=x^y;</span><br><span class="line">     <span class="keyword">int</span> times=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(res!=<span class="number">0</span>)&#123;</span><br><span class="line">       res=res&amp;(res-<span class="number">1</span>);</span><br><span class="line">       times++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> times;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-暴力破解"><a href="#2-暴力破解" class="headerlink" title="2.暴力破解"></a>2.暴力破解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">       ArrayList&lt;Integer&gt; xArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">do</span>&#123;</span><br><span class="line">       xArray.add(x%<span class="number">2</span>);</span><br><span class="line">       x=x/<span class="number">2</span>;</span><br><span class="line">     &#125;<span class="keyword">while</span>(x!=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Integer&gt; yArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">do</span>&#123;</span><br><span class="line">       yArray.add(y%<span class="number">2</span>);</span><br><span class="line">       y=y/<span class="number">2</span>;</span><br><span class="line">     &#125;<span class="keyword">while</span>(y!=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> distance=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">//当y的二进制更长时</span></span><br><span class="line">       <span class="keyword">if</span>(yArray.size()&gt;=xArray.size())&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;yArray.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;xArray.size())&#123;</span><br><span class="line">                   <span class="keyword">if</span>(yArray.get(j)!=xArray.get(j))&#123;</span><br><span class="line">                       distance++;</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(yArray.get(j)!=<span class="number">0</span>)&#123;</span><br><span class="line">                        distance++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;<span class="comment">//x的二进制更长</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;xArray.size();j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(j&lt;yArray.size())&#123;</span><br><span class="line">                   <span class="keyword">if</span>(yArray.get(j)!=xArray.get(j))&#123;</span><br><span class="line">                       distance++;</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(xArray.get(j)!=<span class="number">0</span>)&#123;</span><br><span class="line">                        distance++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> distance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我一开始使用的暴力破解法。但觉得暴力破解法太麻烦了。所以就去看了官方的解题教程，发现位运算这一方法更为简单和高效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/eb8bf20167f1</summary>
      
    
    
    
    <category term="算法" scheme="https://xinc-it.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://xinc-it.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://xinc-it.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode之合并二叉树</title>
    <link href="https://xinc-it.github.io/2024/11/21/LeetCode%E4%B9%8B%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://xinc-it.github.io/2024/11/21/LeetCode%E4%B9%8B%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2024-11-21T17:02:44.670Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p><img src="https://img-blog.csdnimg.cn/20201219005707214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70"></p><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>采用递归和后序遍历的方式来同时遍历两棵树。遍历的同时，一定要判断两颗树的当前节点是否为空。然后创建一个新的节点，节点值为两个节点之和。遍历完成后即可得到合并后的树。</p><h2 id="3-解题步骤"><a href="#3-解题步骤" class="headerlink" title="3. 解题步骤"></a>3. 解题步骤</h2><ol><li> 判断当前两颗树的节点全为空，如果为空则返回空。</li><li>反之有以下三种<ul><li>可能两个节点都不为空</li><li>左节点为空，右节点不为空</li><li>右节点为空，左节点不为空</li></ul></li><li>采取以下措施<ul><li>当为第一种情况时 ,创建一个新的节点，节点值为左右节点值的和,之后遍历左右节点</li><li>当为第二种情况时 ,创建一个新的节点，节点值为右节点值,之后遍历右节点.</li><li>当为第三种情况时 ,创建一个新的节点，节点值为左节点值,之后遍历左节点。</li></ul></li><li> 返回创建的新的节点。</li></ol><h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">null</span>&amp;&amp;t2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode t3;</span><br><span class="line">            <span class="keyword">if</span>(t1!=<span class="keyword">null</span>&amp;&amp;t2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                t3=<span class="keyword">new</span> TreeNode(t1.val+t2.val);</span><br><span class="line">                t3.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">                t3.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                t3=<span class="keyword">new</span> TreeNode(t1.val);</span><br><span class="line">                t3.right=mergeTrees(t1.right,<span class="keyword">null</span>);</span><br><span class="line">                t3.left=mergeTrees(t1.left,<span class="keyword">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t3=<span class="keyword">new</span> TreeNode(t2.val);</span><br><span class="line">                t3.right=mergeTrees(<span class="keyword">null</span>,t2.right);</span><br><span class="line">                t3.left=mergeTrees(<span class="keyword">null</span>,t2.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>以目前我做的与树相关的题目来说。所需要做的事基本上就是一件事：<strong>遍历</strong>。而树的遍历一般可以通过递归的方式来进行一些简单的遍历。遍历一般分为三种：前序遍历、中序遍历、后序遍历。前序、中序、后序的名字是按照遍历中父节点，相对于左右子节点中的顺序。如果父节点，在其子父节点中最后一个遍历，称之为后序遍历。其他的遍历顺序可由以上类推。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;合并二叉树&quot;&gt;&lt;a href=&quot;#合并二叉树&quot; class=&quot;headerlink&quot; title=&quot;合并二叉树&quot;&gt;&lt;/a&gt;合并二叉树&lt;/h1&gt;&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1. 题目</summary>
      
    
    
    
    <category term="算法" scheme="https://xinc-it.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://xinc-it.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://xinc-it.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode将有序数组转化为二叉搜索树</title>
    <link href="https://xinc-it.github.io/2024/11/21/LeetCode%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://xinc-it.github.io/2024/11/21/LeetCode%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2024-11-21T17:02:44.670Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、将有序数组转化为二叉搜索树"><a href="#一、将有序数组转化为二叉搜索树" class="headerlink" title="一、将有序数组转化为二叉搜索树"></a>一、将有序数组转化为二叉搜索树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://img-blog.csdnimg.cn/20201219235754380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70"><br><strong>详情链接：</strong><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">有序数组转二叉树</a></p><h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><h2 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1.解题思路"></a>1.解题思路</h2><p>将当前数组的中间值用于创建当前的节点，然后中间值左边的数，分为一个新的子数组，这里我们暂且叫左子数组，将右边的分为右子数组。将左子数组放入当前节点的左子树。右子树组，放入当前节点的右子树。重复上述步骤即可。</p><h2 id="2-解题步骤"><a href="#2-解题步骤" class="headerlink" title="2.解题步骤"></a>2.解题步骤</h2><ol><li>创建一个新的节点节点值为数组的中位值 。</li><li>判断当前子数组大小是否为 1。</li></ol><ul><li>如果为 1，则直接返回该节点。</li><li>反之执行第三步。</li></ul><ol start="3"><li>判断当前数组的 <strong>(中间值得索引-1)&gt;=0</strong>， <strong>就是判断当前节点是否存在左子树</strong>。</li></ol><ul><li><pre><code>如果大于0，创建一个新的数组命名为左子数组，值为当前数组的中间值左边的所有数值。然后将将左子数组传入当前函数执行。</code></pre></li><li>反之，则表明数组越界。直接执行第四步</li></ul><ol start="4"><li>判断当前数组的**(中间值的索引是+1)&lt;=当前数组的长度** ，就是判断当前节点是否存在右子树。</li></ol><ul><li>如果小于的话，创建一个新的数组命名为右子数组，值为当前数组的中间值右边的所有数值。然后将将右子数组传入当前函数执行。</li><li>反之，执行第五步</li></ul><ol start="5"><li>返回当前节点。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;&#123;</span><br><span class="line">            <span class="keyword">return</span> arrrayToBST(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">arrrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start ,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> length=end-start+<span class="number">1</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(nums[start+length/<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(length/<span class="number">2</span>-<span class="number">1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                root.left=arrrayToBST(nums,start,start+length/<span class="number">2</span>-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(length/<span class="number">2</span>+<span class="number">1</span>&lt;=length-<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                root.right=arrrayToBST(nums,start+length/<span class="number">2</span>+<span class="number">1</span>,end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>树的问题一般是通过递归和三种遍历方式来解决。目前我所写的很多树的比较简单的题目都是通过递归和树的三种遍历方式来实现的。</p><p><strong>各位大佬们看完后觉得我写得很差的的话，可以在评论去疯狂踩踏我蹂躏我。但是最最为重要的事就是不要白嫖！！！！虽然我知道在看的各位都是白嫖党！！！！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、将有序数组转化为二叉搜索树&quot;&gt;&lt;a href=&quot;#一、将有序数组转化为二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;一、将有序数组转化为二叉搜索树&quot;&gt;&lt;/a&gt;一、将有序数组转化为二叉搜索树&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://xinc-it.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://xinc-it.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://xinc-it.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode递增顺序查找树</title>
    <link href="https://xinc-it.github.io/2024/11/21/LeetCode%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>https://xinc-it.github.io/2024/11/21/LeetCode%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/</id>
    <published>2024-11-21T17:02:44.670Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h1><p><img src="https://img-blog.csdnimg.cn/20210104232857846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70"><br><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">题目详情链接</a></p><h1 id="一、解题思路"><a href="#一、解题思路" class="headerlink" title="一、解题思路"></a>一、解题思路</h1><p>将原树进行中序遍历将树中的节点的非空值放入到一个 list 集合中，创建一棵新树然后通过递归的方式将不断生成的新的右子树直到集合遍历完。</p><h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.对原树进行中序遍历。将非空树的值一次放入到List集合中。</span><br><span class="line">2.创建一个函数用于对集合进行遍历，将每次遍历得到的值用来创建当前树的值。</span><br><span class="line">  在集合遍历完之前，继续递归该函数，将传递的实参改为当前树的右子树。</span><br></pre></td></tr></table></figure><h1 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           ArrayList array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Solution s=<span class="keyword">new</span> Solution();</span><br><span class="line">            s.inOrderTraversal(root,array);</span><br><span class="line">           root=s.toTree(<span class="keyword">null</span>,array,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过递归的方式不断将集合中的值有做新的右子树的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">toTree</span><span class="params">(TreeNode root,List&lt;Integer&gt; array,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        root=<span class="keyword">new</span> TreeNode(array.get(length));</span><br><span class="line">        root.left=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;array.size()-<span class="number">1</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            root.right=toTree(root.right,array,length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraversal</span><span class="params">(TreeNode root,List&lt;Integer&gt; array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           inOrderTraversal(root.left,array);</span><br><span class="line">           array.add(root.val);</span><br><span class="line">           inOrderTraversal(root.right,array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在我看来树的重点需要掌握的就是树的遍历方式。前序、中序、后序、层序。基本上许多和树有关的题目都会涉及到他的遍历方式。这些方式都可以通过递归的方式来实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目详情&quot;&gt;&lt;a href=&quot;#题目详情&quot; class=&quot;headerlink&quot; title=&quot;题目详情&quot;&gt;&lt;/a&gt;题目详情&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210104232857846.png?x-</summary>
      
    
    
    
    <category term="算法" scheme="https://xinc-it.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://xinc-it.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://xinc-it.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity中执行表单登录认证时无法执行loadUserByUsername方法</title>
    <link href="https://xinc-it.github.io/2024/11/21/SpringSecurity%E4%B8%AD%E6%89%A7%E8%A1%8C%E8%A1%A8%E5%8D%95%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E6%97%B6%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8CloadUserByUsername%E6%96%B9%E6%B3%95/"/>
    <id>https://xinc-it.github.io/2024/11/21/SpringSecurity%E4%B8%AD%E6%89%A7%E8%A1%8C%E8%A1%A8%E5%8D%95%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E6%97%B6%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8CloadUserByUsername%E6%96%B9%E6%B3%95/</id>
    <published>2024-11-21T17:02:44.670Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目场景："><a href="#项目场景：" class="headerlink" title="项目场景："></a>项目场景：</h1><p>执行表单登录认证时配置了 loginProcessUrl 和 loginPage。但是执行登录认证时并不执行 UserDetailsService 接口的 loadByUsername 方法。导致认证失败。</p><h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><h2 id="1-表单登录页面"><a href="#1-表单登录页面" class="headerlink" title="1. 表单登录页面"></a>1. 表单登录页面</h2><p><img src="https://img-blog.csdnimg.cn/20210513173942750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70"></p><h2 id="2-配置类"><a href="#2-配置类" class="headerlink" title="2. 配置类"></a>2. 配置类</h2><p><img src="https://img-blog.csdnimg.cn/20210513173201531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70"></p><h2 id="3-loadUserByUsername-方法"><a href="#3-loadUserByUsername-方法" class="headerlink" title="3. loadUserByUsername 方法"></a>3. loadUserByUsername 方法</h2><p><img src="https://img-blog.csdnimg.cn/20210513173433199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70"></p><h4 id="所有都配置好了，但是进行登录认证的时候还是认证失败跳回登录页。并且控制台未打印-loadUserByUsername-方法中的日志。"><a href="#所有都配置好了，但是进行登录认证的时候还是认证失败跳回登录页。并且控制台未打印-loadUserByUsername-方法中的日志。" class="headerlink" title="所有都配置好了，但是进行登录认证的时候还是认证失败跳回登录页。并且控制台未打印 loadUserByUsername 方法中的日志。"></a>所有都配置好了，但是进行登录认证的时候还是认证失败跳回登录页。并且控制台未打印 loadUserByUsername 方法中的日志。</h4><p><img src="https://img-blog.csdnimg.cn/20210513173819188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210513173839414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70"></p><h1 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h1><p>因此判断是 loginProcessUrl 方法的问题。进入 loginProcessUrl 方法内部发现。关键信息<br><img src="https://img-blog.csdnimg.cn/20210513174339209.png"><br>登录表单申请方式必须为 post 才行，springsecurity 才会进行登录认证。</p><hr><h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><h2 id="将登录表单中提交方法更改为-post-方式即可"><a href="#将登录表单中提交方法更改为-post-方式即可" class="headerlink" title="将登录表单中提交方法更改为 post 方式即可"></a>将登录表单中提交方法更改为 post 方式即可</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目场景：&quot;&gt;&lt;a href=&quot;#项目场景：&quot; class=&quot;headerlink&quot; title=&quot;项目场景：&quot;&gt;&lt;/a&gt;项目场景：&lt;/h1&gt;&lt;p&gt;执行表单登录认证时配置了 loginProcessUrl 和 loginPage。但是执行登录认证时并不执行 Use</summary>
      
    
    
    
    <category term="Java" scheme="https://xinc-it.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://xinc-it.github.io/tags/Java/"/>
    
    <category term="SpringSecurity" scheme="https://xinc-it.github.io/tags/SpringSecurity/"/>
    
    <category term="开发问题" scheme="https://xinc-it.github.io/tags/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xinc-it.github.io/2024/11/21/switchhost%E4%BF%AE%E6%94%B9%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90%E5%8E%9F%E5%9B%A0/"/>
    <id>https://xinc-it.github.io/2024/11/21/switchhost%E4%BF%AE%E6%94%B9%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90%E5%8E%9F%E5%9B%A0/</id>
    <published>2024-11-21T17:02:44.670Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<ol><li>host 文件为只读，取消 host 文件只读属性，并且为所有用户增加写入和修改权限</li><li>系统 hosts 文件无法修改需要添加文件进行修改</li><li>杀毒软件拦截 host 文件修改，建议退出杀毒软件尝试</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;host 文件为只读，取消 host 文件只读属性，并且为所有用户增加写入和修改权限&lt;/li&gt;
&lt;li&gt;系统 hosts 文件无法修改需要添加文件进行修改&lt;/li&gt;
&lt;li&gt;杀毒软件拦截 host 文件修改，建议退出杀毒软件尝试&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Shiro官方文档笔记</title>
    <link href="https://xinc-it.github.io/2024/11/21/Shiro%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/"/>
    <id>https://xinc-it.github.io/2024/11/21/Shiro%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/</id>
    <published>2024-11-21T17:02:44.670Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-核心架构"><a href="#1-核心架构" class="headerlink" title="1. 核心架构"></a>1. 核心架构</h1><h2 id="1-核心流程"><a href="#1-核心流程" class="headerlink" title="1. 核心流程"></a>1. 核心流程</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/f0ce7abbc21ee54f870ed39a960ba893.png"></p><h3 id="1-Subject"><a href="#1-Subject" class="headerlink" title="1.  Subject"></a>1.  Subject</h3><p>指需要认证的用户信息实体，subject 需要通过 securityManager 指定 Realm 来查询是否存在改用户信息和给用户进行授权的操作</p><h3 id="2-SecurityManager"><a href="#2-SecurityManager" class="headerlink" title="2. SecurityManager"></a>2. SecurityManager</h3><p>shiro 体系的核心。协调内部安全组件。如：Realm 等。</p><h3 id="3-Realm"><a href="#3-Realm" class="headerlink" title="3. Realm"></a>3. Realm</h3><p>通过查询特定的数据源：数据库、LDAP 等。来对 Subject 进行认证和授权操作。</p><h2 id="2-核心架构"><a href="#2-核心架构" class="headerlink" title="2. 核心架构"></a>2. 核心架构</h2><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FMppfyoU-1624680171088)(<a href="https://i.loli.net/2021/06/25/tADiGzO3lZpfrYW.png">https://i.loli.net/2021/06/25/tADiGzO3lZpfrYW.png</a>)]</p><h3 id="1-Authenticator-认证器"><a href="#1-Authenticator-认证器" class="headerlink" title="1. Authenticator 认证器"></a>1. Authenticator 认证器</h3><p>对 Subject 中的信息进行认证。通过将 Subject 的信息传入 Realm 查询指定数据源来进行认证判断。<br>当用户尝试登录时，执行认证器。</p><h3 id="2-AuthenticationStrategy-认证策略器"><a href="#2-AuthenticationStrategy-认证策略器" class="headerlink" title="2. AuthenticationStrategy 认证策略器"></a>2. AuthenticationStrategy 认证策略器</h3><p>如果配置了多个多个 Realm，则通过认证策略器来决定认证成功和认证失败的情况。</p><h3 id="3-Authorizer-授权器"><a href="#3-Authorizer-授权器" class="headerlink" title="3. Authorizer 授权器"></a>3. Authorizer 授权器</h3><p>用于对认证成功后的 Subject 进行授权操作。通过 Realm 查询到用户的对应信息给用户授予对应的权力</p><h3 id="4-SessionManager-会话管理器"><a href="#4-SessionManager-会话管理器" class="headerlink" title="4. SessionManager 会话管理器"></a>4. SessionManager 会话管理器</h3><p>Shiro 自带的会话管理器。能够创建和管理用户的 Session 生命周期。提供一种可靠的会话体验。默认情况下，Shiro 使用现有的会话机制机制如 Servlet 容器。</p><h3 id="5-SessionDao-会话持久器"><a href="#5-SessionDao-会话持久器" class="headerlink" title="5. SessionDao 会话持久器"></a>5. SessionDao 会话持久器</h3><p>将 Session Manager 中的 Session 对象进行 CRUD 操作将其存储起来。</p><h3 id="6-CacheManager-缓存管理器"><a href="#6-CacheManager-缓存管理器" class="headerlink" title="6. CacheManager 缓存管理器"></a>6. CacheManager 缓存管理器</h3><p>用于缓存 Shiro 中的 Realm 中的数据</p><h3 id="7-Crypto-加密"><a href="#7-Crypto-加密" class="headerlink" title="7. Crypto 加密"></a>7. Crypto 加密</h3><p>Shiro 中一个简单易用的加密包。针对于 Java 的加密机制，Shiro 的加密 Api 更加简单易用。</p><h3 id="8-Realm-领域"><a href="#8-Realm-领域" class="headerlink" title="8. Realm 领域"></a>8. Realm 领域</h3><p>用于查询数据数据源的信息。通过将查询到用户信息返回给认证器和授权器。进行认证和授权。</p><p>Security Manager 中的默认实现的功能</p><ul><li>Authentication 认证</li><li>Authorization 授权</li><li>Session Management   会话管理</li><li>Cache Management 缓存管理</li><li><a href="https://shiro.apache.org/realm.html">Realm</a> coordination   领域协调</li><li>Event propagation 事件传播</li><li>“Remember Me” Services   记住我服务</li><li>Subject creation Subject 对象的创建</li><li>Logout   注销</li></ul><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="2-身份认证"><a href="#2-身份认证" class="headerlink" title="2. 身份认证"></a>2. 身份认证</h1><p>Subject 的构成</p><ol><li>principals</li></ol><p>通俗点来说就是用户的用户名，可以用来表示用户身份的证明。当然并不是唯一的。</p><ol start="2"><li>credentials</li></ol><p>可以用来证明该用户身份的证据。通常指的是密码或证书等。</p><h2 id="1-认证-Subjects"><a href="#1-认证-Subjects" class="headerlink" title="1. 认证 Subjects"></a>1. 认证 Subjects</h2><ol><li>获取 Subject 中的 principals 和 Credentials</li><li>提交 principals 和 credentials 来进行认证操作</li><li>认证成功，则允许访问。反之阻止访问和进行新的认证</li></ol><p>实例演示：</p><ol><li><strong>获取 principals 和 credentials</strong></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Example using most common scenario of username/password pair:</span><br><span class="line">UsernamePasswordToken token = new UsernamePasswordToken(username, password);</span><br><span class="line">//&quot;Remember Me&quot; built-in: token.setRememberMe(true);</span><br></pre></td></tr></table></figure><p>UsernamePasswordToken 是用来进行 Shiro 进行认证的接口对象。Shiro 中的认证需要认证的信息都要封装成 AuthenticationToken 接口的对象。UsernamePassowrdToken 是其接口的实现。<br>**</p><ol start="2"><li>** 提交 priincipals 和 credentials**</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject(); currentUser.login(token);</span><br></pre></td></tr></table></figure><p>** **subject 对象通过 login 方法将认证信息进行认证提交</p><ol start="3"><li><strong>认证成功或失败</strong></li></ol><p>**<br>当认证成功后即可成功访问，如果失败 Shiro 会抛出异常。通过异常可以知道认证失败的原因。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123; currentUser.login(token); &#125; catch ( UnknownAccountException uae ) &#123; ... &#125;</span><br><span class="line">catch ( IncorrectCredentialsException ice ) &#123; ... &#125; catch (</span><br><span class="line">LockedAccountException lae ) &#123; ... &#125; catch ( ExcessiveAttemptsException eae ) &#123;</span><br><span class="line">... &#125; ... catch your own ... &#125; catch ( AuthenticationException ae ) &#123;</span><br><span class="line">//unexpected error? &#125; //No problems, continue on as expected...</span><br></pre></td></tr></table></figure><h2 id="2-Remember-Me-和-Authenticated"><a href="#2-Remember-Me-和-Authenticated" class="headerlink" title="2. Remember Me 和 Authenticated"></a>2. Remember Me 和 Authenticated</h2><ol><li><strong>Remember me</strong></li></ol><ul><li>使用的是先前会话的 Subject</li><li>并且 Subject 是非匿名的</li><li>通过调用 isRemembered 方法返回的 true</li></ul><ol start="2"><li><strong>Authenticated</strong></li></ol><ul><li>当前认证成功的 subject</li><li>调用 isAuthenticated 返回 true</li></ul><p><strong>记住和已认证两种状态不能同时发生在同一 subject 上。</strong></p><h3 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h3><p>以下是一个相当常见的场景，有助于说明为什么记住和已认证之间的区别很重要。<br>假设您使用的是<a href="https://www.amazon.com/">Amazon.com</a>。您已成功登录，并已在购物车中添加了几本书。但是您必须参加会议，但忘记注销。会议结束时，该回家了，您离开办公室了。<br>第二天上班时，您发现自己还没有完成购买，因此回到 amazon.com。这次，亚马逊“记住”您的身份，以名字向您打招呼，并仍然为您提供一些个性化的书本推荐。对于亚马逊，<code>subject.isRemembered()</code>将返回<code>true</code>。<br>但是，如果您尝试访问帐户以更新信用卡信息以购买图书，会发生什么情况？当亚马逊“记住”您(<code>isRemembered()</code> == <code>true</code>)时，它不能保证您实际上就是您(例如，某个同事正在使用您的计算机)。<br>因此，在您执行敏感操作(如更新信用卡信息)之前，亚马逊会强迫您登录，以便他们保证您的身份。登录后，您的身份已通过验证，并且到亚马逊的<code>isAuthenticated()</code>现在为<code>true</code>。<br>这种情况在许多类型的应用程序中经常发生，因此该功能是 Shiro 内置的，因此您可以将其用于自己的应用程序。现在，是否使用<code>isRemembered()</code>或<code>isAuthenticated()</code>来定制视图和工作流已由您决定，但是 Shiro 将保留此基本状态，以备不时之需。</p><h2 id="3-注销"><a href="#3-注销" class="headerlink" title="3. 注销"></a>3. 注销</h2><p>当 Subject 调用 logout 方法后任何现有的 Session 都将失效并且任何身份都会被取消关联。</p><h2 id="4-认证流程"><a href="#4-认证流程" class="headerlink" title="4. 认证流程"></a>4. 认证流程</h2><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WFk3b6E6-1624680171090)(<a href="https://i.loli.net/2021/06/25/qGAUkvJCdIhjpFw.png">https://i.loli.net/2021/06/25/qGAUkvJCdIhjpFw.png</a>)]</p><p><strong>step1：</strong><br>调用 login 方法提交认证信息</p><p><strong>step2：</strong><br>调用 security Mangager.login（token）来通过 securityManager 开始真正的身份认证</p><p><strong>step3:</strong><br>securityManager 接收 token 并调用 authenticator.authenticate(token)将认证信息提供给认证器进行认证。<br><strong>step4：</strong></p><p>shiro 默认使用的 MoularRealmAuthenticator 实例通过 Realm 进行认证。如果配置了多个 Realm 则使用认证策略其，来进行多次的 Realm 认证。来决定认证成功和失败的条件。<br><strong>只有一个 Realm 的话不需要认证策略器</strong><br>**<br><strong>step5:</strong><br>咨询已配置的 Realm，通过使用 supports 方法判断其是否支持验证其身份信息，如果返回 true。则调用 Realm 的 getAuthenticationInfo 方法获取认证信息。</p><p>**<br>**</p><h1 id="3-授权"><a href="#3-授权" class="headerlink" title="3. 授权"></a>3. 授权</h1><h2 id="1-授权要素"><a href="#1-授权要素" class="headerlink" title="1. 授权要素"></a>1. 授权要素</h2><ul><li>权限：在程序中，表示用户可以执行什么动作或行为</li><li>角色：是一个或多个权限的集合实体。</li><li>用户：是一个或多个角色的集合实体。</li></ul><h2 id="2-授权-Subjects"><a href="#2-授权-Subjects" class="headerlink" title="2.授权 Subjects"></a>2.授权 Subjects</h2><h3 id="1-编程授权"><a href="#1-编程授权" class="headerlink" title="1. 编程授权"></a>1. 编程授权</h3><h4 id="1-基于角色的授权"><a href="#1-基于角色的授权" class="headerlink" title="1. 基于角色的授权"></a>1. 基于角色的授权</h4><p>通过用户是否含有特定角色，来执行角色检查</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject(); if</span><br><span class="line">(currentUser.hasRole(&quot;administrator&quot;)) &#123; //show the admin button &#125; else &#123;</span><br><span class="line">//don&#x27;t show the button? Grey it out? &#125; Subject currentUser =</span><br><span class="line">SecurityUtils.getSubject(); //guarantee that the current user is a bank teller</span><br><span class="line">and //therefore allowed to open the account:</span><br><span class="line">currentUser.checkRole(&quot;bankTeller&quot;); openBankAccount();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/c3804a3a99297afbbe4a0b3a0a22edf6.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/0fddec08dec8177dfa97498c8f147800.png"></p><h4 id="2-基于权限的授权"><a href="#2-基于权限的授权" class="headerlink" title="2. 基于权限的授权"></a>2. 基于权限的授权</h4><p>与基于角色类似<img src="https://img-blog.csdnimg.cn/img_convert/045518ca2b12eaf21f9b4aa2faf2611a.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f2894b3d16202e20863f31d4b10a6ff.png"></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dUuiGDuP-1624680171097)(<a href="https://i.loli.net/2021/06/25/ZKQJUnhEvT6a5ky.png">https://i.loli.net/2021/06/25/ZKQJUnhEvT6a5ky.png</a>)]</p><h3 id="2-基于注解授权"><a href="#2-基于注解授权" class="headerlink" title="2. 基于注解授权"></a>2. 基于注解授权</h3><p><strong>前提：</strong><br>需要在程序中开启 Aop 支持</p><h4 id="1-RequiresAuthentication-注解"><a href="#1-RequiresAuthentication-注解" class="headerlink" title="1. RequiresAuthentication 注解"></a>1. RequiresAuthentication 注解</h4><p>调用该方法时要求用户在当前会话期间认证过</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequiresAuthentication public void updateAccount(Account userAccount) &#123; //this</span><br><span class="line">method will only be invoked by a //Subject that is guaranteed authenticated ...</span><br><span class="line">&#125; //等价于 public void updateAccount(Account userAccount) &#123; if</span><br><span class="line">(!SecurityUtils.getSubject().isAuthenticated()) &#123; throw new</span><br><span class="line">AuthorizationException(...); &#125; //Subject is guaranteed authenticated here ... &#125;</span><br></pre></td></tr></table></figure><h4 id="2-RequiresGuest-注解"><a href="#2-RequiresGuest-注解" class="headerlink" title="2. RequiresGuest 注解"></a>2. RequiresGuest 注解</h4><p>不需要身份认证即可访问的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RequiresGuest public void signUp(User newUser) &#123; //this method will only be</span><br><span class="line">invoked by a //Subject that is unknown/anonymous ... &#125; //等价于 public void</span><br><span class="line">signUp(User newUser) &#123; Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">PrincipalCollection principals = currentUser.getPrincipals(); if (principals !=</span><br><span class="line">null &amp;&amp; !principals.isEmpty()) &#123; //known identity - not a guest: throw new</span><br><span class="line">AuthorizationException(...); &#125; //Subject is guaranteed to be a &#x27;guest&#x27; here ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-RequiresPermissions-注解"><a href="#3-RequiresPermissions-注解" class="headerlink" title="3. RequiresPermissions 注解"></a>3. RequiresPermissions 注解</h4><p>要求用户必须有该权限才能调用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RequiresPermissions(&quot;account:create&quot;) public void createAccount(Account</span><br><span class="line">account) &#123; //this method will only be invoked by a Subject //that is permitted</span><br><span class="line">to create an account ... &#125; public void createAccount(Account account) &#123; Subject</span><br><span class="line">currentUser = SecurityUtils.getSubject(); if</span><br><span class="line">(!subject.isPermitted(&quot;account:create&quot;)) &#123; throw new</span><br><span class="line">AuthorizationException(...); &#125; //Subject is guaranteed to be permitted here ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-RequiresRoles-注解"><a href="#4-RequiresRoles-注解" class="headerlink" title="4. RequiresRoles 注解"></a>4. RequiresRoles 注解</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequiresRoles(&quot;administrator&quot;) public void deleteUser(User user) &#123; //this</span><br><span class="line">method will only be invoked by an administrator ... &#125; public void</span><br><span class="line">deleteUser(User user) &#123; Subject currentUser = SecurityUtils.getSubject(); if</span><br><span class="line">(!subject.hasRole(&quot;administrator&quot;)) &#123; throw new AuthorizationException(...); &#125;</span><br><span class="line">//Subject is guaranteed to be an &#x27;administrator&#x27; here ... &#125;</span><br></pre></td></tr></table></figure><h4 id="5-RequiresUser-注解"><a href="#5-RequiresUser-注解" class="headerlink" title="5. RequiresUser 注解"></a>5. RequiresUser 注解</h4><p>要求用户在当前会话期间进行了会话认证或者是是哦那个 Remember Me 服务被记住</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequiresUser public void updateAccount(Account account) &#123; //this method will</span><br><span class="line">only be invoked by a &#x27;user&#x27; //i.e. a Subject with a known identity ... &#125; public</span><br><span class="line">void updateAccount(Account account) &#123; Subject currentUser =</span><br><span class="line">SecurityUtils.getSubject(); PrincipalCollection principals =</span><br><span class="line">currentUser.getPrincipals(); if (principals == null || principals.isEmpty()) &#123;</span><br><span class="line">//no identity - they&#x27;re anonymous, not allowed: throw new</span><br><span class="line">AuthorizationException(...); &#125; //Subject is guaranteed to have a known identity</span><br><span class="line">here ... &#125;</span><br></pre></td></tr></table></figure><h3 id="3-基于-jsp-标签授权"><a href="#3-基于-jsp-标签授权" class="headerlink" title="3. 基于 jsp 标签授权"></a>3. 基于 jsp 标签授权</h3><h3 id="对应目录-jsp-标签库"><a href="#对应目录-jsp-标签库" class="headerlink" title="对应目录 jsp 标签库"></a>对应目录 jsp 标签库</h3><h2 id="3-授权流程"><a href="#3-授权流程" class="headerlink" title="3. 授权流程"></a>3. 授权流程</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/8b954ab61a6a1614a4029bbf0e7b17ea.png"></p><p><strong>step1:</strong><br>subject 通过调用一些角色和权限的判断方法</p><p><strong>step2:</strong><br>securityManager 调用上面相同的角色和权限的方法</p><p><strong>step3:</strong><br>securityManager 调用 authorizer 默认实例 ModularRealmAuthorizer 实列</p><p><strong>step4:</strong><br>使用 Realm 获取用户对应的权限信息</p><h1 id="4-领域"><a href="#4-领域" class="headerlink" title="4. 领域"></a>4. 领域</h1><h2 id="1-领域认证"><a href="#1-领域认证" class="headerlink" title="1.领域认证"></a>1.领域认证</h2><h3 id="1-领域认证流程"><a href="#1-领域认证流程" class="headerlink" title="1. 领域认证流程"></a>1. 领域认证流程</h3><p>如果调用 Realm 方法支持提交的 AuthenticationToken，则调用 Realm 的 getAuthenticationInfo 方法。然后通过该方法可以获取对应 token 在领域数据源的数据。方法执行顺序为</p><ol><li>识别 token 中的 principal 信息</li><li>根据 principal 查找对应数据源中对应的数据</li><li>确保 token 中的 credentials 与对应数据库中的数据匹配</li><li>匹配返回 AuthenticationInfo 实例，反之则抛出 AuthenticationException</li></ol><p><strong>领域认证可以通过实现 AuthorizingRealm 抽象类来实现领域认证。</strong></p><h3 id="2-凭证匹配"><a href="#2-凭证匹配" class="headerlink" title="2. 凭证匹配"></a>2. 凭证匹配</h3><p>在领域认证流程中领域必须验证 Subject 提交的 credentials 和数据库中存储的凭据是否匹配。如果匹配在身份验证成功。<br>凭证匹配通过 AuthenticatingRealm 和子类 CredentialsMatcher 来实现凭据的比较</p><p>Shiro 提供了 CredentialsMatcher 的实现。例如 SimpleCredentialsMatcher 和 HashedCredentialsMatcher 的实现类。也可以自己自定义证书匹配的规则。</p><h4 id="1-SimpleCredentialsMatcher"><a href="#1-SimpleCredentialsMatcher" class="headerlink" title="1. SimpleCredentialsMatcher"></a>1. SimpleCredentialsMatcher</h4><p>Shiro 中所有的 Realm 默认使用的都是 SimpleCredentialsMatcher。SimpleCredentialsMatcher 对存储的凭据和 AuthenticationToken 中进行直接相等性检查。</p><h4 id="2-HashedCredentialsMatcher"><a href="#2-HashedCredentialsMatcher" class="headerlink" title="2. HashedCredentialsMatcher"></a>2. HashedCredentialsMatcher</h4><p>当用户需要存储一些比较密码等一些重要的凭证时，不是直接存入数据库中而是先 hash 一次然后再存入数据库中。<br>这样用户存储的凭证更加安全也没有人知道原始值。</p><h2 id="2-领域授权"><a href="#2-领域授权" class="headerlink" title="2. 领域授权"></a>2. 领域授权</h2><p>SeurityManager 将权限和角色的检查任务交给授权器。默认的授权器为 ModularRealmAuthorizer。</p><h3 id="1-基于角色的授权流程"><a href="#1-基于角色的授权流程" class="headerlink" title="1. 基于角色的授权流程"></a>1. 基于角色的授权流程</h3><ol><li>Subject 委托 SecurityManager 以确定是否分配给定的角色</li><li>SecurityManager 委托授权器</li><li>授权器逐个使用所有领域，直到找到 Subject 指定角色。如果都没有则返回 false</li><li>如果在领域中成功找到则掉哦那个 AuthenticationInfo.getRoles 返回给定角色。并授予访问权限。</li></ol><h4 id="2-基于权限的授权流程"><a href="#2-基于权限的授权流程" class="headerlink" title="2. 基于权限的授权流程"></a>2. 基于权限的授权流程</h4><ol><li>Subject 委托 SecurityManager 授予或拒绝授予权限</li><li>SecurityManager 委托给授权器</li><li>授权器查找所有领域，如果查找到对应全新啊，则授予权限。反之则拒绝授予权限</li></ol><h1 id="5-会话管理"><a href="#5-会话管理" class="headerlink" title="5. 会话管理"></a>5. 会话管理</h1><p><strong>特性：</strong></p><ol><li>轻松自定义会话存储</li><li>支持 web</li><li>可用于 sso</li></ol><h2 id="1-使用-Session"><a href="#1-使用-Session" class="headerlink" title="1. 使用 Session"></a>1. 使用 Session</h2><p>Session 的获取</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject(); Session session =</span><br><span class="line">currentUser.getSession(); session.setAttribute( &quot;someKey&quot;, someValue);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/10fc819bbfd3c78fdeb94ea7f5007ba9.png"></p><h2 id="2-会话管理器"><a href="#2-会话管理器" class="headerlink" title="2. 会话管理器"></a>2. 会话管理器</h2><p>Shiro 中会话管理器可以对应用中的 Session 进行创建、删除、验证等操作。<br>Shiro 中提供了默认的会话管理器 DefaultSessionManager。提供了 Session 的验证和清楚等</p><h2 id="3-会话存储"><a href="#3-会话存储" class="headerlink" title="3. 会话存储"></a>3. 会话存储</h2><p>当每次创建、更新或删除长时间未使用的 Session 时，未来避免 Session 存储空间耗尽。SessionManager 将 Session 的创建、读取、更新、删除操作委派给<br>组件 SesssionDao。<br>SessionDao 的特点将所有你只需要实现这个接口姐可以实现任何数据的储存在任何地方。这意味着你可以将 Session 数据存储在内存中、关系数据库、NoSql 数据库中。</p><p>Shiro 中默认的 Session 存储在内存中。可以通过配置 EHCacheSessionDao 或者是实现自定以的 SessionDao。</p><h3 id="1-EHCache-SessionDao"><a href="#1-EHCache-SessionDao" class="headerlink" title="1. EHCache SessionDao"></a>1. EHCache SessionDao</h3><p>默认情况下未开启。如需开启需要在会话管理器中开启 EHCache 支持。EHCache SessionDao 会将 Sesssion 存储在会话中。如果内存不够了，则会其他的 Session 存储在磁盘中。<br>除了存储 Session 外，还以缓存身份验证和授权数据</p><h3 id="2-EHCacheSessionDao-配置"><a href="#2-EHCacheSessionDao-配置" class="headerlink" title="2.EHCacheSessionDao 配置"></a>2.EHCacheSessionDao 配置</h3><p>默认情况下 Shiro 中的 EhCacheManager 使用的 Shiro 自带的 ehcache.xml 来设置缓存配置。</p><h1 id="6-JSP-标签库"><a href="#6-JSP-标签库" class="headerlink" title="6. JSP 标签库"></a>6. JSP 标签库</h1><h2 id="1-标签库配置"><a href="#1-标签库配置" class="headerlink" title="1. 标签库配置"></a>1. 标签库配置</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</span><br></pre></td></tr></table></figure><h2 id="2-访客标签"><a href="#2-访客标签" class="headerlink" title="2. 访客标签"></a>2. 访客标签</h2><p>不需要认证就可以生效的标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:guest</span>&gt;</span></span><br><span class="line">  Hi there! Please <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;login.jsp&quot;</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">a</span>&gt;</span> or</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;signup.jsp&quot;</span>&gt;</span>Signup<span class="tag">&lt;/<span class="name">a</span>&gt;</span> today!</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:guest</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-用户标签"><a href="#3-用户标签" class="headerlink" title="3. 用户标签"></a>3. 用户标签</h2><p>当用户被认证过或者说是被记住了的话才生效的标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:user</span>&gt;</span></span><br><span class="line">    Welcome back John!  Not John? Click <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;login.jsp&quot;</span>&gt;</span>here<span class="tag">&lt;<span class="name">a</span>&gt;</span> to login.</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:user</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-认证标签"><a href="#3-认证标签" class="headerlink" title="3. 认证标签"></a>3. 认证标签</h2><p>用户只有被认证过才生效的标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:authenticated</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;updateAccount.jsp&quot;</span>&gt;</span>Update your contact information<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:authenticated</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-认证失败标签"><a href="#4-认证失败标签" class="headerlink" title="4. 认证失败标签"></a>4. 认证失败标签</h2><p>用户认证失败的生效标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:notAuthenticated</span>&gt;</span></span><br><span class="line">  Please <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;login.jsp&quot;</span>&gt;</span>login<span class="tag">&lt;/<span class="name">a</span>&gt;</span> in order to update your credit card</span><br><span class="line">  information.</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:notAuthenticated</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-principal-标签"><a href="#5-principal-标签" class="headerlink" title="5.principal 标签"></a>5.principal 标签</h2><p>获取用户的 priincipal 属性<br>shiro:principa 标签可以简化为 principal</p><p>principal 等价于 subject.getPrincipal()方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hello, <span class="tag">&lt;<span class="name">shiro:principal</span> /&gt;</span>, how are you today? //等价于 Hello, &lt;%=</span><br><span class="line">SecurityUtils.getSubject().getPrincipal().toString() %&gt;, how are you today? User</span><br><span class="line">ID: <span class="tag">&lt;<span class="name">principal</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Integer&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">User ID: &lt;%=</span><br><span class="line">SecurityUtils.getSubject().getPrincipals().oneByType(Integer.class).toString()</span><br><span class="line">%&gt; Hello, <span class="tag">&lt;<span class="name">shiro:principal</span> <span class="attr">property</span>=<span class="string">&quot;firstName&quot;</span> /&gt;</span>, how are you today? Hello,</span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:principal</span> <span class="attr">type</span>=<span class="string">&quot;com.foo.User&quot;</span> <span class="attr">property</span>=<span class="string">&quot;firstName&quot;</span> /&gt;</span>, how are you today?</span><br><span class="line">Hello, &lt;%= SecurityUtils.getSubject().getPrincipal().getFirstName().toString()</span><br><span class="line">%&gt;, how are you today?</span><br></pre></td></tr></table></figure><h2 id="6-hasRole-标签"><a href="#6-hasRole-标签" class="headerlink" title="6. hasRole 标签"></a>6. hasRole 标签</h2><p>当用户拥有某个权限才会生效的标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">&quot;administrator&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;admin.jsp&quot;</span>&gt;</span>Administer the system<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-misssingRole-标签"><a href="#7-misssingRole-标签" class="headerlink" title="7.misssingRole 标签"></a>7.misssingRole 标签</h2><p>与 hasRole 标签作用相反</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:lacksRole</span> <span class="attr">name</span>=<span class="string">&quot;administrator&quot;</span>&gt;</span></span><br><span class="line">  Sorry, you are not allowed to administer the system.</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:lacksRole</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="8-hasAnyRole-标签"><a href="#8-hasAnyRole-标签" class="headerlink" title="8.hasAnyRole 标签"></a>8.hasAnyRole 标签</h2><p>用户只要含有任意一个角色就生效的标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasAnyRoles</span> <span class="attr">name</span>=<span class="string">&quot;developer, project manager, administrator&quot;</span>&gt;</span></span><br><span class="line">  You are either a developer, project manager, or administrator.</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasAnyRoles</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9-hasPermission-标签"><a href="#9-hasPermission-标签" class="headerlink" title="9.hasPermission 标签"></a>9.hasPermission 标签</h2><p>用户拥有某项权限才生效的标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">&quot;user:create&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;createUser.jsp&quot;</span>&gt;</span>Create a new User<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="10-missingsPermisssion-标签"><a href="#10-missingsPermisssion-标签" class="headerlink" title="10. missingsPermisssion 标签"></a>10. missingsPermisssion 标签</h2><p>与 hasPermission 作用相反</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:lacksPermission</span> <span class="attr">name</span>=<span class="string">&quot;user:delete&quot;</span>&gt;</span></span><br><span class="line">  Sorry, you are not allowed to delete user accounts.</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:lacksPermission</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-核心架构&quot;&gt;&lt;a href=&quot;#1-核心架构&quot; class=&quot;headerlink&quot; title=&quot;1. 核心架构&quot;&gt;&lt;/a&gt;1. 核心架构&lt;/h1&gt;&lt;h2 id=&quot;1-核心流程&quot;&gt;&lt;a href=&quot;#1-核心流程&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Java" scheme="https://xinc-it.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://xinc-it.github.io/tags/Java/"/>
    
    <category term="Shiro" scheme="https://xinc-it.github.io/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Mysql逻辑架构</title>
    <link href="https://xinc-it.github.io/2023/01/11/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
    <id>https://xinc-it.github.io/2023/01/11/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</id>
    <published>2023-01-11T20:48:28.000Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="架构剖析"><a href="#架构剖析" class="headerlink" title="架构剖析"></a>架构剖析</h1><h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673793013564-ddef72da-8e2f-46e8-976c-3b78d324bad9.png"></p><h2 id="Mysql-架构"><a href="#Mysql-架构" class="headerlink" title="Mysql 架构"></a>Mysql 架构</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1674177610690-d827ed10-467b-4b9e-a73d-67db0a9ab071.png"></p><h3 id="1-连接层"><a href="#1-连接层" class="headerlink" title="1. 连接层"></a>1. 连接层</h3><h4 id="1-Connection-pool"><a href="#1-Connection-pool" class="headerlink" title="1. Connection pool"></a>1. Connection pool</h4><p>作用：</p><ol><li>客户端与服务器建立 TCP 连接</li><li>查询用户对应权限，判定用户能够进行哪些操作</li><li>控制连接个数和连接的复用</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1674178023914-f758ce45-8f06-4434-862b-4348ec02da7f.png"></p><h3 id="2-服务层"><a href="#2-服务层" class="headerlink" title="2. 服务层"></a>2. 服务层</h3><h4 id="1-Sql-接口"><a href="#1-Sql-接口" class="headerlink" title="1. Sql 接口"></a>1. Sql 接口</h4><ol><li>接收 SQL 命令</li><li>返回查询结果</li></ol><h4 id="2-解析器"><a href="#2-解析器" class="headerlink" title="2. 解析器"></a>2. 解析器</h4><ol><li>解析 SQL 语句</li><li>生成解析树</li><li>验证用户权限</li></ol><h4 id="3-优化器"><a href="#3-优化器" class="headerlink" title="3. 优化器"></a>3. 优化器</h4><ol><li>生成执行计划</li><li>明确索引使用</li><li>采用选取-投影-连接进行查询</li></ol><h4 id="4-查询缓存"><a href="#4-查询缓存" class="headerlink" title="4. 查询缓存"></a>4. 查询缓存</h4><ol><li>记录查询结果</li><li>key-value 形式存储</li></ol><h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><ol><li>数据存储提取</li><li>维护底层数据执行</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;架构剖析&quot;&gt;&lt;a href=&quot;#架构剖析&quot; class=&quot;headerlink&quot; title=&quot;架构剖析&quot;&gt;&lt;/a&gt;架构剖析&lt;/h1&gt;&lt;h2 id=&quot;请求流程&quot;&gt;&lt;a href=&quot;#请求流程&quot; class=&quot;headerlink&quot; title=&quot;请求流程&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Mysql" scheme="https://xinc-it.github.io/categories/Mysql/"/>
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://xinc-it.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="https://xinc-it.github.io/2022/12/22/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://xinc-it.github.io/2022/12/22/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-12-22T20:48:28.000Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>本质:<strong>作为函数式接口的实例</strong></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>-&gt;:lambda 操作符()</p><p>-&gt;右边:lambda 形参列表(抽象方法的形参列表)</p><p>-&gt;左边:lambda 体(抽象方法的方法体)</p><h2 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h2><p>lambda 表达式六种使用情况：</p><ol><li>形参类型可以省略，如果参数只有一个，可省小括号</li><li>方法体只有一条语句，可省略大括号（语句为 return 语句时，可省略 return 和大括号关键字）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式一：无参、无返回值</span></span><br><span class="line">Runnable runnable = () -&gt; System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="comment">//语法格式二：有一个参数，无返回值</span></span><br><span class="line">Consumer&lt;String&gt; s1 = (String s) -&gt; &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line">s1.accept(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法格式三：数据类型可以省略，编译器可以推断得出（类型推断）</span></span><br><span class="line"></span><br><span class="line">Consumer&lt;String&gt; s2 = (s) -&gt; &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line">s2.accept(<span class="string">&quot;23&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//语法格式四：只需要一个参数，小括号可以省略</span></span><br><span class="line">Consumer&lt;String&gt; s3 = s -&gt; &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line">s3.accept(<span class="string">&quot;34&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//语法格式五：多个参数，多个执行语句有返回值</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator = (o1, o2) -&gt; &#123;</span><br><span class="line">System.out.println(o1);</span><br><span class="line">System.out.println(o2);</span><br><span class="line"><span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;;</span><br><span class="line">comparator.compare(<span class="number">12</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//语法格式六：只有一条语句，有return时可省略return和大括号</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator2 = (o1, o2) -&gt;</span><br><span class="line">o1.compareTo(o2);</span><br><span class="line">comparator2.compare(<span class="number">12</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>常见函数式接口</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673745172306-3b63b6bc-50cb-4737-8d11-1b0da86c581b.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673746698011-93399e69-4051-4e9e-980d-242231d6293a.png"></p><h1 id="方法引用和构造器引用"><a href="#方法引用和构造器引用" class="headerlink" title="方法引用和构造器引用"></a>方法引用和构造器引用</h1><p>方法引用的三种情况</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673752145970-95aa0b7b-73d4-4671-bba9-f7025a871460.png"></p><p>引用要求：<br>抽象方法和方法体内部的调用方法</p><ol><li>返回值相同</li><li>形参列表相同</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673753293813-92c153ff-48d8-4749-8a96-ef934d2fe7d3.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673753305266-4eb3eae6-95f5-48bf-9d81-08589c0af10e.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673753324728-02575316-cbd9-4423-b3f3-1a0a95110d6a.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673753338098-2e6ffcc1-5afa-4a7a-b78d-0e3b07005804.png"></p><h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><p>用于操作数据源（集合、数组）</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>不存储元素</li><li>不该元数据</li><li>操作延迟执行</li></ol><h2 id="Stream-操作三步"><a href="#Stream-操作三步" class="headerlink" title="Stream 操作三步"></a>Stream 操作三步</h2><ol><li>创建 Stream</li><li>中间操作</li><li>终止操作</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673753653838-0fa643de-e8ee-4ac3-acdf-c2392b26d708.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lambda-表达式&quot;&gt;&lt;a href=&quot;#Lambda-表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda 表达式&quot;&gt;&lt;/a&gt;Lambda 表达式&lt;/h1&gt;&lt;p&gt;本质:&lt;strong&gt;作为函数式接口的实例&lt;/strong&gt;&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="Java" scheme="https://xinc-it.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://xinc-it.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-行锁</title>
    <link href="https://xinc-it.github.io/2022/09/11/6!%E8%A1%8C%E9%94%81/"/>
    <id>https://xinc-it.github.io/2022/09/11/6!%E8%A1%8C%E9%94%81/</id>
    <published>2022-09-11T21:17:06.000Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-两阶段锁"><a href="#1-两阶段锁" class="headerlink" title="1. 两阶段锁"></a>1. 两阶段锁</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634436939942-730ba0be-6f13-45fd-9e43-01d1e21cdcae.png"></p><p><strong><font style="color:rgb(53, 53, 53);">下面的操作序列中，如果为两行数据加了行锁事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。</font>**</strong><br>**</p><hr><p>在 InnoDB 中，行锁是在需要的时候加上，在**<font style="color:#F5222D;">事务结束时释放。（</font><strong>最有可能造成锁冲突的行的读锁尽量往后放</strong><font style="color:#F5222D;">）</font>**</p><p><strong><font style="color:#F5222D;"></font></strong></p><p>示例：</p><p>顾客 A 在影院 B 买电影票</p><p>操作如下</p><ol><li><font style="color:rgb(53, 53, 53);">从顾客 A 账户余额中扣除电影票价；</font></li><li><font style="color:rgb(53, 53, 53);">给影院 B 的账户余额增加这张电影票价；</font></li><li><font style="color:rgb(53, 53, 53);">记录一条交易日志。</font></li></ol><p><font style="color:rgb(53, 53, 53);"></font></p><p>其中多个顾客买票可能造成 B 的账户行数据冲突。因此将 B 的操作放在最后。最大程度减少了事务之间的锁等待。</p><h2 id="2-死锁和死锁检测"><a href="#2-死锁和死锁检测" class="headerlink" title="2. 死锁和死锁检测"></a>2. 死锁和死锁检测</h2><p>示例：当行锁同时锁住 id=1 和 2 的两行数据</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634437587628-d3672f2b-b62b-4ced-ac7b-dcc6de65eb02.png"></p><p>在这种情况下事务 A 等待 id=2 的行锁，事务 B 等待 id=1 的行锁。事务 A 和事务 B 互相都在等待对方无法释放的资源，从而进入了死锁。</p><p>解决方法</p><ul><li>设置获取锁等待时间：设置获取锁超时时间，如果超时则锁住的线程自动退出。通过 innodb_lock_wait_timeout 来设置等待时间默认为 50s</li><li>发起死锁检测：发现死锁后主动回滚争抢锁的某一个事务。让其他事务继续执行。通过 innodb_deadlock_detect 设置为 on 表示开启逻辑。</li></ul><p>死锁检测的缺点：</p><ol><li>确保业务不会出现死锁，关闭死锁检测</li><li>控制并发度</li></ol><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><ol><li>读锁的两阶段协议：需要的时候加上、事务结束的时候释放。尽可能将影响并发度最大的锁往后放。减少其他锁的等待时间</li><li>死锁的形成，事务之间争抢不释放的锁资源。导致一直处于等待状态</li><li>死锁的解决方法：1. 设置锁等待时间 2. 开启死锁检测</li></ol><p><strong><font style="color:#F5222D;"></font></strong></p><p><strong><font style="color:#F5222D;"></font></strong></p><ul><li><font style="color:rgb(53, 53, 53);">第一种，直接执行 delete from T limit 10000;</font></li><li><font style="color:rgb(53, 53, 53);">第二种，在一个连接中循环执行 20 次 delete from T limit 500;</font></li><li><font style="color:rgb(53, 53, 53);">第三种，在 20 个连接中同时执行 delete from T limit 500。</font></li></ul><p><font style="color:rgb(53, 53, 53);">你会选择哪一种方法呢？为什么呢？</font></p><p><font style="color:rgb(53, 53, 53);">第二种，第三种容易造成死锁。第一种锁的范围太大导致获取锁的时间长。</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-两阶段锁&quot;&gt;&lt;a href=&quot;#1-两阶段锁&quot; class=&quot;headerlink&quot; title=&quot;1. 两阶段锁&quot;&gt;&lt;/a&gt;1. 两阶段锁&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/123</summary>
      
    
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="https://xinc-it.github.io/tags/Mysql/"/>
    
    <category term="InnoDB" scheme="https://xinc-it.github.io/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-索引</title>
    <link href="https://xinc-it.github.io/2022/09/09/4!%E7%B4%A2%E5%BC%95/"/>
    <id>https://xinc-it.github.io/2022/09/09/4!%E7%B4%A2%E5%BC%95/</id>
    <published>2022-09-09T15:17:06.000Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-索引常见模型"><a href="#1-索引常见模型" class="headerlink" title="1.索引常见模型"></a>1.索引常见模型</h2><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631014492663-2fed2cf8-9707-4346-bf90-06ff2a5b0d4e.png"></p><p>通过 hash 算法将 key 换算成确定的位置，然后把 value 放入到这个数组的位置。如果数组已经存在值，</p><p>则通过拉链法，拉出一条链表。</p><p>优点：等值查询的情况下查询效率高</p><p>缺点：范围查询效率低下</p><h3 id="2-有序数组"><a href="#2-有序数组" class="headerlink" title="2. 有序数组"></a>2. 有序数组</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631014718687-07087e14-d4f9-4401-9bbd-bb4dd3a0bce5.png"></p><p>优点：等值和范围查询效率高</p><p>缺点：插入、删除数据效率低下</p><p>场景：只适用于静态存储引擎</p><h3 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3. 二叉搜索树"></a>3. 二叉搜索树</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631014893629-805c3a90-3ccf-4fff-98f4-51ec1671c6df.png"></p><p>缺点：数据量大的情况下，导致树很高，需要进行多次磁盘读取数据，比较浪费时间。</p><h2 id="2-InnoDB-索引模型"><a href="#2-InnoDB-索引模型" class="headerlink" title="2. InnoDB 索引模型"></a>2. InnoDB 索引模型</h2><p>B+树</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631015176574-c34b7b27-c5cc-4295-8de1-bdb466fe3700.png"></p><h2 id="3-主键索引和非主键索引"><a href="#3-主键索引和非主键索引" class="headerlink" title="3. 主键索引和非主键索引"></a>3. 主键索引和非主键索引</h2><p><strong>InnoDB 里面主键索引也被称为聚簇索引</strong></p><p><font style="background-color:#FADB14;">非主键索引的叶子节点存储的是主键的值</font></p><p><font style="background-color:#F5222D;">主键索引和非主键索引的区别</font></p><ol><li>主键查询： 只需要查询主键索引的 B+树,查询出对应的数据</li><li>非主键索引：查询非主键索引的树，获得对应的主键值，然后通过主键值查询主键索引的 B+树</li></ol><h2 id="4-索引维护"><a href="#4-索引维护" class="headerlink" title="4. 索引维护"></a>4. 索引维护</h2><p>概念： 当数据页中数据存储满了，会生成一个新的数据页，然后原有数据也中的部分数据会移到新的数据也中。这种过程叫做页分裂。</p><p>同理页合并是两个数据页中的数据太少了，合并到一个数据页中。</p><h2 id="5-索引覆盖"><a href="#5-索引覆盖" class="headerlink" title="5. 索引覆盖"></a>5. 索引覆盖</h2><h3 id="1-回表"><a href="#1-回表" class="headerlink" title="1. 回表"></a>1. 回表</h3><p><font style="color:rgb(53, 53, 53);"> select * from T where k between 3 and 5</font></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631016152383-0a030960-b98c-4af0-8eb5-c3e571988bc0.png"></p><p>执行流程</p><ol><li><font style="color:rgb(53, 53, 53);">在 k 索引树上找到 k=3 的记录，取得 ID = 300；</font></li><li><font style="color:rgb(53, 53, 53);">再到 ID 索引树查到 ID=300 对应的 R3；</font></li><li><font style="color:rgb(53, 53, 53);">在 k 索引树取下一个值 k=5，取得 ID=500；</font></li><li><font style="color:rgb(53, 53, 53);">再回到 ID 索引树查到 ID=500 对应的 R4；</font></li><li><font style="color:rgb(53, 53, 53);">在 k 索引树取下一个值 k=6，不满足条件，循环结束</font></li></ol><p><strong>回表：非主键搜索完后，回到主键索引树进行搜索的过程</strong>。（步骤 2、4）</p><h3 id="2-索引覆盖"><a href="#2-索引覆盖" class="headerlink" title="2. 索引覆盖"></a>2. 索引覆盖</h3><p><font style="color:rgb(53, 53, 53);">select ID from T where k between 3 and 5</font></p><p><font style="color:rgb(53, 53, 53);"></font></p><p><font style="color:rgb(53, 53, 53);"></font></p><p><font style="color:rgb(53, 53, 53);">对于上述通过非主键索引查询主键索引信息，由于非主键索引存放了主键的信息。</font></p><p><font style="color:rgb(53, 53, 53);">导致我们不需要进行回表。</font><strong><font style="color:rgb(53, 53, 53);">由于索引 k 的值覆盖了查询的字段，我们称之为覆盖索引</font></strong></p><p><strong><font style="color:rgb(53, 53, 53);"></font></strong></p><p><strong><font style="color:rgb(53, 53, 53);"></font></strong></p><p><strong><font style="color:rgb(53, 53, 53);">优点：减少树的搜索次数，提升查询效率</font></strong></p><p><font style="color:rgb(53, 53, 53);"></font></p><p><font style="color:rgb(53, 53, 53);"></font></p><h2 id="6-最左前缀原则"><a href="#6-最左前缀原则" class="headerlink" title="6. 最左前缀原则"></a>6. 最左前缀原则</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tuser` (</span><br><span class="line">  `id` int(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `id_card` varchar(<span class="number">32</span>) DEFAULT NULL,</span><br><span class="line">  `name` varchar(<span class="number">32</span>) DEFAULT NULL,</span><br><span class="line">  `age` int(<span class="number">11</span>) DEFAULT NULL,</span><br><span class="line">  `ismale` tinyint(<span class="number">1</span>) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `id_card` (`id_card`),</span><br><span class="line">  KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631016490840-0e048d5d-77e7-4191-83e7-026d3c1e3e6e.png"></p><p><font style="color:rgb(53, 53, 53);">如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</font></p><p><strong><font style="color:rgb(53, 53, 53);"></font></strong></p><p><strong><font style="color:rgb(53, 53, 53);">联合索引以第一个索引为基准进行排序，然后通过第一个索引的值来进行查询</font></strong></p><p><a href="https://www.cnblogs.com/ljl150/p/12934071.html">最左前缀原则</a></p><p><strong><font style="color:rgb(53, 53, 53);"></font></strong></p><p><strong><font style="color:rgb(53, 53, 53);"></font></strong></p><p><strong><font style="color:rgb(53, 53, 53);"></font></strong></p><h2 id="7-索引下推"><a href="#7-索引下推" class="headerlink" title="7. 索引下推"></a>7. 索引下推</h2><p>Mysql5.6 引入索引下推，是在最左前缀的条件小，过滤调不不符合条件的记录减少回表的次数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select * from tuser where name like &#x27;张 %&#x27; and age=<span class="number">10</span> and ismale=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631018210889-220345e3-dae5-4eb8-9170-5537631d52ef.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631018215910-da87dcc1-a41f-46ae-b73b-cecf9db4cf0f.png"></p><h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h2><ol><li>索引的常见模型<ol><li>哈希表 （不支持范围查询）</li><li>有序数组（插入删除效率低）</li><li>二叉搜索树（数据量大，导致树的高度很高，需要进行多次磁盘读取）</li></ol></li><li>InnoDB 索引模型<ol><li>B+树支持范围查询，树的高度不会太高</li><li>查找数据消耗磁盘读取的时间相同</li></ol></li><li>主键索引和非主键索引<ol><li>在 InnoDB 主键索引存储索引行对应的数据</li><li>非主键索引存储的是主键索引的值，需要通过回表的方式，去查询一遍主键索引</li></ol></li><li>索引覆盖：通过非主键索引查询主键索引的值，导致不需要回到主键索引树再次进行查询的过程。</li><li>最左前缀原则</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-索引常见模型&quot;&gt;&lt;a href=&quot;#1-索引常见模型&quot; class=&quot;headerlink&quot; title=&quot;1.索引常见模型&quot;&gt;&lt;/a&gt;1.索引常见模型&lt;/h2&gt;&lt;h3 id=&quot;1-哈希表&quot;&gt;&lt;a href=&quot;#1-哈希表&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="https://xinc-it.github.io/tags/Mysql/"/>
    
    <category term="InnoDB" scheme="https://xinc-it.github.io/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-事务隔离</title>
    <link href="https://xinc-it.github.io/2022/09/07/3!%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <id>https://xinc-it.github.io/2022/09/07/3!%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</id>
    <published>2022-09-07T19:17:06.000Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-隔离性和隔离级别"><a href="#1-隔离性和隔离级别" class="headerlink" title="1. 隔离性和隔离级别"></a>1. 隔离性和隔离级别</h2><h3 id="1-事务特性"><a href="#1-事务特性" class="headerlink" title="1. 事务特性"></a>1. 事务特性</h3><ol><li><strong><font style="color:#F5222D;">原子性</font></strong></li><li><strong><font style="color:#F5222D;">持久性</font></strong></li><li><strong><font style="color:#F5222D;">隔离性</font></strong></li><li><strong><font style="color:#F5222D;">一致性</font></strong></li></ol><h3 id="2-事务隔离级别"><a href="#2-事务隔离级别" class="headerlink" title="2. 事务隔离级别"></a>2. 事务隔离级别</h3><ol><li><strong><font style="color:#F5222D;">读已提交（事务未提交时，变更能被其它事务看到）</font></strong></li><li><strong><font style="color:#F5222D;">读未提交（事务提交后，其它事务才能看到变更）</font></strong></li><li><strong><font style="color:#F5222D;">可重复读（一个事务执行过程中，总是跟启动时看到的数据是一致的。未提交的变更对其它事务不可见）</font></strong></li><li><strong><font style="color:#F5222D;">串行化（同一行记录写会加写锁，读会读锁。当出现读写锁冲突时，后访问的事务，必须等前一个事务完成，才能执行）</font></strong></li></ol><p><strong><font style="color:#F5222D;"></font></strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630988923063-4d56a761-7637-488b-951d-c443de806cb1.png"></p><p>v1=v2=1,v3=2</p><p>四种事务得到的结果</p><ol><li>读未提交： v1、v2、v3=2</li><li>读已提交: v1=1 ，v2、v3=2</li><li>可重复读：v1=v2=1，v3=2</li><li>可串行化 ： v1=v2=1,v3=2</li></ol><p><strong><font style="color:#F5222D;"></font></strong></p><h2 id="2-事务隔离的实现"><a href="#2-事务隔离的实现" class="headerlink" title="2. 事务隔离的实现"></a>2. 事务隔离的实现</h2><p>当一个值从 1 按顺序变成 2，3，3 那么他的日志里面就会有类似的回滚段记录</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631013980123-b4f659d1-a49a-4d6f-bffa-5c049fb7a4b5.png"></p><p>如图事务 A、B、C 修改记录导致一个字段对应多个值。</p><p>通过 MVCC 来实现一个数据的多个版本，通过 undo log 实现数据版本的回滚</p><p>通过 MVCC 和 undo log 来实现事务的隔离</p><p>具体可以参考</p><p><a href="https://www.yuque.com/sanxingalaxys9/gwxct1/lq01qk">Mysql 实战 45 讲</a></p><p>当回滚段日志过长时，系统会自动清除。</p><h2 id="3-事务的启动方式"><a href="#3-事务的启动方式" class="headerlink" title="3. 事务的启动方式"></a>3. 事务的启动方式</h2><ol><li>set autocommit=0 关闭自动提交，只要执行 select 语句自动开启事务</li><li>begin 或是 start transaction</li></ol><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><ol><li>四大特性和隔离级别</li><li>事务隔离的实现（通过 MVCC 和 undo log)</li><li>事务的启动方式<ol><li>自动启动 select 语句执行时自动启动</li><li>手动启动 begin、 start transaction</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-隔离性和隔离级别&quot;&gt;&lt;a href=&quot;#1-隔离性和隔离级别&quot; class=&quot;headerlink&quot; title=&quot;1. 隔离性和隔离级别&quot;&gt;&lt;/a&gt;1. 隔离性和隔离级别&lt;/h2&gt;&lt;h3 id=&quot;1-事务特性&quot;&gt;&lt;a href=&quot;#1-事务特性&quot; class</summary>
      
    
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="https://xinc-it.github.io/tags/Mysql/"/>
    
    <category term="InnoDB" scheme="https://xinc-it.github.io/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-更新语句的执行</title>
    <link href="https://xinc-it.github.io/2022/09/06/2!%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
    <id>https://xinc-it.github.io/2022/09/06/2!%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C/</id>
    <published>2022-09-06T12:17:06.000Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-更新语句执行流程"><a href="#1-更新语句执行流程" class="headerlink" title="1. 更新语句执行流程"></a>1. 更新语句执行流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630974533552-29681b12-3ee4-4012-ae23-882ab740984d.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T <span class="built_in">set</span> c=c+1 <span class="built_in">where</span> ID=2;</span><br></pre></td></tr></table></figure><ol><li>客户端通过连接器连接 MySQL 服务器</li><li>将缓存中相关表的结果清空</li><li>分析器通过词法和语法分析判断是更新语句</li><li>优化器通过索引，决定使用 ID 的索引</li><li>执行器执行更新语句</li><li>进行 redo log 和 bin log 的修改</li></ol><h2 id="2-Redo-log-引擎日志"><a href="#2-Redo-log-引擎日志" class="headerlink" title="2.Redo log(引擎日志)"></a>2.Redo log(引擎日志)</h2><p>情景老板记账：先把借帐和还账记录写在黑板上，空闲时，再把黑板上账的写入到账本中。</p><p>作用： 用作数据库写入将数据磁盘的缓存，防止每次更新都要将数据写进磁盘，提高了更新效率。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630975170760-0904cfb2-ee0b-4650-a584-bb831be94070.png"></p><h3 id="1-WAL-Write-Ahead-Logging"><a href="#1-WAL-Write-Ahead-Logging" class="headerlink" title="1. WAL (Write-Ahead Logging)"></a>1. WAL (Write-Ahead Logging)</h3><p>**<font style="color:#F5222D;background-color:#FADB14;">先写日志，再写磁盘</font>**。</p><p>InnoDB 引擎会把记录写道 redo log 中，并更新内存。然后更新就算完成。引擎会在空闲时间操作记录</p><p>写入磁盘。</p><p>如果 redo log 写满了，会把一部分记录更新到磁盘中。</p><p>通过 write pos 和 check point 两个指针来判断日志是否写满</p><h3 id="2-crash-safe"><a href="#2-crash-safe" class="headerlink" title="2. crash-safe"></a>2. crash-safe</h3><p>当数据库发生异常时，可以通过 redo log 可以获取到之前的提交记录。</p><p>通过提交记录可以将未同步到数据库中数据同步到数据库中。</p><p><strong><font style="color:#F5222D;">redo log 存储的是物理变更日志，用于记录磁盘中指定地方的数值修改记录。</font></strong></p><h3 id="3-特点"><a href="#3-特点" class="headerlink" title="3. 特点"></a>3. 特点</h3><ol><li> 存储的物理日志（记录的是数据页上数据的更改）</li><li> 先写日志，后写磁盘</li><li> 可以 crash safe 进行数据的修复</li><li> InnoDB 引擎层日志</li><li> 空间有限会用完，通过队列的实现循环写</li></ol><h2 id="3-binlog（Server-层日志）"><a href="#3-binlog（Server-层日志）" class="headerlink" title="3. binlog（Server 层日志）"></a>3. binlog（Server 层日志）</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><ol><li>服务层日志</li><li>存储的内容是逻辑日志（记录的是语句的原始逻辑）</li><li>空间无限，通过新增文件实现追加写</li></ol><h2 id="4-执行流程"><a href="#4-执行流程" class="headerlink" title="4. 执行流程"></a>4. 执行流程</h2><ol><li>执行引擎先找到 ID=2 的这一行数据，如果内存中存在直接返回给执行器，否则从磁盘读入内存然后返回给执行器</li><li>把值加上 1，然后调用引擎接口写入数据</li><li>引擎会将新数据更新到内存中，同时更新到 redo log 中。redo log 处于 prepare 状态，告诉执行器完成了，可以提交事务了。</li><li>执行器生成更新操作的 bin log,并把 bin log 写入磁盘</li><li>执行器调用引擎的事务接口，将写入的 redo log 改成 commit 状态</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634976756709-8dbcb97a-235f-4b93-a181-f46a29389d94.png"></p><h2 id="5-两阶段提交"><a href="#5-两阶段提交" class="headerlink" title="5. 两阶段提交"></a>5. 两阶段提交</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630988222445-a6208d34-24c4-4e8d-89b2-8952bbb46186.png"></p><hr><p><strong>原因</strong></p><ol><li>如果发生 crash 导致系统崩溃的话，如果顺序不一致，可能导致之后无法通过 binlog 恢复到任一时刻的数据</li><li>可能导致 binlog 和 redo log 的数据不一致导致数据冲突。</li></ol><h2 id="6-两种日志的不同点"><a href="#6-两种日志的不同点" class="headerlink" title="6. 两种日志的不同点"></a>6. 两种日志的不同点</h2><ol><li>redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的</li><li>redo log 是物理日志，记录的是 <strong>在某个数据页上做了修改</strong>，binlog 是逻辑日志记录的是语句逻辑 <strong>给 ID=2 的数据进行加 1</strong></li><li>redo log 是循环写，空间大小固定。bin log 是追加写，当 bin log 文件到达一定大小后会切换到下一个，不会覆盖以前的日志</li></ol><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><ol><li>更新语句的执行流程</li><li>Redo log 的作用是用来存储 MySQL 产生更新语句的物理日志。通过 WAL 技术先将日志写入 队列中然偶后通过指定条件写入磁盘中</li><li>bin log 的作用和特点</li><li>两种日志的不同点</li><li>两阶段提交的作用<ol><li>保证数据库的数据不冲突</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-更新语句执行流程&quot;&gt;&lt;a href=&quot;#1-更新语句执行流程&quot; class=&quot;headerlink&quot; title=&quot;1. 更新语句执行流程&quot;&gt;&lt;/a&gt;1. 更新语句执行流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuqu</summary>
      
    
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="https://xinc-it.github.io/tags/Mysql/"/>
    
    <category term="InnoDB" scheme="https://xinc-it.github.io/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>了解Mysql查询语句执行流程</title>
    <link href="https://xinc-it.github.io/2022/01/11/1!%E4%BA%86%E8%A7%A3Mysql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://xinc-it.github.io/2022/01/11/1!%E4%BA%86%E8%A7%A3Mysql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2022-01-11T20:55:45.000Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<p><strong>MySQL 逻辑架构图</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1629176680362-2a25040b-16f9-402a-895d-3c6fdfd78a1f.png"></p><h2 id="1-Server-层"><a href="#1-Server-层" class="headerlink" title="1. Server 层"></a>1. Server 层</h2><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>Server 层包括连接器、分析器、优化器、执行器、查询缓存。</p><h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h3><p>作用：</p><ol><li><strong><font style="color:#F5222D;">负责跟客户端建立连接</font></strong></li><li><strong><font style="color:#F5222D;">获取权限</font></strong></li><li><strong><font style="color:#F5222D;">维持和管理连接</font></strong></li></ol><p>连接指令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h$ip <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p</span><br></pre></td></tr></table></figure><p>获取权限：通过 TCP 握手后，连接器验证身份，通过输入的用户名和密码。查询 MySQL 数据库中的 user 表。查询对应的用户权限。</p><p><strong>长连接和短链接</strong></p><p>长连接：连接成功后，如果客户端持续有请求，则一直使用该连接</p><p>短连接：每次执行完几次查询就断开连接，下次查询在重新建立连接。</p><p>建议使用长连接，因为建立连接过程比较复杂，尽量减少建立连接的动作。</p><p>但是建立长连接也会导致内存消耗增加。因为 Mysql 在执行时使用的内存是在连接对象里面的。这些资源会在断开时释放。</p><p>如果长连接累计下来，可能导致内存占用太大。</p><p>解决方法</p><ol><li>定期断开长连接</li><li>执行 mysql_reset_connectionc 初始化连接资源。针对 5.7 以后。</li></ol><h3 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2. 查询缓存"></a>2. 查询缓存</h3><p><strong><font style="color:#F5222D;">作用：用于做缓存</font></strong></p><p>Mysql 拿到请求后会先去缓存中，查看是否有对应的查询语句。缓存以 key-value 的形式存储。</p><p>查询语句作为 key ,查询结果作为 value 存入缓存中。</p><p>但是不建议使用查询缓存。因为缓存数据失效的很频繁。</p><p><strong>8.0 之后 MySQL 删掉了查询缓存</strong></p><hr><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>缓存查询</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  SQL_CACHE <span class="operator">*</span>  <span class="keyword">from</span> T ;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 不查询缓存</span><br><span class="line"><span class="keyword">select</span>   DEMAND <span class="operator">*</span>  <span class="keyword">from</span> T ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h3><p>**<font style="color:#F5222D;">作用： 进行 sql 语句的解析</font>**。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li>词法分析</li></ol><p>通过关键字 **select **识别为查询语句。将对应的 T 识别成对应的表名 T，将字符串”ID” 识别成列”ID”.</p><ol start="2"><li>语法分析</li></ol><p>判断 Sql 语句是否满足 Mysql 语法。如果语句不对，则会受到错误提醒。</p><h3 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h3><p><strong><font style="color:#F5222D;">作用：决定执行方案</font></strong></p><ol><li><strong><font style="color:#F5222D;">决定使用哪个索引，多个索引情况下。</font></strong></li><li><strong><font style="color:#F5222D;">决定各表连接顺序，多个表关联的情况下。</font></strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID) <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li><font style="color:rgb(53, 53, 53);">既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</font></li><li><font style="color:rgb(53, 53, 53);">也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</font></li></ul><p><font style="color:rgb(53, 53, 53);"></font></p><p><font style="color:rgb(53, 53, 53);">优化器会决定执行哪种方案。</font></p><p><font style="color:rgb(53, 53, 53);"></font></p><p><font style="color:rgb(53, 53, 53);"></font></p><h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h3><p><strong><font style="color:#F5222D;">作用：执行 sql 语句</font></strong></p><ol><li>判断用户对这个表有无查询权限</li><li>根据表引擎提供的接口执行查询</li></ol><ul><li><font style="color:rgb(53, 53, 53);">调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</font></li><li><font style="color:rgb(53, 53, 53);">调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</font></li><li><font style="color:rgb(53, 53, 53);">执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</font></li></ul><p><font style="color:rgb(53, 53, 53);"></font></p><p><font style="color:rgb(53, 53, 53);"></font></p><p><font style="color:rgb(53, 53, 53);"></font></p><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h3><ol><li>连接器主要作用让客户端和服务端建立连接、获取登录用户权限、维持和管理连接。</li><li>查询缓存用于通过查询的 sql 语句作为 key，判断是否存在对应的 key,如果存在直接返回缓存中存储的查询结果。</li><li>分析器用于**<font style="color:#F5222D;">判断 sql 语句语法是否正确</font>**！将查询的 sql 语句的字段名解析成对应的数据库中对应的字段和表</li><li><font style="color:rgb(53, 53, 53);">分析器作用</font><strong><font style="color:#F5222D;">优化查询条件</font></strong><font style="color:rgb(53, 53, 53);">。查询条件判断使用哪种索引进行查询以及各表的连接顺序</font></li><li><font style="color:rgb(53, 53, 53);">执行器用于</font><strong><font style="color:#F5222D;">执行 sql 语句</font></strong><font style="color:rgb(53, 53, 53);">。</font></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;MySQL 逻辑架构图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/12394516/1629176680362-2a25040b-16f9-402a-895d-3c6fd</summary>
      
    
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="https://xinc-it.github.io/tags/Mysql/"/>
    
    <category term="InnoDB" scheme="https://xinc-it.github.io/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>Mysql技术内幕-第二章</title>
    <link href="https://xinc-it.github.io/2022/01/11/Mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>https://xinc-it.github.io/2022/01/11/Mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</id>
    <published>2022-01-11T20:55:45.000Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12394516/1636370551211-b7e3691e-760d-4777-9125-49a114a0f304.jpeg" alt="画板"></p><h1 id="1-InnoDB-体系架构"><a href="#1-InnoDB-体系架构" class="headerlink" title="1. InnoDB 体系架构"></a>1. InnoDB 体系架构</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635692260786-270228fe-31a7-4258-b9c1-87c52f516e08.png"></p><hr><h3 id="1-InnoDB-存储引擎作用"><a href="#1-InnoDB-存储引擎作用" class="headerlink" title="1. InnoDB 存储引擎作用"></a>1. InnoDB 存储引擎作用</h3><ol><li><strong>缓存磁盘上的数据</strong>，方便快速读取。对<strong>磁盘数据修改之前也做缓存。</strong></li><li><strong>redo log 缓冲</strong></li><li>维护进程、线程需要访问的多个内部数据结构</li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="1-后台线程"><a href="#1-后台线程" class="headerlink" title="1. 后台线程"></a>1. 后台线程</h2><p>InnoDB 存储引擎是多线程模型，负责处理不同的任务</p><h3 id="1-MasterThread"><a href="#1-MasterThread" class="headerlink" title="1. MasterThread"></a>1. MasterThread</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>将数据异步刷新到磁盘。其中包括脏页刷新、合并插入缓冲、UNDO 页回收。</p><h3 id="2-IO-Thread"><a href="#2-IO-Thread" class="headerlink" title="2. IO Thread"></a>2. IO Thread</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>InnoDB 使用了大量的<strong>异步 IO</strong> 来处理 IO 请求。作用是<strong>提高数据库的性能</strong>。</p><p>IO Thread 的作用是负责<strong>IO 请求的回调处理</strong></p><hr><hr><h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h4><p>IOThread 主要分为 4 种</p><ul><li><code>write thread</code>(默认 4 个)</li><li><code>read thread</code>(默认 4 个)</li><li><code>insert buffer thread</code></li><li><code>log io thread </code></li></ul><p>write 和 read Thread 可以通过 <code>innnodb_read_io_threads </code>和<code>innodb_write_io_threads</code>设置线程数</p><hr><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635693324015-367ec145-45e4-4614-87a4-0c8acb2a6e1e.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//可以通过该命令查看innodb 中的io Thread</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash">show engine innodb  status ;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635693491056-13f94aba-301d-4a04-a8fa-9002fa135a97.png"></p><h3 id="3-Purge-Thread"><a href="#3-Purge-Thread" class="headerlink" title="3. Purge Thread"></a>3. Purge Thread</h3><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p><strong>作用：回收事务提交后的使用的 undo 页</strong>。</p><p>分配到独立的线程中进行，减少 Master Thread 工作。同时用户可以也可以通过<code>innnodb_purge_threads</code> 设置线程数，默认为 1.</p><h3 id="4-Page-Cleaner-Thread"><a href="#4-Page-Cleaner-Thread" class="headerlink" title="4. Page Cleaner Thread"></a>4. Page Cleaner Thread</h3><p>作用：脏页刷新操作。</p><p>从而减少了 Master Thread 工作和查询线程线程的阻塞。提高了 InnoDB 性能。</p><h3 id="5-后台线程作用"><a href="#5-后台线程作用" class="headerlink" title="5. 后台线程作用"></a>5. 后台线程作用</h3><ol><li>刷新内存池中的数据，保证缓存的是最新的数据</li><li>将已修改的数据文件刷新到磁盘中</li><li>保证数据库发生异常恢复正常</li></ol><h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h2><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="1-缓冲池"><a href="#1-缓冲池" class="headerlink" title="1. 缓冲池"></a>1. 缓冲池</h3><h4 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>用来<strong>解决 cpu 速度和磁盘速度之间的鸿沟</strong></p><hr><hr><h4 id="2-执行流程"><a href="#2-执行流程" class="headerlink" title="2. 执行流程"></a>2. 执行流程</h4><p>数据库读取页时，将磁盘读取到的页放在缓冲池中。下一次再次读取该数据页时，直接从池中读取。否则从磁盘上读取。</p><p>数据库修改页操作时，首先修改缓冲池的页，然后通过<code>check point </code>机制将数据页刷新到磁盘中。</p><h4 id="3-缓冲池大小配置"><a href="#3-缓冲池大小配置" class="headerlink" title="3. 缓冲池大小配置"></a>3. 缓冲池大小配置</h4><hr><p>通过 innnodb_buffer_pool_size 来设置缓冲池大小。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635694963515-e0b21fec-317a-400c-ac75-263527738b5a.png"></p><h4 id="4-存储对象"><a href="#4-存储对象" class="headerlink" title="4. 存储对象"></a>4. 存储对象</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635695049116-4482036d-9fb4-4114-86c0-d6bc26b0bb12.png"></p><ol><li>索引页</li><li>数据页</li><li>插入缓冲</li><li>undo 页</li><li>自适应哈希索引</li><li>锁信息</li><li>数据字典信息</li></ol><hr><hr><hr><h3 id="2-缓存算法"><a href="#2-缓存算法" class="headerlink" title="2. 缓存算法"></a>2. 缓存算法</h3><h4 id="1-LRU（最近最少使用淘汰）"><a href="#1-LRU（最近最少使用淘汰）" class="headerlink" title="1. LRU（最近最少使用淘汰）"></a>1. LRU（最近最少使用淘汰）</h4><p>将经常使用的页放在 LRU 列表的最前端，最少使用页放在列表尾端。将新读取的页放到 midpoint 位置（距离尾端的 3/8 出）。可以通过<code>innodb_old_blocks_pct</code>控制插入位置。</p><p><code>midpoint</code> 之前的 new 列表，之后的为 old 列表。new 列表中数据为活跃的数据。</p><p>为什么不直接把读取的新页放在列表首部？</p><p>部分 sql 操作（索引、数据扫描操作）导致缓冲池中页被刷出，影响缓冲池效率。需要读入大量的数据页，导致许多活跃数据页从列表中移除。</p><p>innodb 可以通过设置<code>innodb_old_blocks_time</code>来决定新加入的页从 mid 到列表头部需要等待多久。</p><h3 id="3-redo-日志缓冲（-redo-log-buffer）"><a href="#3-redo-日志缓冲（-redo-log-buffer）" class="headerlink" title="3. redo 日志缓冲（ redo log buffer）"></a>3. redo 日志缓冲（ redo log buffer）</h3><p>用于暂时存放 redo log 信息，然后 Innodb 以一定频率刷新到 redo log 文件中。</p><p>可以通过 <code>innnodb_log_buffer_size</code>设置缓冲大小。</p><p><strong>三种日志刷新到 redo log 文件情况</strong></p><ol><li>Master Thread 每秒刷新</li><li>事务提交时刷新</li><li>日志缓冲空间小于一半</li></ol><h1 id="2-Checkpoint-技术"><a href="#2-Checkpoint-技术" class="headerlink" title="2. Checkpoint 技术"></a>2. Checkpoint 技术</h1><p><strong>解决问题</strong></p><ol><li>缩短数据恢复时间</li><li>缓冲池不够时，将脏页刷新到磁盘</li><li>redo log 日志缓冲不够时，刷新脏页</li></ol><h2 id="1-Check-Point-分类："><a href="#1-Check-Point-分类：" class="headerlink" title="1. Check Point 分类："></a>1. Check Point 分类：</h2><ol><li>Sharp Checkpoint</li><li>Fuzzy Checkpoing</li></ol><h2 id="2-Sharp-Checkpoint"><a href="#2-Sharp-Checkpoint" class="headerlink" title="2. Sharp Checkpoint"></a>2. Sharp Checkpoint</h2><p>默认将<strong>数据库关闭时将所有脏页刷新到磁盘中</strong>，</p><p>参数是 innodb_fast_shutdown=1.</p><h2 id="3-Fuzzy-Checkpoint"><a href="#3-Fuzzy-Checkpoint" class="headerlink" title="3. Fuzzy Checkpoint"></a>3. Fuzzy Checkpoint</h2><h3 id="1-Master-Thread-checkpoint"><a href="#1-Master-Thread-checkpoint" class="headerlink" title="1. Master Thread checkpoint"></a>1. Master Thread checkpoint</h3><p>每 1 或 10 秒将缓冲池中的部分脏页异步刷新到磁盘</p><h3 id="2-Async-Sync-Flush-checkpoint"><a href="#2-Async-Sync-Flush-checkpoint" class="headerlink" title="2. Async/Sync Flush checkpoint"></a>2. Async/Sync Flush checkpoint</h3><p>在重做日志不可用情况下强制刷新一部分页会磁盘。</p><h1 id="3-InnoDB-关键特性"><a href="#3-InnoDB-关键特性" class="headerlink" title="3. InnoDB 关键特性"></a>3. InnoDB 关键特性</h1><h2 id="1-插入缓冲"><a href="#1-插入缓冲" class="headerlink" title="1. 插入缓冲"></a>1. 插入缓冲</h2><h3 id="1-Insert-Buffer"><a href="#1-Insert-Buffer" class="headerlink" title="1. Insert Buffer"></a>1. Insert Buffer</h3><p>原理： 当对<strong>非聚集索</strong>引进<strong>行插入或更新</strong>操作时，若<strong>索引页在缓冲池</strong>中，则直接<strong>更新索引页</strong>。反之，先<strong>放到 Insert Buffer <strong>中，然后以一定频率将 Insert Buffer 中的数据和辅助索引页进行</strong>merge 操作</strong>。</p><p>前提：<strong>不是唯一索引的辅助索引</strong></p><p>问题：为什么不能是唯一索引？</p><p>因为唯一索引在更新时，需要将索引页加载进缓冲池中，判断索引是否唯一。将索引页加入了缓冲池中，就失去了使用 Insert Buffer 的意义。</p><p>作用：提高插入性能，因为每次插入时不需要立即将数据 merge 到索引页中。</p><p>本质：将非聚集索引的写操作缓冲起来，然后将写操作批量 merge 到索引页中。</p><p>缺点：写密集情况下会暂用大量缓冲池内存</p><p>可以通过 IBUF_POOL_SIZE_PER_MAX_SIZE 设置 Insert buffer 占缓冲池的比例</p><h3 id="2-change-buffer"><a href="#2-change-buffer" class="headerlink" title="2. change buffer"></a>2. change buffer</h3><p>insert buffer 的升级版，支持 insert 、delete、 update 语句缓冲。通过 Insert Buffer、 Delete Buffer 、Purge Buffer 来实现缓冲。</p><p>Update 语句的实现过程</p><ol><li>数据的记录标记为删除</li><li>数据真正删除</li></ol><p>将数据记录标记位删除通过，通过 Delete Buffer 来实现。然后通过 Purge Buffer 将数据真正删除。</p><h3 id="3-Insert-Buffer-内部实现"><a href="#3-Insert-Buffer-内部实现" class="headerlink" title="3. Insert Buffer 内部实现"></a>3. Insert Buffer 内部实现</h3><p>Insert Buffer 的数据结构是一颗 B+树。</p><p>非叶节点存放的查询的 search key .</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635779623534-a1a111a7-ba6f-4e06-9b28-2805adb882e1.png"></p><ul><li>space 表示数据插入的表的<strong>表空间 id（用于确定插入数据是哪张表）</strong></li><li>marker 兼容老版本的 Insert Buffer</li><li>offset 数据页在表中的偏移量（位置）（用于确定是辅助索引的哪一页）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635780351139-02db6f9a-d6eb-43b8-b2c3-006e96cac8da.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635780853424-d8b9a379-1c69-4fdb-bcb0-b7b93b0b0a50.png"></p><p>metadata 中记录信息插入的顺序以及插入信息的类型</p><p>Insert Buffer 通过 space 和 offset 确定更新数据的表和辅助索引具体页。</p><h3 id="4-Merge-Insert-Buffer"><a href="#4-Merge-Insert-Buffer" class="headerlink" title="4. Merge Insert Buffer"></a>4. Merge Insert Buffer</h3><h5 id="-3"><a href="#-3" class="headerlink" title=""></a></h5><ol><li>辅助索引页读取到缓冲池中</li><li>Insert Buffer Bitmap 页发现辅助索引页无可用空间时。</li><li>Master Thread 定时进行 Merge</li></ol><h3 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. 命令</h3><h4 id="1-innodb-change-buffering"><a href="#1-innodb-change-buffering" class="headerlink" title="1. innodb_change_buffering"></a>1. <code>innodb_change_buffering</code></h4><p>作用： 选择开启哪些缓冲，参数为<img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635779173141-60283c22-3b4a-4307-9afb-d2b31f2ecf19.png"></p><h4 id="2-innodb-change-buffer-max-size"><a href="#2-innodb-change-buffer-max-size" class="headerlink" title="2. innodb_change_buffer_max_size"></a>2. innodb_change_buffer_max_size</h4><p>作用：控制 change buffer 最大内存使用量</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635779232140-aea89c5b-1c60-420c-ad21-7455d07c85ef.png"></p><p><strong>最大值为 50.</strong></p><h2 id="2-两次写"><a href="#2-两次写" class="headerlink" title="2. 两次写"></a>2. 两次写</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1636031467126-3252bdd4-ab40-4f6e-9266-86cd36868636.png"></p><h3 id="1-流程"><a href="#1-流程" class="headerlink" title="1. 流程"></a>1. 流程</h3><ol><li>InnoDB 将脏页写到内存中的 Double write buffer 中</li><li>然后 DWB 将数据现在写入磁盘上 DWB</li><li>内存中的 DWB 再将数据刷到磁盘中</li></ol><h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><p>通过将脏页数据进行缓存，可以保证数据库异常关闭的情况下，脏页数据未完全写入磁盘时，无法通过 redo log 进行数据的恢复。可以通过 DWB 中之前保存的脏页数据，将数据页写入到磁盘中，然后 redo log 根据脏页进行数据的恢复。</p><p><a href="https://developer.aliyun.com/article/743889?spm=a2c6h.14164896.0.0.7d52783blX00fB">double write buffer 深度</a></p><h2 id="3-自适应哈希索引（AHI）"><a href="#3-自适应哈希索引（AHI）" class="headerlink" title="3. 自适应哈希索引（AHI）"></a>3. 自适应哈希索引（AHI）</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>由于哈希是一种时间复杂度为 O(1)的查找方法。可以通过在 B+树种建立哈希索引提高查询速度。</p><p>自适应哈希索引：存储引擎通过监控索引页的查询条件和频率，来选择是否建立哈希索引。</p><p>原理：通过缓冲池中的页</p><h3 id="2-前提"><a href="#2-前提" class="headerlink" title="2. 前提"></a>2. 前提</h3><ol><li>连续使用的查询条件一样</li><li>查询条件使用了 100 次</li><li>数据页通过该查询条件访问了（页中记录/16）次。</li></ol><h3 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h3><ol><li>提高了读取和写入速度</li><li>只能用来等值查询，不能范围查询</li></ol><h2 id="4-异步-IO"><a href="#4-异步-IO" class="headerlink" title="4. 异步 IO"></a>4. 异步 IO</h2><h3 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1. 作用"></a>1. 作用</h3><ol><li>异步执行 IO 操作</li><li>IO 合并</li></ol><h3 id="2-异步-IO-操作"><a href="#2-异步-IO-操作" class="headerlink" title="2. 异步 IO 操作"></a>2. 异步 IO 操作</h3><p>同步 IO: 用户发出 IO 请求后，需要等待 IO 请求完成，才能继续发送下一个 IO 请求。</p><p>异步 IO: 用户发出 IO 请求后不需要等待 IO 操作完成，可以继续发出 IO 请求。直到所有的 IO 请求发送完后，等待 IO 操作完成。</p><h3 id="3-IO-合并"><a href="#3-IO-合并" class="headerlink" title="3. IO 合并"></a>3. IO 合并</h3><p>AIO:将多个 IO 请求合并为一个 IO 请求。</p><p>例如： 用户需要访问多个连续页时（8,6）、（8,7）、（8,8）可以将多个 IO 操作合并成一个 IO 操作。</p><p>（page,offset）指代某个表的某一页。</p><h2 id="5-刷新临接页"><a href="#5-刷新临接页" class="headerlink" title="5. 刷新临接页"></a>5. 刷新临接页</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1636369637440-accdf8fa-3eba-4dfa-a7bd-ca3a30b7af22.png"></p><p>工作原理：刷新脏页时，会检测所在区的所有分页，然后通过 AIO 一起进行刷新。</p><p>建议机械硬盘开启特性，固态硬盘由于有着高性能的 IO 读写可以关闭。</p><h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/jpeg/12394516/1636370551211-b7e3691e-760d-4777-9125-49a114a0f304.jpeg&quot; alt=&quot;画板&quot;&gt;&lt;/p&gt;
&lt;h1 id=</summary>
      
    
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://xinc-it.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="https://xinc-it.github.io/tags/Mysql/"/>
    
    <category term="InnoDB" scheme="https://xinc-it.github.io/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>Java日期常用类</title>
    <link href="https://xinc-it.github.io/2021/12/24/Java%E6%97%A5%E6%9C%9F%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    <id>https://xinc-it.github.io/2021/12/24/Java%E6%97%A5%E6%9C%9F%E5%B8%B8%E7%94%A8%E7%B1%BB/</id>
    <published>2021-12-24T20:48:28.000Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SimpleDateFormate-类（日期格式化类）"><a href="#SimpleDateFormate-类（日期格式化类）" class="headerlink" title="SimpleDateFormate 类（日期格式化类）"></a>SimpleDateFormate 类（日期格式化类）</h1><p>Date 类大部分被废弃（不利于国际化），用日期格式化类来格式化日期</p><p>作用：格式化日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. SimpleDateFormat的两种操作</span></span><br><span class="line"><span class="comment">* 格式化：日期---》字符串</span></span><br><span class="line"><span class="comment">* 解析：字符串---》日期</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*2. SimpleDateFormat的实例化</span></span><br><span class="line"><span class="comment">* 常用带格式的实例化，进行初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 3. 日期&gt;&gt;&gt;字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String format = dateFormat.format(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(format);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 4. 字符串》》》日期</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Date parse = dateFormat.parse(<span class="string">&quot;2019-09-01 12:22:23&quot;</span>);</span><br><span class="line">System.out.println(parse);</span><br></pre></td></tr></table></figure><h2 id="日期常用格式化模式："><a href="#日期常用格式化模式：" class="headerlink" title="日期常用格式化模式："></a>日期常用格式化模式：</h2><table><thead><tr><th>格式</th><th>结果</th></tr></thead><tbody><tr><td>“yyyy.MM.dd G ‘at’ HH:mm:ss z”</td><td>2001.07.04 AD at 12:08:56 PDT</td></tr><tr><td>“EEE, MMM d, ‘’yy”</td><td>Wed, Jul 4, ‘01</td></tr><tr><td>“h:mm a”</td><td>12:08 PM</td></tr><tr><td>“hh ‘o’’clock’ a, zzzz”</td><td>12 o’clock PM, Pacific Daylight Time</td></tr><tr><td>“K:mm a, z”</td><td>0:08 PM, PDT</td></tr><tr><td>“yyyyy.MMMMM.dd GGG hh:mm aaa”</td><td>02001.July.04 AD 12:08 PM</td></tr><tr><td>“EEE, d MMM yyyy HH:mm:ss Z”</td><td>Wed, 4 Jul 2001 12:08:56 -0700</td></tr><tr><td>“yyMMddHHmmssZ”</td><td>010704120856-0700</td></tr><tr><td>“yyyy-MM-dd’T’HH:mm:ss.SSSZ”</td><td>2001-07-04T12:08:56.235-0700</td></tr><tr><td>“yyyy-MM-dd’T’HH:mm:ss.SSSXXX”</td><td>2001-07-04T12:08:56.235-07:00</td></tr><tr><td>“YYYY-‘W’ww-u”</td><td>2001-W27-3</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673443767764-17cc56c0-b738-4c9e-9dcd-27916a963cec.png"></p><h1 id="两个-Date-类的使用"><a href="#两个-Date-类的使用" class="headerlink" title="两个 Date 类的使用"></a>两个 Date 类的使用</h1><p>三天打鱼两天晒网练习题</p><p>从 1990-01-01 到任意日期需要打多少天鱼和晒多少天网？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDays</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">       String dateStr1 = <span class="string">&quot;1990-01-01&quot;</span>;</span><br><span class="line">       String dateStr2 = <span class="string">&quot;1990-01-07&quot;</span>;</span><br><span class="line">       SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">       Date date1 = dateFormat.parse(dateStr1);</span><br><span class="line">       Date date2 = dateFormat.parse(dateStr2);</span><br><span class="line">       <span class="keyword">long</span> dayNums = (date2.getTime() - date1.getTime()) / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">       <span class="keyword">long</span> times = dayNums / <span class="number">5</span>;</span><br><span class="line">       <span class="keyword">long</span> leftDays = dayNums % <span class="number">5</span>;</span><br><span class="line">       <span class="keyword">long</span> fishDays = times * <span class="number">3</span>;</span><br><span class="line">       <span class="keyword">long</span> netDays = (times * <span class="number">2</span>);</span><br><span class="line">       <span class="keyword">if</span> (leftDays &gt; <span class="number">3</span>) &#123;</span><br><span class="line">           fishDays += <span class="number">3</span>;</span><br><span class="line">           netDays += leftDays - <span class="number">3</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           fishDays += leftDays;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;打鱼总共：&quot;</span>+fishDays+<span class="string">&quot;  晒网：&quot;</span>+netDays);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="JDK-的-Date-类和-Calendar-类的问题"><a href="#JDK-的-Date-类和-Calendar-类的问题" class="headerlink" title="JDK 的 Date 类和 Calendar 类的问题"></a>JDK 的 Date 类和 Calendar 类的问题</h2><p>可变性：日期和时间的类应该不可变</p><p>偏移性：Date 中的年份从 1990 开始计算，月份从 0 开始</p><p>格式化:Calendar 不能格式化</p><p>线程不安全</p><h1 id="JDK8-的新增日期-API"><a href="#JDK8-的新增日期-API" class="headerlink" title="JDK8 的新增日期 API"></a>JDK8 的新增日期 API</h1><h2 id="LocalDate、LocalTIme、LocalDateTime-类"><a href="#LocalDate、LocalTIme、LocalDateTime-类" class="headerlink" title="LocalDate、LocalTIme、LocalDateTime 类"></a>LocalDate、LocalTIme、LocalDateTime 类</h2><h3 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673440907621-943d6b4b-f4e3-472a-b2a0-104d704ca4f6.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Local时间、日期类的两种实例化方式</span></span><br><span class="line"><span class="comment">* now（）获取当前日期、时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line"></span><br><span class="line">System.out.println(localDate);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(localTime);</span><br><span class="line">System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* of()获取指定日期、时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LocalDate localDate1 = LocalDate.of(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">LocalTime localTime1 = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>);</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(localDate1, localTime1);</span><br><span class="line">System.out.println(localDate1);</span><br><span class="line">System.out.println(localTime1);</span><br><span class="line">System.out.println(localDateTime1);</span><br></pre></td></tr></table></figure><h2 id="Instant-类"><a href="#Instant-类" class="headerlink" title="Instant 类"></a>Instant 类</h2><p>**记录从 1970 年到指定时间经历的毫秒数 **</p><h3 id="常用-API-1"><a href="#常用-API-1" class="headerlink" title="常用 API"></a>常用 API</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673441764498-e4a790ac-4d62-40e3-a99b-3f0800149c52.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Instant类的使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line"><span class="comment">//获取本初子午线的时间</span></span><br><span class="line">System.out.println(instant);</span><br><span class="line"><span class="comment">//偏移指定时间</span></span><br><span class="line">OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(offsetDateTime);</span><br></pre></td></tr></table></figure><h2 id="DateTimeFormatter-日期时间格式化类"><a href="#DateTimeFormatter-日期时间格式化类" class="headerlink" title="DateTimeFormatter 日期时间格式化类"></a>DateTimeFormatter 日期时间格式化类</h2><h3 id="常用-API-2"><a href="#常用-API-2" class="headerlink" title="常用 API"></a>常用 API</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673443905190-115a91c7-cde8-4966-92a0-f620b5d9cd43.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</span></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line"><span class="comment">//格式化:日期--&gt;字符串</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">String str1 = formatter.format(localDateTime);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(str1);<span class="comment">//2019-02-18T15:42:18.797</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析：字符串 --&gt;日期</span></span><br><span class="line">TemporalAccessor parse = formatter.parse(<span class="string">&quot;2019-02-18T15:42:18.797&quot;</span>);</span><br><span class="line">System.out.println(parse);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        方式二：</span></span><br><span class="line"><span class="comment">//        本地化相关的格式。如：ofLocalizedDateTime()</span></span><br><span class="line"><span class="comment">//        FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime</span></span><br><span class="line">DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String str2 = formatter1.format(localDateTime);</span><br><span class="line">System.out.println(str2);<span class="comment">//2019年2月18日 下午03时47分16秒</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      本地化相关的格式。如：ofLocalizedDate()</span></span><br><span class="line"><span class="comment">//      FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate</span></span><br><span class="line">DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String str3 = formatter2.format(LocalDate.now());</span><br><span class="line">System.out.println(str3);<span class="comment">//2019-2-18</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</span></span><br><span class="line">DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String str4 = formatter3.format(LocalDateTime.now());</span><br><span class="line">System.out.println(str4);<span class="comment">//2019-02-18 03:52:09</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line">TemporalAccessor accessor = formatter3.parse(<span class="string">&quot;2019-02-18 03:52:09&quot;</span>);</span><br><span class="line">System.out.println(accessor);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="日期-API"><a href="#日期-API" class="headerlink" title="日期 API"></a>日期 API</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673444174224-bcd7dbe4-a174-4e80-a872-6365b7e2c2d4.png"></p><p>日期时间类转换</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673444196839-36dae3ab-6baf-4120-b929-d6aabcdcf8f3.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SimpleDateFormate-类（日期格式化类）&quot;&gt;&lt;a href=&quot;#SimpleDateFormate-类（日期格式化类）&quot; class=&quot;headerlink&quot; title=&quot;SimpleDateFormate 类（日期格式化类）&quot;&gt;&lt;/a&gt;Simpl</summary>
      
    
    
    
    <category term="Java" scheme="https://xinc-it.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://xinc-it.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>String及其工具类</title>
    <link href="https://xinc-it.github.io/2021/12/24/String%E5%8F%8A%E5%85%B6%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://xinc-it.github.io/2021/12/24/String%E5%8F%8A%E5%85%B6%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2021-12-24T20:48:28.000Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h1><h2 id="String-字符串特性"><a href="#String-字符串特性" class="headerlink" title="String 字符串特性"></a>String 字符串特性</h2><ol><li> final 类，不可被继承</li><li> 实现 Serializable 接口，支持序列化</li><li> 实现 Comparable 接口，可比较大小</li><li> 内部使用 final char 数组存储字符串数据，解释类 String 不可更改原因</li><li>String 具有不变性,体现:<ol><li>字面量赋值，字符串值存储在字符串常量池中（常量池不会存储相同内容字符串）</li><li>对字符串进行修改（replace）或者是拼接（StringBuilder、StringBuffer、直接+）字符串时，不会修改原值，而是新建一个值，在新值上修改或拼接</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//字符串定义方式</span></span><br><span class="line">        String s1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1==s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;________________&quot;</span>);</span><br><span class="line">        <span class="comment">//字符串拼接不会修改原字符串值，会新建一个原值并修改</span></span><br><span class="line">        String s3=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        s3+=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s3==s1);</span><br><span class="line">        System.out.println(<span class="string">&quot;________________&quot;</span>);</span><br><span class="line">        <span class="comment">//字符串修改同拼接不会修改原值，会新建一个原值并修改</span></span><br><span class="line">        String s4=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        s4.replace(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">        System.out.println(s4==s1);</span><br><span class="line">        System.out.println(<span class="string">&quot;________________&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="String-字面量赋值和构造器赋值区别"><a href="#String-字面量赋值和构造器赋值区别" class="headerlink" title="String 字面量赋值和构造器赋值区别"></a>String 字面量赋值和构造器赋值区别</h2><hr><p>使用构造器的变量指向的地址是堆中的地址，堆再指向 abc</p><p>字面量变量地址指向的是 abc</p><p><strong>字符串常量池中不会存在两个相同的字符串</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673249278562-b7c20202-82f5-4cbb-9503-4211af8fd6d7.png"></p><h2 id="String-和基本数据类型、包装类之间转换"><a href="#String-和基本数据类型、包装类之间转换" class="headerlink" title="String 和基本数据类型、包装类之间转换"></a>String 和基本数据类型、包装类之间转换</h2><h3 id="String-转包装类、基本数据类型"><a href="#String-转包装类、基本数据类型" class="headerlink" title="String 转包装类、基本数据类型"></a>String 转包装类、基本数据类型</h3><p>调用对应包装类的 parseXxx（Str）方法</p><h3 id="包装类、基本数据类型转-String"><a href="#包装类、基本数据类型转-String" class="headerlink" title="包装类、基本数据类型转 String"></a>包装类、基本数据类型转 String</h3><p>调用 String 类的 valueOf();</p><h2 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h2><h3 id="构造器创建的字符串在内存中创建了几个对象？"><a href="#构造器创建的字符串在内存中创建了几个对象？" class="headerlink" title="构造器创建的字符串在内存中创建了几个对象？"></a>构造器创建的字符串在内存中创建了几个对象？</h3><p>最多两个，如果字符串常量池中存在该字符串，则只在堆中创建一个空间，存放字符串常量池中对应字符串的地址！！！</p><h3 id="String-陷阱"><a href="#String-陷阱" class="headerlink" title="String 陷阱"></a>String 陷阱</h3><p><font style="color:rgb(0,0,0);">String s1 = “a”; </font></p><p><font style="color:rgb(0,0,0);">说明：在字符串常量池中创建了一个字面量为</font><font style="color:rgb(0,0,0);">“a”</font><font style="color:rgb(0,0,0);">的字符串。 </font></p><p><font style="color:rgb(0,0,0);">s1 = s1 + “b”; </font></p><p><font style="color:rgb(0,0,0);">说明：实际上原来的</font><font style="color:rgb(0,0,0);">“a”</font><font style="color:rgb(0,0,0);">字符串对象已经丢弃了，现在在堆空间中产生了一个字符 </font></p><p><font style="color:rgb(0,0,0);">串</font><font style="color:rgb(0,0,0);">s1+”b”</font><font style="color:rgb(0,0,0);">（也就是</font><font style="color:rgb(0,0,0);">“ab”)</font><font style="color:rgb(0,0,0);">。如果多次执行这些改变串内容的操作，会导致大量副本 </font></p><p><font style="color:rgb(0,0,0);">字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响 </font></p><p><font style="color:rgb(0,0,0);">程序的性能。 </font></p><p><font style="color:rgb(0,0,0);">String s2 = “ab”; </font></p><p><font style="color:rgb(0,0,0);">说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。 String s3 = “a” + “b”; </font></p><p><font style="color:rgb(0,0,0);">说明：</font><font style="color:rgb(0,0,0);">s3</font><font style="color:rgb(0,0,0);">指向字符串常量池中已经创建的</font><font style="color:rgb(0,0,0);">“ab”</font><font style="color:rgb(0,0,0);">的字符串。 </font></p><p><font style="color:rgb(0,0,0);">String s4 = s1.intern(); </font></p><p><font style="color:rgb(0,0,0);">说明：堆空间的</font><font style="color:rgb(0,0,0);">s1</font><font style="color:rgb(0,0,0);">对象在调用</font><font style="color:rgb(0,0,0);">intern()</font><font style="color:rgb(0,0,0);">之后，会将常量池中已经存在的</font><font style="color:rgb(0,0,0);">“ab”</font><font style="color:rgb(0,0,0);">字符串 </font></p><p><font style="color:rgb(0,0,0);">赋值给 s4。</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String  s9=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">       String  s10=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">       String  s11=<span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">       String  s12=s9+<span class="string">&quot;world&quot;</span>;</span><br><span class="line">       String  s13=<span class="string">&quot;hello&quot;</span>+s10;</span><br><span class="line">       String  s14=s9+s10;</span><br><span class="line">       String  s15=<span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">       <span class="comment">//true</span></span><br><span class="line">       System.out.println(s15==s11);</span><br><span class="line">       <span class="comment">//false</span></span><br><span class="line">       System.out.println(s12==s11);</span><br><span class="line">       <span class="comment">//false</span></span><br><span class="line">       System.out.println(s13==s11);</span><br><span class="line">       <span class="comment">//false</span></span><br><span class="line">       System.out.println(s14==s11);</span><br><span class="line">       <span class="comment">//false</span></span><br><span class="line">       System.out.println(s12==s14);</span><br><span class="line">  String s16=s14.intern();</span><br><span class="line">       System.out.println(s11==s16);</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>常量与常量的拼接修改结果存在常量池中，且<strong>不会存在相同内容的常量</strong></li><li>只要是变量的拼接或修改，地址为堆中的地址。</li><li>调用 intern 返回的是常量池中存在的地址</li></ol><h1 id="StringBuffer-和-StringBuilder-类"><a href="#StringBuffer-和-StringBuilder-类" class="headerlink" title="StringBuffer 和 StringBuilder 类"></a>StringBuffer 和 StringBuilder 类</h1><h2 id="三者异同点"><a href="#三者异同点" class="headerlink" title="三者异同点"></a>三者异同点</h2><p>String：不可变字符串序列<br>StringBuffer：线程安全，效率低，可变字符串序列<br>StringBuilder：线程不安全，效率高，可变字符串序列 jdk5 新增<br>原因：append 方法是否被 synchronized 修饰</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>StringBuffer sb1=new StringBuffer();//底层创建一个长度为 16 的 char 数组<br>sb1.append(‘a’);//value[0]=a;<br>sb1.length()//等于数组实际存储的字符数，不等于数组长度</p><h2 id="扩容流程"><a href="#扩容流程" class="headerlink" title="扩容流程"></a>扩容流程</h2><ol><li>调用 append 方法，</li><li>调用父类的 append 方法</li><li>调用 ensureCapacityInternal，确保数组长度够用</li><li>如果不够用进行数组长度*2+2，再调用 arraysCopy 的方法将原有数组复制到新数组中</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12394516/1673318843665-557757a1-23f3-4488-92e2-c302667c2fa4.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;String-类&quot;&gt;&lt;a href=&quot;#String-类&quot; class=&quot;headerlink&quot; title=&quot;String 类&quot;&gt;&lt;/a&gt;String 类&lt;/h1&gt;&lt;h2 id=&quot;String-字符串特性&quot;&gt;&lt;a href=&quot;#String-字符串特性&quot; cla</summary>
      
    
    
    
    <category term="Java" scheme="https://xinc-it.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://xinc-it.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>枚举和注解</title>
    <link href="https://xinc-it.github.io/2021/12/24/%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
    <id>https://xinc-it.github.io/2021/12/24/%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-12-24T20:48:28.000Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="枚举类的使用"><a href="#枚举类的使用" class="headerlink" title="枚举类的使用"></a>枚举类的使用</h1><h2 id="枚举类的定义"><a href="#枚举类的定义" class="headerlink" title="枚举类的定义"></a>枚举类的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SeasonEnums</span> </span>&#123;</span><br><span class="line">    <span class="comment">//提供当前枚举类的对象</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>), SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>), AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>), WINNER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    SeasonEnums(String name, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SeasonEnums&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="枚举类的方法使用"><a href="#枚举类的方法使用" class="headerlink" title="枚举类的方法使用"></a>枚举类的方法使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SeasonEnums.WINNER);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. values（）获取所有的枚举对象</span></span><br><span class="line">SeasonEnums[] values = SeasonEnums.values();</span><br><span class="line"><span class="keyword">for</span> (SeasonEnums value : values) &#123;</span><br><span class="line">System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. valueOf(String str)通过枚举对象名，获取对应枚举对象信息</span></span><br><span class="line">SeasonEnums spring = SeasonEnums.valueOf(<span class="string">&quot;SPRING&quot;</span>);</span><br><span class="line">System.out.println(spring);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SeasonEnums&#123;name=&#x27;冬天&#x27;, desc=&#x27;冰天雪地&#x27;&#125;</span></span><br><span class="line"><span class="comment">SeasonEnums&#123;name=&#x27;春天&#x27;, desc=&#x27;春暖花开&#x27;&#125;</span></span><br><span class="line"><span class="comment">SeasonEnums&#123;name=&#x27;夏天&#x27;, desc=&#x27;夏日炎炎&#x27;&#125;</span></span><br><span class="line"><span class="comment">SeasonEnums&#123;name=&#x27;秋天&#x27;, desc=&#x27;秋高气爽&#x27;&#125;</span></span><br><span class="line"><span class="comment">SeasonEnums&#123;name=&#x27;冬天&#x27;, desc=&#x27;冰天雪地&#x27;&#125;</span></span><br><span class="line"><span class="comment">SeasonEnums&#123;name=&#x27;春天&#x27;, desc=&#x27;春暖花开&#x27;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="枚举类实现接口的方式"><a href="#枚举类实现接口的方式" class="headerlink" title="枚举类实现接口的方式"></a>枚举类实现接口的方式</h1><h2 id="枚举类中实现抽象方法"><a href="#枚举类中实现抽象方法" class="headerlink" title="枚举类中实现抽象方法"></a>枚举类中实现抽象方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SeasonEnums</span> <span class="keyword">implements</span> <span class="title">Show</span> </span>&#123;</span><br><span class="line">    <span class="comment">//提供当前枚举类的对象</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>), SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>), AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>), WINNER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    SeasonEnums(String name, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SeasonEnums&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举类实现接口的一种方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个季节&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举对象中实现抽象方法"><a href="#枚举对象中实现抽象方法" class="headerlink" title="枚举对象中实现抽象方法"></a>枚举对象中实现抽象方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SeasonEnums</span> <span class="keyword">implements</span> <span class="title">Show</span> </span>&#123;</span><br><span class="line">    <span class="comment">//提供当前枚举类的对象</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, WINNER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    SeasonEnums(String name, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SeasonEnums&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;枚举类的使用&quot;&gt;&lt;a href=&quot;#枚举类的使用&quot; class=&quot;headerlink&quot; title=&quot;枚举类的使用&quot;&gt;&lt;/a&gt;枚举类的使用&lt;/h1&gt;&lt;h2 id=&quot;枚举类的定义&quot;&gt;&lt;a href=&quot;#枚举类的定义&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Java" scheme="https://xinc-it.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://xinc-it.github.io/tags/Java/"/>
    
    <category term="注解" scheme="https://xinc-it.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
    <category term="枚举" scheme="https://xinc-it.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>Buttterfly美化教程集合</title>
    <link href="https://xinc-it.github.io/2021/12/20/Buttterfly%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B%E9%9B%86%E5%90%88/"/>
    <id>https://xinc-it.github.io/2021/12/20/Buttterfly%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B%E9%9B%86%E5%90%88/</id>
    <published>2021-12-20T22:06:26.000Z</published>
    <updated>2024-11-21T17:02:44.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-设置背景渐变效果"><a href="#1-设置背景渐变效果" class="headerlink" title="1. 设置背景渐变效果"></a>1. 设置背景渐变效果</h1><h2 id="1-效果图"><a href="#1-效果图" class="headerlink" title="1.效果图"></a>1.效果图</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1640016968691-40cf8542-0c0d-476f-a342-ef7803df0029.png"></p><h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2.步骤"></a>2.步骤</h2><ol><li>在博客根目录下的<code>themes\butterfly\source\css</code>创建一个 css 后缀文件</li><li>在新建的后缀文件中添加如下配置。 由于每个人用的 butterfly 版本不同，所以修改的不一定是#body-wrap。具体需要通过在页面上使用<code>F12</code>，查看标签对应的 id。<img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1640017441534-b130e721-df0c-4ca7-b538-913c9c50d77f.png"></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修改文章页背景及透明度 */</span></span><br><span class="line"><span class="selector-id">#body-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(</span><br><span class="line">    <span class="number">0deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">247</span>, <span class="number">149</span>, <span class="number">51</span>, <span class="number">0.1</span>) <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">243</span>, <span class="number">112</span>, <span class="number">85</span>, <span class="number">0.1</span>) <span class="number">15%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">239</span>, <span class="number">78</span>, <span class="number">123</span>, <span class="number">0.1</span>) <span class="number">30%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">161</span>, <span class="number">102</span>, <span class="number">171</span>, <span class="number">0.1</span>) <span class="number">44%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">80</span>, <span class="number">115</span>, <span class="number">184</span>, <span class="number">0.1</span>) <span class="number">58%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">16</span>, <span class="number">152</span>, <span class="number">173</span>, <span class="number">0.1</span>) <span class="number">72%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">7</span>, <span class="number">179</span>, <span class="number">155</span>, <span class="number">0.1</span>) <span class="number">86%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">109</span>, <span class="number">186</span>, <span class="number">130</span>, <span class="number">0.1</span>) <span class="number">100%</span></span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(</span><br><span class="line">    <span class="number">0deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">247</span>, <span class="number">149</span>, <span class="number">51</span>, <span class="number">0.1</span>) <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">243</span>, <span class="number">112</span>, <span class="number">85</span>, <span class="number">0.1</span>) <span class="number">15%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">239</span>, <span class="number">78</span>, <span class="number">123</span>, <span class="number">0.1</span>) <span class="number">30%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">161</span>, <span class="number">102</span>, <span class="number">171</span>, <span class="number">0.1</span>) <span class="number">44%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">80</span>, <span class="number">115</span>, <span class="number">184</span>, <span class="number">0.1</span>) <span class="number">58%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">16</span>, <span class="number">152</span>, <span class="number">173</span>, <span class="number">0.1</span>) <span class="number">72%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">7</span>, <span class="number">179</span>, <span class="number">155</span>, <span class="number">0.1</span>) <span class="number">86%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">109</span>, <span class="number">186</span>, <span class="number">130</span>, <span class="number">0.1</span>) <span class="number">100%</span></span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(</span><br><span class="line">    <span class="number">0deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">247</span>, <span class="number">149</span>, <span class="number">51</span>, <span class="number">0.1</span>) <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">243</span>, <span class="number">112</span>, <span class="number">85</span>, <span class="number">0.1</span>) <span class="number">15%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">239</span>, <span class="number">78</span>, <span class="number">123</span>, <span class="number">0.1</span>) <span class="number">30%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">161</span>, <span class="number">102</span>, <span class="number">171</span>, <span class="number">0.1</span>) <span class="number">44%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">80</span>, <span class="number">115</span>, <span class="number">184</span>, <span class="number">0.1</span>) <span class="number">58%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">16</span>, <span class="number">152</span>, <span class="number">173</span>, <span class="number">0.1</span>) <span class="number">72%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">7</span>, <span class="number">179</span>, <span class="number">155</span>, <span class="number">0.1</span>) <span class="number">86%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">109</span>, <span class="number">186</span>, <span class="number">130</span>, <span class="number">0.1</span>) <span class="number">100%</span></span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-ms-linear-gradient</span>(</span><br><span class="line">    <span class="number">0deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">247</span>, <span class="number">149</span>, <span class="number">51</span>, <span class="number">0.1</span>) <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">243</span>, <span class="number">112</span>, <span class="number">85</span>, <span class="number">0.1</span>) <span class="number">15%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">239</span>, <span class="number">78</span>, <span class="number">123</span>, <span class="number">0.1</span>) <span class="number">30%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">161</span>, <span class="number">102</span>, <span class="number">171</span>, <span class="number">0.1</span>) <span class="number">44%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">80</span>, <span class="number">115</span>, <span class="number">184</span>, <span class="number">0.1</span>) <span class="number">58%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">16</span>, <span class="number">152</span>, <span class="number">173</span>, <span class="number">0.1</span>) <span class="number">72%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">7</span>, <span class="number">179</span>, <span class="number">155</span>, <span class="number">0.1</span>) <span class="number">86%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">109</span>, <span class="number">186</span>, <span class="number">130</span>, <span class="number">0.1</span>) <span class="number">100%</span></span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(</span><br><span class="line">    <span class="number">90deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">247</span>, <span class="number">149</span>, <span class="number">51</span>, <span class="number">0.1</span>) <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">243</span>, <span class="number">112</span>, <span class="number">85</span>, <span class="number">0.1</span>) <span class="number">15%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">239</span>, <span class="number">78</span>, <span class="number">123</span>, <span class="number">0.1</span>) <span class="number">30%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">161</span>, <span class="number">102</span>, <span class="number">171</span>, <span class="number">0.1</span>) <span class="number">44%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">80</span>, <span class="number">115</span>, <span class="number">184</span>, <span class="number">0.1</span>) <span class="number">58%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">16</span>, <span class="number">152</span>, <span class="number">173</span>, <span class="number">0.1</span>) <span class="number">72%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">7</span>, <span class="number">179</span>, <span class="number">155</span>, <span class="number">0.1</span>) <span class="number">86%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">109</span>, <span class="number">186</span>, <span class="number">130</span>, <span class="number">0.1</span>) <span class="number">100%</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-页脚渐变透明"><a href="#2-页脚渐变透明" class="headerlink" title="2. 页脚渐变透明"></a>2. 页脚渐变透明</h1><h2 id="1-效果图-1"><a href="#1-效果图-1" class="headerlink" title="1. 效果图"></a>1. 效果图</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1640017580407-35c4e83d-2e35-4bb0-b987-02d04521b0db.png"></p><h2 id="2-步骤-1"><a href="#2-步骤-1" class="headerlink" title="2. 步骤"></a>2. 步骤</h2><ol><li>在博客根目录下的<code>themes\butterfly\source\css</code>创建一个 css 后缀文件</li><li>在新建的后缀文件中添加如下配置</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 页脚透明渐变 */</span></span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.15</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-top-right-radius</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-top-left-radius</span>: <span class="number">20px</span>;</span><br><span class="line">  backdrop-<span class="attribute">filter</span>: <span class="built_in">saturate</span>(<span class="number">100%</span>) <span class="built_in">blur</span>(<span class="number">5px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#footer</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.15</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#footer</span> <span class="selector-id">#footer-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--font-color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#footer</span> <span class="selector-id">#footer-wrap</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--font-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-页脚徽标设置"><a href="#3-页脚徽标设置" class="headerlink" title="3. 页脚徽标设置"></a>3. 页脚徽标设置</h1><h2 id="1-效果图-2"><a href="#1-效果图-2" class="headerlink" title="1. 效果图"></a>1. 效果图</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1640017751461-338d3075-c47d-4fc5-9e9b-e6d863333636.png"></p><h2 id="2-步骤-2"><a href="#2-步骤-2" class="headerlink" title="2.步骤"></a>2.步骤</h2><p>在_cofing.yml 中添加如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">&lt;p&gt;&lt;a</span> <span class="string">style=&quot;margin-inline:5px&quot;target=&quot;_blank&quot;</span> <span class="string">href=&quot;https://hexo.io/&quot;&gt;&lt;img</span> <span class="string">src=&quot;https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo&quot;</span> <span class="string">title=&quot;博客框架为</span> <span class="string">Hexo&quot;</span> <span class="string">alt=&quot;HEXO&quot;&gt;&lt;/a&gt;&lt;a</span> <span class="string">style=&quot;margin-inline:5px&quot;target=&quot;_blank&quot;</span> <span class="string">href=&quot;https://butterfly.js.org/&quot;&gt;&lt;img</span> <span class="string">src=&quot;https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender&quot;</span> <span class="string">title=&quot;主题采用</span> <span class="string">Butterfly&quot;</span> <span class="string">alt=&quot;Butterfly&quot;&gt;&lt;/a&gt;&lt;a</span> <span class="string">style=&quot;margin-inline:5px&quot;target=&quot;_blank&quot;</span> <span class="string">href=&quot;https://www.jsdelivr.com/&quot;&gt;&lt;img</span> <span class="string">src=&quot;https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr&quot;</span> <span class="string">title=&quot;本站使用</span> <span class="string">Jsdelivr</span> <span class="string">为静态资源提供CDN加速&quot;</span> <span class="string">alt=&quot;Jsdelivr&quot;&gt;&lt;/a&gt;&lt;a</span> <span class="string">style=&quot;margin-inline:5px&quot;target=&quot;_blank&quot;</span> <span class="string">href=&quot;https://github.com/&quot;&gt;&lt;img</span> <span class="string">src=&quot;https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub&quot;</span> <span class="string">title=&quot;本站项目由</span> <span class="string">GitHub</span> <span class="string">托管&quot;</span> <span class="string">alt=&quot;GitHub&quot;&gt;&lt;/a&gt;&lt;a</span> <span class="string">style=&quot;margin-inline:5px&quot;target=&quot;_blank&quot;href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img</span> <span class="string">src=&quot;https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris&quot;</span> <span class="string">alt=&quot;img&quot;</span> <span class="string">title=&quot;本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可&quot;&gt;&lt;/a&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4-图片懒加载"><a href="#4-图片懒加载" class="headerlink" title="4. 图片懒加载"></a>4. 图片懒加载</h1><h2 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1. 步骤"></a>1. 步骤</h2><ol><li>安装懒加载插件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure><ol start="2"><li>在配置文件对应主题.yml 中添加配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazyload:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  onlypost: <span class="literal">false</span>  <span class="comment"># 是否只对文章的图片做懒加载</span></span><br><span class="line">  loadingImg: <span class="comment"># eg ./images/loading.gif</span></span><br></pre></td></tr></table></figure><p>[</p><p>](<a href="http://img.wuxin.website/img/b3f6b2565c3149a2a8df94ab43cf3a3b.jpg">http://img.wuxin.website/img/b3f6b2565c3149a2a8df94ab43cf3a3b.jpg</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-设置背景渐变效果&quot;&gt;&lt;a href=&quot;#1-设置背景渐变效果&quot; class=&quot;headerlink&quot; title=&quot;1. 设置背景渐变效果&quot;&gt;&lt;/a&gt;1. 设置背景渐变效果&lt;/h1&gt;&lt;h2 id=&quot;1-效果图&quot;&gt;&lt;a href=&quot;#1-效果图&quot; class=&quot;</summary>
      
    
    
    
    <category term="Butterfly" scheme="https://xinc-it.github.io/categories/Butterfly/"/>
    
    
    <category term="hexo" scheme="https://xinc-it.github.io/tags/hexo/"/>
    
    <category term="Butterfly" scheme="https://xinc-it.github.io/tags/Butterfly/"/>
    
  </entry>
  
</feed>
