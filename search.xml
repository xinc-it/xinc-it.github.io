<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mysql-事务隔离</title>
    <url>/2022/09/07/3!%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<html><head></head><body><h2 id="1-隔离性和隔离级别"><a href="#1-隔离性和隔离级别" class="headerlink" title="1. 隔离性和隔离级别"></a>1. 隔离性和隔离级别</h2><h3 id="1-事务特性"><a href="#1-事务特性" class="headerlink" title="1. 事务特性"></a>1. 事务特性</h3><ol>
<li><strong>原子性</strong></li>
<li><strong>持久性</strong></li>
<li><strong>隔离性</strong></li>
<li><strong>一致性</strong></li>
</ol>
<h3 id="2-事务隔离级别"><a href="#2-事务隔离级别" class="headerlink" title="2. 事务隔离级别"></a>2. 事务隔离级别</h3><ol>
<li><strong>读已提交（事务未提交时，变更能被其它事务看到）</strong></li>
<li><strong>读未提交（事务提交后，其它事务才能看到变更）</strong></li>
<li><strong>可重复读（一个事务执行过程中，总是跟启动时看到的数据是一致的。未提交的变更对其它事务不可见）</strong></li>
<li><strong>串行化（同一行记录写会加写锁，读会读锁。当出现读写锁冲突时，后访问的事务，必须等前一个事务完成，才能执行）</strong></li>
</ol>
<p><strong>​</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630988923063-4d56a761-7637-488b-951d-c443de806cb1.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=381&amp;id=uf414196c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=762&amp;originWidth=788&amp;originalType=binary&amp;ratio=1&amp;size=201874&amp;status=done&amp;style=none&amp;taskId=u19543944-dee4-4fbf-bf51-efae564dfae&amp;width=394" alt="image.png"></p>
<p>v1=v2=1,v3=2<br>四种事务得到的结果</p>
<ol>
<li>读未提交： v1、v2、v3=2</li>
<li>读已提交: v1=1 ，v2、v3=2</li>
<li>可重复读：v1=v2=1，v3=2</li>
<li>可串行化 ： v1=v2=1,v3=2</li>
</ol>
<p><strong>​</strong></p>
<p>​</p>
<h2 id="2-事务隔离的实现"><a href="#2-事务隔离的实现" class="headerlink" title="2. 事务隔离的实现"></a>2. 事务隔离的实现</h2><p>当一个值从 1 按顺序变成 2，3，3 那么他的日志里面就会有类似的回滚段记录<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631013980123-b4f659d1-a49a-4d6f-bffa-5c049fb7a4b5.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=259&amp;id=u4bd92b33&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=517&amp;originWidth=906&amp;originalType=binary&amp;ratio=1&amp;size=104426&amp;status=done&amp;style=none&amp;taskId=ub4313c28-1bd9-45bf-a56d-abe4cf1987a&amp;width=453" alt="image.png"><br>如图事务 A、B、C 修改记录导致一个字段对应多个值。<br>​</p>
<p>通过 MVCC 来实现一个数据的多个版本，通过 undo log 实现数据版本的回滚<br>通过 MVCC 和 undo log 来实现事务的隔离<br>具体可以参考</p>
<p><a href="https://www.yuque.com/sanxingalaxys9/gwxct1/lq01qk?view=doc_embed">Mysql 实战 45 讲</a></p>
<p>当回滚段日志过长时，系统会自动清除。<br>​</p>
<p>​</p>
<p>​</p>
<h2 id="3-事务的启动方式"><a href="#3-事务的启动方式" class="headerlink" title="3. 事务的启动方式"></a>3. 事务的启动方式</h2><ol>
<li>set autocommit=0 关闭自动提交，只要执行 select 语句自动开启事务</li>
<li>begin 或是 start transaction</li>
</ol>
<p>​</p>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><ol>
<li>四大特性和隔离级别</li>
<li>事务隔离的实现（通过 MVCC 和 undo log)</li>
<li>事务的启动方式<ol>
<li>自动启动 select 语句执行时自动启动</li>
<li>手动启动 begin、 start transaction</li>
</ol>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-更新语句的执行</title>
    <url>/2022/09/06/2!%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<html><head></head><body><h2 id="1-更新语句执行流程"><a href="#1-更新语句执行流程" class="headerlink" title="1. 更新语句执行流程"></a>1. 更新语句执行流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630974533552-29681b12-3ee4-4012-ae23-882ab740984d.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=337&amp;id=u6f547220&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=674&amp;originWidth=928&amp;originalType=binary&amp;ratio=1&amp;size=239274&amp;status=done&amp;style=none&amp;taskId=u902b2c56-0159-4ac1-9ecc-7c0453d9054&amp;width=464" alt="image.png"></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; update T <span class="built_in">set</span> c=c+1 <span class="built_in">where</span> ID=2;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>客户端通过连接器连接 MySQL 服务器</li>
<li>将缓存中相关表的结果清空</li>
<li>分析器通过词法和语法分析判断是更新语句</li>
<li>优化器通过索引，决定使用 ID 的索引</li>
<li>执行器执行更新语句</li>
<li>进行 redo log 和 bin log 的修改</li>
</ol>
<p>​</p>
<h2 id="2-Redo-log-引擎日志"><a href="#2-Redo-log-引擎日志" class="headerlink" title="2.Redo log(引擎日志)"></a>2.Redo log(引擎日志)</h2><p>情景老板记账：先把借帐和还账记录写在黑板上，空闲时，再把黑板上账的写入到账本中。</p>
<p>作用： 用作数据库写入将数据磁盘的缓存，防止每次更新都要将数据写进磁盘，提高了更新效率。<br>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630975170760-0904cfb2-ee0b-4650-a584-bb831be94070.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=328&amp;id=u5e5e1dba&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=655&amp;originWidth=943&amp;originalType=binary&amp;ratio=1&amp;size=104067&amp;status=done&amp;style=none&amp;taskId=u353c490e-0715-407a-9113-50af777809c&amp;width=471.5" alt="image.png"><br>​</p>
<p>​</p>
<p>​</p>
<h3 id="1-WAL-Write-Ahead-Logging"><a href="#1-WAL-Write-Ahead-Logging" class="headerlink" title="1. WAL (Write-Ahead Logging)"></a>1. WAL (Write-Ahead Logging)</h3><p><strong>先写日志，再写磁盘</strong>。<br>InnoDB 引擎会把记录写道 redo log 中，并更新内存。然后更新就算完成。引擎会在空闲时间操作记录<br>写入磁盘。<br>如果 redo log 写满了，会把一部分记录更新到磁盘中。<br>通过 write pos 和 check point 两个指针来判断日志是否写满</p>
<h3 id="2-crash-safe"><a href="#2-crash-safe" class="headerlink" title="2. crash-safe"></a>2. crash-safe</h3><p>当数据库发生异常时，可以通过 redo log 可以获取到之前的提交记录。<br>通过提交记录可以将未同步到数据库中数据同步到数据库中。<br>​</p>
<p><strong>redo log 存储的是物理变更日志，用于记录磁盘中指定地方的数值修改记录。</strong><br>​</p>
<p>​</p>
<h3 id="3-特点"><a href="#3-特点" class="headerlink" title="3. 特点"></a>3. 特点</h3><p>​</p>
<ol>
<li> 存储的物理日志（记录的是数据页上数据的更改）</li>
<li> 先写日志，后写磁盘</li>
<li> 可以 crash safe 进行数据的修复</li>
<li> InnoDB 引擎层日志</li>
<li> 空间有限会用完，通过队列的实现循环写</li>
</ol>
<h2 id="3-binlog（Server-层日志）"><a href="#3-binlog（Server-层日志）" class="headerlink" title="3. binlog（Server 层日志）"></a>3. binlog（Server 层日志）</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><ol>
<li>服务层日志</li>
<li>存储的内容是逻辑日志（记录的是语句的原始逻辑）</li>
<li>空间无限，通过新增文件实现追加写</li>
</ol>
<h2 id="4-执行流程"><a href="#4-执行流程" class="headerlink" title="4. 执行流程"></a>4. 执行流程</h2><ol>
<li>执行引擎先找到 ID=2 的这一行数据，如果内存中存在直接返回给执行器，否则从磁盘读入内存然后返回给执行器</li>
<li>把值加上 1，然后调用引擎接口写入数据</li>
<li>引擎会将新数据更新到内存中，同时更新到 redo log 中。redo log 处于 prepare 状态，告诉执行器完成了，可以提交事务了。</li>
<li>执行器生成更新操作的 bin log,并把 bin log 写入磁盘</li>
<li>执行器调用引擎的事务接口，将写入的 redo log 改成 commit 状态</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634976756709-8dbcb97a-235f-4b93-a181-f46a29389d94.png#clientId=u359acdfd-faff-4&amp;from=paste&amp;height=525&amp;id=u4d800135&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1050&amp;originWidth=686&amp;originalType=binary&amp;ratio=1&amp;size=168644&amp;status=done&amp;style=none&amp;taskId=u39624d17-5f0a-4d9a-931c-683c5152009&amp;width=343" alt="image.png"></p>
<h2 id="5-两阶段提交"><a href="#5-两阶段提交" class="headerlink" title="5. 两阶段提交"></a>5. 两阶段提交</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630988222445-a6208d34-24c4-4e8d-89b2-8952bbb46186.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=198&amp;id=u6943ccfd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=396&amp;originWidth=651&amp;originalType=binary&amp;ratio=1&amp;size=113756&amp;status=done&amp;style=none&amp;taskId=udaf78fe9-6800-4ea4-af49-47d717da835&amp;width=325.5" alt="image.png"></p>
<p><strong>​</strong></p>
<p><strong>原因</strong></p>
<ol>
<li>如果发生 crash 导致系统崩溃的话，如果顺序不一致，可能导致之后无法通过 binlog 恢复到任一时刻的数据</li>
<li>可能导致 binlog 和 redo log 的数据不一致导致数据冲突。</li>
</ol>
<h2 id="6-两种日志的不同点"><a href="#6-两种日志的不同点" class="headerlink" title="6. 两种日志的不同点"></a>6. 两种日志的不同点</h2><ol>
<li>redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的</li>
<li>redo log 是物理日志，记录的是 <strong>在某个数据页上做了修改</strong>，binlog 是逻辑日志记录的是语句逻辑 <strong>给 ID=2 的数据进行加 1</strong></li>
<li>redo log 是循环写，空间大小固定。bin log 是追加写，当 bin log 文件到达一定大小后会切换到下一个，不会覆盖以前的日志</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><ol>
<li>更新语句的执行流程</li>
<li>Redo log 的作用是用来存储 MySQL 产生更新语句的物理日志。通过 WAL 技术先将日志写入 队列中然偶后通过指定条件写入磁盘中</li>
<li>bin log 的作用和特点</li>
<li>两种日志的不同点</li>
<li>两阶段提交的作用<ol>
<li>保证数据库的数据不冲突</li>
</ol>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-锁</title>
    <url>/2021/09/10/5!%E9%94%81/</url>
    <content><![CDATA[<html><head></head><body><h2 id="1-锁的分类："><a href="#1-锁的分类：" class="headerlink" title="1. 锁的分类："></a>1. 锁的分类：</h2><p><strong>根据加锁范围：</strong></p>
<ol>
<li><strong>全局锁</strong></li>
<li><strong>表级锁</strong></li>
<li><strong>行锁</strong></li>
</ol>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<h2 id="2-全局锁"><a href="#2-全局锁" class="headerlink" title="2. 全局锁"></a>2. 全局锁</h2><p>全局读锁命令<br><strong>全局锁就是对整个数据库实例加锁，Mysql 提供了一个加全局读锁的命令。可以让整个数据库处于只读状态。</strong><br>导致数据的增删改、建表修改表语句、事务的提交语句失效。</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></tbody></table></figure>

<p>场景：<strong>全库的逻辑备份(也可以开启可重复读事务级别来进行备份)</strong><br>另一种方式是使用 mysqldump 工具使用参数-single-transaction 进行数据库备份。前提：数据库中所有的表支持可重复读。<br>​</p>
<p>​</p>
<p>场景：用户买课和买课后的余额。不加锁导致两个表的数据前后不一致。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631018821575-900c6793-130c-47c3-8b6c-b3533bf27c70.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=271&amp;id=u5e04065e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=542&amp;originWidth=882&amp;originalType=binary&amp;ratio=1&amp;size=204494&amp;status=done&amp;style=none&amp;taskId=uadb7ab82-ba93-48d1-a88f-e117005dcaf&amp;width=441" alt="image.png"></p>
<h2 id="3-表级锁"><a href="#3-表级锁" class="headerlink" title="3. 表级锁"></a>3. 表级锁</h2><ol>
<li>两种表锁</li>
</ol>
<p>​</p>
<ul>
<li>表锁</li>
<li>元数据锁</li>
</ul>
<p>​</p>
<p>​</p>
<p>​</p>
<ol start="2">
<li>表锁</li>
</ol>
<p>​</p>
<p>作用：<strong>锁定表只能进行读或读和写操作。不允许操作其他表。（处理并发的常用方式）</strong></p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">lock tables t1 read, t2 write;</span><br></pre></td></tr></tbody></table></figure>

<p>​</p>
<p>只能对 t1 表进行读，t2 表进行读和写。直到执行<strong>unlock tables</strong>之前不允许对其他表进行读写操作。<br>​</p>
<p>​</p>
<ol start="3">
<li>MDL ( meatadata lock)</li>
</ol>
<p>​</p>
<p>作用：保证读写的正确性。防止 DDL(加字段等修改表结构的操作)和 DML 冲突（增删改数据）<br>特点： 自动加上，不需要使用 sql 语句。在对表进行数据的增删改查操作时加读锁。修改表结构时，加写锁。<br>​</p>
<p>​</p>
<p>读读锁共存、读写锁、写写锁互斥。<br>​</p>
<p><strong>示例</strong><br><strong>​</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634388295266-c5897d57-05ac-4ac9-b910-e2d9950d6f1e.png#clientId=ubaf7a982-8eca-4&amp;from=paste&amp;height=261&amp;id=u0e8aeaeb&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=521&amp;originWidth=834&amp;originalType=binary&amp;ratio=1&amp;size=78640&amp;status=done&amp;style=none&amp;taskId=u2b78eb8a-f57d-433e-935f-d586ac65ede&amp;width=417" alt="image.png"></p>
<p>在多个事务开启且未结束的过程中给某个表添加个字段导致读写锁冲突。<br>​</p>
<p>解决方法<br>在 information_schema 库中 innodb_trx 表中查询出正在执行事务，可以暂停表变更事务、或者是长事务。<br>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><ol>
<li>全局锁主要是用来逻辑备份，有两种方式一种是通过命令 flush tables with read lock;。另一种需要支持库中所有的表支持可重复读事务，使用 mysqldump -single-transaction 进行备份。</li>
</ol>
<p>​</p>
<ol start="2">
<li>表锁通过 sql 语句限制指定表只能进行读、读/写操作,且不允许对其他表操作在解锁前。</li>
</ol>
<p>​</p>
<ol start="3">
<li>MDL 是自动加上的，不需要通过 sql 语句。存在读写锁、写写锁互斥情况。锁在事务提交后释放。作用是为了防止 DDL 和 DML 操作冲突。</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-索引</title>
    <url>/2022/09/09/4!%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<html><head></head><body><h2 id="1-索引常见模型"><a href="#1-索引常见模型" class="headerlink" title="1.索引常见模型"></a>1.索引常见模型</h2><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631014492663-2fed2cf8-9707-4346-bf90-06ff2a5b0d4e.png#clientId=uf02e59f4-5d80-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=286&amp;id=u7fa963ac&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=572&amp;originWidth=848&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=173484&amp;status=done&amp;style=none&amp;taskId=u6e8f087d-7794-4326-8ff8-d1cb74fcb50&amp;title=&amp;width=424" alt="image.png"></p>
<p>通过 hash 算法将 key 换算成确定的位置，然后把 value 放入到这个数组的位置。如果数组已经存在值，<br>则通过拉链法，拉出一条链表。<br>​</p>
<p>​</p>
<p>优点：等值查询的情况下查询效率高<br>缺点：范围查询效率低下<br>​</p>
<h3 id="2-有序数组"><a href="#2-有序数组" class="headerlink" title="2. 有序数组"></a>2. 有序数组</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631014718687-07087e14-d4f9-4401-9bbd-bb4dd3a0bce5.png#clientId=uf02e59f4-5d80-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=219&amp;id=u6b2951af&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=437&amp;originWidth=898&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=108398&amp;status=done&amp;style=none&amp;taskId=uf49d5f91-1a3a-48ac-aca3-80d6aec3ace&amp;title=&amp;width=449" alt="image.png"><br>​</p>
<p>​</p>
<p>​</p>
<p>优点：等值和范围查询效率高<br>缺点：插入、删除数据效率低下<br>​</p>
<p>​</p>
<p>场景：只适用于静态存储引擎<br>​</p>
<p>​</p>
<h3 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3. 二叉搜索树"></a>3. 二叉搜索树</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631014893629-805c3a90-3ccf-4fff-98f4-51ec1671c6df.png#clientId=uf02e59f4-5d80-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=306&amp;id=u38010e60&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=612&amp;originWidth=865&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=178178&amp;status=done&amp;style=none&amp;taskId=u5614456c-9189-45ca-bfb2-5fbf49f84fc&amp;title=&amp;width=432.5" alt="image.png"></p>
<p>缺点：数据量大的情况下，导致树很高，需要进行多次磁盘读取数据，比较浪费时间。<br>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="2-InnoDB-索引模型"><a href="#2-InnoDB-索引模型" class="headerlink" title="2. InnoDB 索引模型"></a>2. InnoDB 索引模型</h2><p>B+树<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631015176574-c34b7b27-c5cc-4295-8de1-bdb466fe3700.png#clientId=uf02e59f4-5d80-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=226&amp;id=ud6c87e87&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=451&amp;originWidth=847&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=121005&amp;status=done&amp;style=none&amp;taskId=ue3c7c791-9710-400e-b106-8559a26769a&amp;title=&amp;width=423.5" alt="image.png"></p>
<h2 id="3-主键索引和非主键索引"><a href="#3-主键索引和非主键索引" class="headerlink" title="3. 主键索引和非主键索引"></a>3. 主键索引和非主键索引</h2><p><strong>InnoDB 里面主键索引也被称为聚簇索引</strong><br>​</p>
<p>非主键索引的叶子节点存储的是主键的值<br>​</p>
<p>主键索引和非主键索引的区别</p>
<ol>
<li>主键查询： 只需要查询主键索引的 B+树,查询出对应的数据</li>
<li>非主键索引：查询非主键索引的树，获得对应的主键值，然后通过主键值查询主键索引的 B+树</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="4-索引维护"><a href="#4-索引维护" class="headerlink" title="4. 索引维护"></a>4. 索引维护</h2><p>​</p>
<p>概念： 当数据页中数据存储满了，会生成一个新的数据页，然后原有数据也中的部分数据会移到新的数据也中。这种过程叫做页分裂。<br>​</p>
<p>同理页合并是两个数据页中的数据太少了，合并到一个数据页中。</p>
<p>​</p>
<p>​</p>
<h2 id="5-索引覆盖"><a href="#5-索引覆盖" class="headerlink" title="5. 索引覆盖"></a>5. 索引覆盖</h2><h3 id="1-回表"><a href="#1-回表" class="headerlink" title="1. 回表"></a>1. 回表</h3><p>select * from T where k between 3 and 5<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631016152383-0a030960-b98c-4af0-8eb5-c3e571988bc0.png#clientId=uf02e59f4-5d80-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=203&amp;id=QPjkB&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=406&amp;originWidth=847&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=119807&amp;status=done&amp;style=none&amp;taskId=uc4420736-4496-455c-a039-deaab42dce4&amp;title=&amp;width=423.5" alt="image.png"><br>执行流程</p>
<ol>
<li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li>
<li>再到 ID 索引树查到 ID=300 对应的 R3；</li>
<li>在 k 索引树取下一个值 k=5，取得 ID=500；</li>
<li>再回到 ID 索引树查到 ID=500 对应的 R4；</li>
<li>在 k 索引树取下一个值 k=6，不满足条件，循环结束</li>
</ol>
<p>​</p>
<p>​</p>
<p><strong>回表：非主键搜索完后，回到主键索引树进行搜索的过程</strong>。（步骤 2、4）<br>​</p>
<p>​</p>
<p>​</p>
<h3 id="2-索引覆盖"><a href="#2-索引覆盖" class="headerlink" title="2. 索引覆盖"></a>2. 索引覆盖</h3><p>select ID from T where k between 3 and 5<br>​</p>
<p>​</p>
<p>对于上述通过非主键索引查询主键索引信息，由于非主键索引存放了主键的信息。<br>导致我们不需要进行回表。<strong>由于索引 k 的值覆盖了查询的字段，我们称之为覆盖索引</strong><br><strong>​</strong></p>
<p><strong>​</strong></p>
<p><strong>优点：减少树的搜索次数，提升查询效率</strong><br>​</p>
<p>​</p>
<h2 id="6-最左前缀原则"><a href="#6-最左前缀原则" class="headerlink" title="6. 最左前缀原则"></a>6. 最左前缀原则</h2><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">CREATE TABLE `tuser` (</span><br><span class="line">  `id` int(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `id_card` varchar(<span class="number">32</span>) DEFAULT NULL,</span><br><span class="line">  `name` varchar(<span class="number">32</span>) DEFAULT NULL,</span><br><span class="line">  `age` int(<span class="number">11</span>) DEFAULT NULL,</span><br><span class="line">  `ismale` tinyint(<span class="number">1</span>) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `id_card` (`id_card`),</span><br><span class="line">  KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631016490840-0e048d5d-77e7-4191-83e7-026d3c1e3e6e.png#clientId=uf02e59f4-5d80-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=243&amp;id=u0182df12&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=486&amp;originWidth=916&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=185361&amp;status=done&amp;style=none&amp;taskId=ubb2ba15c-29fb-469e-bca4-35d9ccce47c&amp;title=&amp;width=458" alt="image.png"></p>
<p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。<br><strong>​</strong></p>
<p><strong>联合索引以第一个索引为基准进行排序，然后通过第一个索引的值来进行查询</strong><br><a href="https://www.cnblogs.com/ljl150/p/12934071.html">最左前缀原则</a><br><strong>​</strong></p>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<h2 id="7-索引下推"><a href="#7-索引下推" class="headerlink" title="7. 索引下推"></a>7. 索引下推</h2><p>Mysql5.6 引入索引下推，是在最左前缀的条件小，过滤调不不符合条件的记录减少回表的次数<br>​</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select * from tuser where name like '张 %' and age=<span class="number">10</span> and ismale=<span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631018210889-220345e3-dae5-4eb8-9170-5537631d52ef.png#clientId=uf02e59f4-5d80-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=194&amp;id=u671fa958&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=388&amp;originWidth=859&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=183225&amp;status=done&amp;style=none&amp;taskId=u26fcfa9c-8351-4a80-bb20-4dd098a028b&amp;title=&amp;width=429.5" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631018215910-da87dcc1-a41f-46ae-b73b-cecf9db4cf0f.png#clientId=uf02e59f4-5d80-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=198&amp;id=ue03b52df&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=395&amp;originWidth=869&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=189030&amp;status=done&amp;style=none&amp;taskId=u0df9d68d-5a7b-4383-babc-d022de12965&amp;title=&amp;width=434.5" alt="image.png"></p>
<h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h2><ol>
<li>索引的常见模型<ol>
<li>哈希表 （不支持范围查询）</li>
<li>有序数组（插入删除效率低）</li>
<li>二叉搜索树（数据量大，导致树的高度很高，需要进行多次磁盘读取）</li>
</ol>
</li>
<li>InnoDB 索引模型<ol>
<li>B+树支持范围查询，树的高度不会太高</li>
<li>查找数据消耗磁盘读取的时间相同</li>
</ol>
</li>
<li>主键索引和非主键索引<ol>
<li>在 InnoDB 主键索引存储索引行对应的数据</li>
<li>非主键索引存储的是主键索引的值，需要通过回表的方式，去查询一遍主键索引</li>
</ol>
</li>
<li>索引覆盖：通过非主键索引查询主键索引的值，导致不需要回到主键索引树再次进行查询的过程。</li>
<li>最左前缀原则</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-行锁</title>
    <url>/2022/09/11/6!%E8%A1%8C%E9%94%81/</url>
    <content><![CDATA[<html><head></head><body><p>​</p>
<h2 id="1-两阶段锁"><a href="#1-两阶段锁" class="headerlink" title="1. 两阶段锁"></a>1. 两阶段锁</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634436939942-730ba0be-6f13-45fd-9e43-01d1e21cdcae.png#clientId=u3b414356-8e51-4&amp;from=paste&amp;height=284&amp;id=tMiKr&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=568&amp;originWidth=857&amp;originalType=binary&amp;ratio=1&amp;size=76026&amp;status=done&amp;style=none&amp;taskId=u92c3677b-e488-453e-8a85-2b6bec9261e&amp;width=428.5" alt="image.png"><br>**下面的操作序列中，如果为两行数据加了行锁事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。</p>
<p><strong>​</strong></p>
<p>在 InnoDB 中，行锁是在需要的时候加上，在<strong>事务结束时释放。（</strong>最有可能造成锁冲突的行的读锁尽量往后放<strong>）</strong><br><strong>​</strong></p>
<p>示例：<br>顾客 A 在影院 B 买电影票<br>操作如下</p>
<ol>
<li>从顾客 A 账户余额中扣除电影票价；</li>
<li>给影院 B 的账户余额增加这张电影票价；</li>
<li>记录一条交易日志。</li>
</ol>
<p>​</p>
<p>其中多个顾客买票可能造成 B 的账户行数据冲突。因此将 B 的操作放在最后。最大程度减少了事务之间的锁等待。<br>​</p>
<p>​</p>
<h2 id="2-死锁和死锁检测"><a href="#2-死锁和死锁检测" class="headerlink" title="2. 死锁和死锁检测"></a>2. 死锁和死锁检测</h2><p>示例：当行锁同时锁住 id=1 和 2 的两行数据<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634437587628-d3672f2b-b62b-4ced-ac7b-dcc6de65eb02.png#clientId=u3b414356-8e51-4&amp;from=paste&amp;height=281&amp;id=uf1f2e0cc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=561&amp;originWidth=871&amp;originalType=binary&amp;ratio=1&amp;size=90990&amp;status=done&amp;style=none&amp;taskId=ub90e33fe-f5b8-4aab-ad45-1cf1dd6750d&amp;width=435.5" alt="image.png"><br>在这种情况下事务 A 等待 id=2 的行锁，事务 B 等待 id=1 的行锁。事务 A 和事务 B 互相都在等待对方无法释放的资源，从而进入了死锁。<br>​</p>
<p>​</p>
<p>解决方法</p>
<ul>
<li>设置获取锁等待时间：设置获取锁超时时间，如果超时则锁住的线程自动退出。通过 innodb_lock_wait_timeout 来设置等待时间默认为 50s</li>
<li>发起死锁检测：发现死锁后主动回滚争抢锁的某一个事务。让其他事务继续执行。通过 innodb_deadlock_detect 设置为 on 表示开启逻辑。</li>
</ul>
<p>死锁检测的缺点：</p>
<ol>
<li>确保业务不会出现死锁，关闭死锁检测</li>
<li>控制并发度</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><ol>
<li>读锁的两阶段协议：需要的时候加上、事务结束的时候释放。尽可能将影响并发度最大的锁往后放。减少其他锁的等待时间</li>
<li>死锁的形成，事务之间争抢不释放的锁资源。导致一直处于等待状态</li>
<li>死锁的解决方法：1. 设置锁等待时间 2. 开启死锁检测</li>
</ol>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<ul>
<li>第一种，直接执行 delete from T limit 10000;</li>
<li>第二种，在一个连接中循环执行 20 次 delete from T limit 500;</li>
<li>第三种，在 20 个连接中同时执行 delete from T limit 500。</li>
</ul>
<p>你会选择哪一种方法呢？为什么呢？<br>第二种，第三种容易造成死锁。第一种锁的范围太大导致获取锁的时间长。</p>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Buttterfly美化教程集合</title>
    <url>/2021/12/20/Buttterfly%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<html><head></head><body><h1 id="1-设置背景渐变效果"><a href="#1-设置背景渐变效果" class="headerlink" title="1. 设置背景渐变效果"></a>1. 设置背景渐变效果</h1><h2 id="1-效果图"><a href="#1-效果图" class="headerlink" title="1.效果图"></a>1.效果图</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1640016968691-40cf8542-0c0d-476f-a342-ef7803df0029.png#clientId=u69b8f327-ff26-4&amp;from=paste&amp;height=167&amp;id=ua08fe870&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=334&amp;originWidth=1134&amp;originalType=binary&amp;ratio=1&amp;size=156444&amp;status=done&amp;style=none&amp;taskId=u6648ddf4-3cf6-4796-94e8-d4a74dfc23b&amp;width=567" alt="image.png"></p>
<h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2.步骤"></a>2.步骤</h2><ol>
<li>在博客根目录下的<code>themes\butterfly\source\css</code>创建一个 css 后缀文件</li>
<li>在新建的后缀文件中添加如下配置。 由于每个人用的 butterfly 版本不同，所以修改的不一定是#body-wrap。具体需要通过在页面上使用<code>F12</code>，查看标签对应的 id。<img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1640017441534-b130e721-df0c-4ca7-b538-913c9c50d77f.png#clientId=u69b8f327-ff26-4&amp;from=paste&amp;id=u3e0effb6&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=27&amp;originWidth=419&amp;originalType=binary&amp;ratio=1&amp;size=3831&amp;status=done&amp;style=none&amp;taskId=u8e1396fd-4db0-4b4e-beb8-da4f152e19a" alt="image.png"></li>
</ol>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 修改文章页背景及透明度 */</span></span><br><span class="line"><span class="selector-id">#body-wrap</span> {</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(</span><br><span class="line">    <span class="number">0deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">247</span>, <span class="number">149</span>, <span class="number">51</span>, <span class="number">0.1</span>) <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">243</span>, <span class="number">112</span>, <span class="number">85</span>, <span class="number">0.1</span>) <span class="number">15%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">239</span>, <span class="number">78</span>, <span class="number">123</span>, <span class="number">0.1</span>) <span class="number">30%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">161</span>, <span class="number">102</span>, <span class="number">171</span>, <span class="number">0.1</span>) <span class="number">44%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">80</span>, <span class="number">115</span>, <span class="number">184</span>, <span class="number">0.1</span>) <span class="number">58%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">16</span>, <span class="number">152</span>, <span class="number">173</span>, <span class="number">0.1</span>) <span class="number">72%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">7</span>, <span class="number">179</span>, <span class="number">155</span>, <span class="number">0.1</span>) <span class="number">86%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">109</span>, <span class="number">186</span>, <span class="number">130</span>, <span class="number">0.1</span>) <span class="number">100%</span></span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(</span><br><span class="line">    <span class="number">0deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">247</span>, <span class="number">149</span>, <span class="number">51</span>, <span class="number">0.1</span>) <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">243</span>, <span class="number">112</span>, <span class="number">85</span>, <span class="number">0.1</span>) <span class="number">15%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">239</span>, <span class="number">78</span>, <span class="number">123</span>, <span class="number">0.1</span>) <span class="number">30%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">161</span>, <span class="number">102</span>, <span class="number">171</span>, <span class="number">0.1</span>) <span class="number">44%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">80</span>, <span class="number">115</span>, <span class="number">184</span>, <span class="number">0.1</span>) <span class="number">58%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">16</span>, <span class="number">152</span>, <span class="number">173</span>, <span class="number">0.1</span>) <span class="number">72%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">7</span>, <span class="number">179</span>, <span class="number">155</span>, <span class="number">0.1</span>) <span class="number">86%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">109</span>, <span class="number">186</span>, <span class="number">130</span>, <span class="number">0.1</span>) <span class="number">100%</span></span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(</span><br><span class="line">    <span class="number">0deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">247</span>, <span class="number">149</span>, <span class="number">51</span>, <span class="number">0.1</span>) <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">243</span>, <span class="number">112</span>, <span class="number">85</span>, <span class="number">0.1</span>) <span class="number">15%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">239</span>, <span class="number">78</span>, <span class="number">123</span>, <span class="number">0.1</span>) <span class="number">30%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">161</span>, <span class="number">102</span>, <span class="number">171</span>, <span class="number">0.1</span>) <span class="number">44%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">80</span>, <span class="number">115</span>, <span class="number">184</span>, <span class="number">0.1</span>) <span class="number">58%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">16</span>, <span class="number">152</span>, <span class="number">173</span>, <span class="number">0.1</span>) <span class="number">72%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">7</span>, <span class="number">179</span>, <span class="number">155</span>, <span class="number">0.1</span>) <span class="number">86%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">109</span>, <span class="number">186</span>, <span class="number">130</span>, <span class="number">0.1</span>) <span class="number">100%</span></span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-ms-linear-gradient</span>(</span><br><span class="line">    <span class="number">0deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">247</span>, <span class="number">149</span>, <span class="number">51</span>, <span class="number">0.1</span>) <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">243</span>, <span class="number">112</span>, <span class="number">85</span>, <span class="number">0.1</span>) <span class="number">15%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">239</span>, <span class="number">78</span>, <span class="number">123</span>, <span class="number">0.1</span>) <span class="number">30%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">161</span>, <span class="number">102</span>, <span class="number">171</span>, <span class="number">0.1</span>) <span class="number">44%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">80</span>, <span class="number">115</span>, <span class="number">184</span>, <span class="number">0.1</span>) <span class="number">58%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">16</span>, <span class="number">152</span>, <span class="number">173</span>, <span class="number">0.1</span>) <span class="number">72%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">7</span>, <span class="number">179</span>, <span class="number">155</span>, <span class="number">0.1</span>) <span class="number">86%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">109</span>, <span class="number">186</span>, <span class="number">130</span>, <span class="number">0.1</span>) <span class="number">100%</span></span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(</span><br><span class="line">    <span class="number">90deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">247</span>, <span class="number">149</span>, <span class="number">51</span>, <span class="number">0.1</span>) <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">243</span>, <span class="number">112</span>, <span class="number">85</span>, <span class="number">0.1</span>) <span class="number">15%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">239</span>, <span class="number">78</span>, <span class="number">123</span>, <span class="number">0.1</span>) <span class="number">30%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">161</span>, <span class="number">102</span>, <span class="number">171</span>, <span class="number">0.1</span>) <span class="number">44%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">80</span>, <span class="number">115</span>, <span class="number">184</span>, <span class="number">0.1</span>) <span class="number">58%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">16</span>, <span class="number">152</span>, <span class="number">173</span>, <span class="number">0.1</span>) <span class="number">72%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">7</span>, <span class="number">179</span>, <span class="number">155</span>, <span class="number">0.1</span>) <span class="number">86%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">109</span>, <span class="number">186</span>, <span class="number">130</span>, <span class="number">0.1</span>) <span class="number">100%</span></span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="2-页脚渐变透明"><a href="#2-页脚渐变透明" class="headerlink" title="2. 页脚渐变透明"></a>2. 页脚渐变透明</h1><h2 id="1-效果图-1"><a href="#1-效果图-1" class="headerlink" title="1. 效果图"></a>1. 效果图</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1640017580407-35c4e83d-2e35-4bb0-b987-02d04521b0db.png#clientId=u69b8f327-ff26-4&amp;from=paste&amp;height=106&amp;id=uc27f3f41&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=211&amp;originWidth=1752&amp;originalType=binary&amp;ratio=1&amp;size=33379&amp;status=done&amp;style=none&amp;taskId=ubaba17b1-ed4e-429d-93fd-31a2418926b&amp;width=876" alt="image.png"></p>
<h2 id="2-步骤-1"><a href="#2-步骤-1" class="headerlink" title="2. 步骤"></a>2. 步骤</h2><ol>
<li>在博客根目录下的<code>themes\butterfly\source\css</code>创建一个 css 后缀文件</li>
<li>在新建的后缀文件中添加如下配置</li>
</ol>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 页脚透明渐变 */</span></span><br><span class="line"><span class="selector-id">#footer</span> {</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.15</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-top-right-radius</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-top-left-radius</span>: <span class="number">20px</span>;</span><br><span class="line">  backdrop-<span class="attribute">filter</span>: <span class="built_in">saturate</span>(<span class="number">100%</span>) <span class="built_in">blur</span>(<span class="number">5px</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#footer</span><span class="selector-pseudo">::before</span> {</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.15</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#footer</span> <span class="selector-id">#footer-wrap</span> {</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--font-color);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#footer</span> <span class="selector-id">#footer-wrap</span> <span class="selector-tag">a</span> {</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--font-color);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="3-页脚徽标设置"><a href="#3-页脚徽标设置" class="headerlink" title="3. 页脚徽标设置"></a>3. 页脚徽标设置</h1><h2 id="1-效果图-2"><a href="#1-效果图-2" class="headerlink" title="1. 效果图"></a>1. 效果图</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1640017751461-338d3075-c47d-4fc5-9e9b-e6d863333636.png#clientId=u69b8f327-ff26-4&amp;from=paste&amp;height=30&amp;id=u8575727c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=59&amp;originWidth=878&amp;originalType=binary&amp;ratio=1&amp;size=10582&amp;status=done&amp;style=none&amp;taskId=uefa87f9e-ab64-4c2c-b25f-6ead943b2af&amp;width=439" alt="image.png"></p>
<h2 id="2-步骤-2"><a href="#2-步骤-2" class="headerlink" title="2.步骤"></a>2.步骤</h2><p>在_cofing.yml 中添加如下配置</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">&lt;p&gt;&lt;a</span> <span class="string">style="margin-inline:5px"target="_blank"</span> <span class="string">href="https://hexo.io/"&gt;&lt;img</span> <span class="string">src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo"</span> <span class="string">title="博客框架为</span> <span class="string">Hexo"</span> <span class="string">alt="HEXO"&gt;&lt;/a&gt;&lt;a</span> <span class="string">style="margin-inline:5px"target="_blank"</span> <span class="string">href="https://butterfly.js.org/"&gt;&lt;img</span> <span class="string">src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender"</span> <span class="string">title="主题采用</span> <span class="string">Butterfly"</span> <span class="string">alt="Butterfly"&gt;&lt;/a&gt;&lt;a</span> <span class="string">style="margin-inline:5px"target="_blank"</span> <span class="string">href="https://www.jsdelivr.com/"&gt;&lt;img</span> <span class="string">src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr"</span> <span class="string">title="本站使用</span> <span class="string">Jsdelivr</span> <span class="string">为静态资源提供CDN加速"</span> <span class="string">alt="Jsdelivr"&gt;&lt;/a&gt;&lt;a</span> <span class="string">style="margin-inline:5px"target="_blank"</span> <span class="string">href="https://github.com/"&gt;&lt;img</span> <span class="string">src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub"</span> <span class="string">title="本站项目由</span> <span class="string">GitHub</span> <span class="string">托管"</span> <span class="string">alt="GitHub"&gt;&lt;/a&gt;&lt;a</span> <span class="string">style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;&lt;img</span> <span class="string">src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris"</span> <span class="string">alt="img"</span> <span class="string">title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"&gt;&lt;/a&gt;&lt;/p&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="4-图片懒加载"><a href="#4-图片懒加载" class="headerlink" title="4. 图片懒加载"></a>4. 图片懒加载</h1><h2 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1. 步骤"></a>1. 步骤</h2><ol>
<li>安装懒加载插件</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>在配置文件对应主题.yml 中添加配置</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">lazyload:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  onlypost: <span class="literal">false</span>  <span class="comment"># 是否只对文章的图片做懒加载</span></span><br><span class="line">  loadingImg: <span class="comment"># eg ./images/loading.gif</span></span><br></pre></td></tr></tbody></table></figure>

<p>[</p>
<p>](<a href="http://img.wuxin.website/img/b3f6b2565c3149a2a8df94ab43cf3a3b.jpg">http://img.wuxin.website/img/b3f6b2565c3149a2a8df94ab43cf3a3b.jpg</a>)</p>
</body></html>]]></content>
      <categories>
        <category>Butterfly</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-11-盛水最多的容器</title>
    <url>/2021/07/23/LeetCode-11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<html><head></head><body><p>​</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://img-blog.csdnimg.cn/0344e196bab241ed866b13e6c08896fb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70#id=pQeNT&amp;originHeight=689&amp;originWidth=827&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"><br><a href="https://leetcode-cn.com/problems/container-with-most-water/">题目链接</a></p>
<h1 id="一、解题思路"><a href="#一、解题思路" class="headerlink" title="一、解题思路"></a>一、解题思路</h1><p>这题其实就是要求那两个点的面积最大。有两种解题思路。</p>
<h2 id="1-暴力破解"><a href="#1-暴力破解" class="headerlink" title="1. 暴力破解"></a>1. 暴力破解</h2><p>通过两层循环遍历任意两点的所有组合情况，然后求出两点的面积值，然后取最大值。<br>这种方法是最容易想到的。但是当我们使用这种方法提交上去时，会出现超时错误。不要问我为什么！！！懂得都懂。所以我们要通过一种要想出一种时间复杂度更低的方法。</p>
<h2 id="2-双指针法"><a href="#2-双指针法" class="headerlink" title="2.双指针法"></a>2.双指针法</h2><p>首先双层循环时肯定不行的，所以我们就来试试单层循环。单层循环我们要获取最大的面积我们首先要确定如何遍历。这点很关键!!!我们不能再向之前双层循环从头遍历到尾。单层循环我们需要通过从两头开始遍历。那这就产生了一种限制。我们每次往中间移的话长度都是再变小！！！然后我们又不希望要获取面积的慢慢随着长度的变小而变小，所以我们需要让我们的高度变高。而高度是由较小的高度来决定，所以我们要让高度变大，只需要让高度较小的一番往中间移。当两条线重合或者超过的时候就遍历完了。</p>
<h1 id="二、方法代码"><a href="#二、方法代码" class="headerlink" title="二、方法代码"></a>二、方法代码</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//暴力破解</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++) {</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) {</span><br><span class="line">        <span class="keyword">int</span> largeHeight = height[i] &gt; height[j] ? height[j] : height[i];</span><br><span class="line">        <span class="keyword">int</span> area = largeHeight * (j - i);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">if</span> (area &gt; maxArea) {</span><br><span class="line">          maxArea = area;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="comment">///双指针法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; j; ) {</span><br><span class="line">      <span class="keyword">int</span> area;</span><br><span class="line">      <span class="keyword">if</span> (height[i] &lt;= height[j]) {</span><br><span class="line">        area = height[i] * (j - i);</span><br><span class="line">        i++;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        area = height[j] * (j - i);</span><br><span class="line">        j--;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (maxArea &lt; area) {</span><br><span class="line">        maxArea = area;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这题的暴力破解法其实很多人应该都可以想得到，比较难想到得是第二种，这里很巧妙的利用随着直线不断往中间靠拢，长度在不断的减小，而我们不想让面积随着长度得较小而较小，所以就需要高度不断增加，所以我们每次都要移动长度较小的一方，已达到长度得增加，从而可能产生面积得增长。</p>
</body></html>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-求二叉树的最大深度</title>
    <url>/2021/01/04/LeetCode-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<html><head></head><body><h1 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h1><p><img src="https://img-blog.csdnimg.cn/20210117094814654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70#id=VYwer&amp;originHeight=520&amp;originWidth=740&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"><br><strong>题目链接：</strong><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></p>
<h1 id="一、解题思路"><a href="#一、解题思路" class="headerlink" title="一、解题思路"></a>一、解题思路</h1><p>通过递归的方式，不断遍历其树的每一个节点。然后判断当前节点是否为空，不为空高度加 1,同时遍历当前节点的子节点，然后比较左右两节点的高度，返回最大的节点高度。反之则直接返回上一节点的高度。</p>
<h1 id="二、解题步骤"><a href="#二、解题步骤" class="headerlink" title="二、解题步骤"></a>二、解题步骤</h1><h2 id="1-详细步骤"><a href="#1-详细步骤" class="headerlink" title="1.详细步骤"></a>1.详细步骤</h2><ol>
<li>判断当前节点是否为空<ul>
<li>如果为空，直接返回上一节点的高度</li>
<li>反之高度加 1 ，并执行下一步</li>
</ul>
</li>
<li>继续递归调用该函数，将其节点设置为当前节点，同时高度设置为当前节点的高度。并设置变量用于获取函数的返回值。</li>
<li>比较左右两个节点函数返回值，取其最大值。</li>
</ol>
<h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h2><p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> maxHeight(root,<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxHeight</span><span class="params">(TreeNode root,<span class="keyword">int</span> height)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>){</span><br><span class="line">            height++;</span><br><span class="line">            <span class="keyword">int</span> leftHeight=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> rightHeight=<span class="number">0</span>;</span><br><span class="line">            leftHeight=maxHeight(root.left,height);</span><br><span class="line">            rightHeight=maxHeight(root.right,height);</span><br><span class="line">            <span class="keyword">return</span> leftHeight&gt;rightHeight?leftHeight:rightHeight;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> height;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>这里面主要用到了递归的思想。递归在与树有关的很多的题目都可以使用该思想。通过该思想可以很大程度上简化代码。但是也不是没有缺点，如果递归次数过多的话，可能会造成堆栈溢出。</p>
</body></html>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之合并二叉树</title>
    <url>/2020/12/19/LeetCode%E4%B9%8B%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<html><head></head><body><p>​</p>
<p>​</p>
<p>​</p>
<h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p><img src="https://img-blog.csdnimg.cn/20201219005707214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70#id=ZaF2E&amp;originHeight=739&amp;originWidth=698&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"></p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>采用递归和后序遍历的方式来同时遍历两棵树。遍历的同时，一定要判断两颗树的当前节点是否为空。然后创建一个新的节点，节点值为两个节点之和。遍历完成后即可得到合并后的树。</p>
<h2 id="3-解题步骤"><a href="#3-解题步骤" class="headerlink" title="3. 解题步骤"></a>3. 解题步骤</h2><ol>
<li> 判断当前两颗树的节点全为空，如果为空则返回空。</li>
<li> 反之有以下三种</li>
</ol>
<ul>
<li>可能两个节点都不为空</li>
<li>左节点为空，右节点不为空</li>
<li>右节点为空，左节点不为空</li>
</ul>
<ol start="3">
<li> 采取以下措施</li>
</ol>
<ul>
<li>当为第一种情况时 ,创建一个新的节点，节点值为左右节点值的和,之后遍历左右节点</li>
<li>当为第二种情况时 ,创建一个新的节点，节点值为右节点值,之后遍历右节点.</li>
<li>当为第三种情况时 ,创建一个新的节点，节点值为左节点值,之后遍历左节点。</li>
</ul>
<ol start="4">
<li> 返回创建的新的节点。</li>
</ol>
<h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">null</span>&amp;&amp;t2==<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            TreeNode t3;</span><br><span class="line">            <span class="keyword">if</span>(t1!=<span class="keyword">null</span>&amp;&amp;t2!=<span class="keyword">null</span>){</span><br><span class="line">                t3=<span class="keyword">new</span> TreeNode(t1.val+t2.val);</span><br><span class="line">                t3.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">                t3.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(t1!=<span class="keyword">null</span>){</span><br><span class="line">                t3=<span class="keyword">new</span> TreeNode(t1.val);</span><br><span class="line">                t3.right=mergeTrees(t1.right,<span class="keyword">null</span>);</span><br><span class="line">                t3.left=mergeTrees(t1.left,<span class="keyword">null</span>);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                t3=<span class="keyword">new</span> TreeNode(t2.val);</span><br><span class="line">                t3.right=mergeTrees(<span class="keyword">null</span>,t2.right);</span><br><span class="line">                t3.left=mergeTrees(<span class="keyword">null</span>,t2.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> t3;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>以目前我做的与树相关的题目来说。所需要做的事基本上就是一件事：<strong>遍历</strong>。而树的遍历一般可以通过递归的方式来进行一些简单的遍历。遍历一般分为三种：前序遍历、中序遍历、后序遍历。前序、中序、后序的名字是按照遍历中父节点，相对于左右子节点中的顺序。如果父节点，在其子父节点中最后一个遍历，称之为后序遍历。其他的遍历顺序可由以上类推。<br>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
</body></html>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-汉明距离</title>
    <url>/2021/01/16/LeetCode-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<html><head></head><body><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/eb8bf20167f1cc2d7f1d9c054ec9d21b.png#id=rp6JQ&amp;originHeight=609&amp;originWidth=745&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"></p>
<h1 id="一、解题思路"><a href="#一、解题思路" class="headerlink" title="一、解题思路"></a>一、解题思路</h1><p>这里有两种解题思路</p>
<h2 id="1-位运算法"><a href="#1-位运算法" class="headerlink" title="1. 位运算法"></a>1. 位运算法</h2><p><strong>位运算</strong>如果你不了解的话，可以看下第二种解题思路。但是整体代码有点冗余，而且效率也不高。<br><code>^</code>的运算规则二进制位中各个位上数就是相同为 0，不同为 1。<br><code>&amp;</code>的运算规则是都为 1 时结果为 1，反之全为 0。<br><code>|</code>的运算规则是只要有 1 结果为 1，反之为 0。<br><code>&gt;&gt;</code>当前数二级制向右移一位，同时最高位根据数的正负来补 0 或 1<br><code>&lt;&lt;</code> 当前数二进制向左移一位，同时最低位补 0。</p>
<p><strong>位运算法</strong></p>
<ol>
<li> 将两个数<code>^</code>运算</li>
<li>判断运算结果中 1 的个数。即为两个数二进制中各个位的值不同的个数<br> 这里有两种计算 1 个数的方法<br> 2.1.1 &nbsp; 将运算结果按 2 求余，如果为 1 就个数加 1。反之就忽略<br> 2.1.2 将运算结果右移一位。并重复上述步骤 32 次。<br> 2.2.1 将运算结果和运算结果-1 进行<code>&amp;</code>运算，然后将值返回作为新的运算结果。1 的个数加 1。<br> 2.2.2 直到运算结果为 0 时跳出循环</li>
</ol>
<h2 id="2-暴力破解法"><a href="#2-暴力破解法" class="headerlink" title="2. 暴力破解法"></a>2. 暴力破解法</h2><ol>
<li>将上述两个数将其二进制位分别放入到不同的 List 容器中</li>
<li>判断两个容器的长度，将长度较大的容器作为遍历次数</li>
<li>获取两个容器中当前索引的值，并判断是否相等，如果不等距离加 1</li>
<li>如果较小容器遍历完了的话，就判断较大容器中的值是否等于 0。如果不等距离加 1</li>
<li>最后得到的距离即为结果</li>
</ol>
<h1 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h1><h2 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1.位运算"></a>1.位运算</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">     <span class="keyword">int</span> res=x^y;</span><br><span class="line">     <span class="keyword">int</span> times=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(res!=<span class="number">0</span>){</span><br><span class="line">       res=res&amp;(res-<span class="number">1</span>);</span><br><span class="line">       times++;</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> times;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-暴力破解"><a href="#2-暴力破解" class="headerlink" title="2.暴力破解"></a>2.暴力破解</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">       ArrayList&lt;Integer&gt; xArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">do</span>{</span><br><span class="line">       xArray.add(x%<span class="number">2</span>);</span><br><span class="line">       x=x/<span class="number">2</span>;</span><br><span class="line">     }<span class="keyword">while</span>(x!=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Integer&gt; yArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">do</span>{</span><br><span class="line">       yArray.add(y%<span class="number">2</span>);</span><br><span class="line">       y=y/<span class="number">2</span>;</span><br><span class="line">     }<span class="keyword">while</span>(y!=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> distance=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">//当y的二进制更长时</span></span><br><span class="line">       <span class="keyword">if</span>(yArray.size()&gt;=xArray.size()){</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;yArray.size();j++){</span><br><span class="line">                <span class="keyword">if</span>(j&lt;xArray.size()){</span><br><span class="line">                   <span class="keyword">if</span>(yArray.get(j)!=xArray.get(j)){</span><br><span class="line">                       distance++;</span><br><span class="line">                   }</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="keyword">if</span>(yArray.get(j)!=<span class="number">0</span>){</span><br><span class="line">                        distance++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">       }<span class="keyword">else</span>{<span class="comment">//x的二进制更长</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;xArray.size();j++){</span><br><span class="line">               <span class="keyword">if</span>(j&lt;yArray.size()){</span><br><span class="line">                   <span class="keyword">if</span>(yArray.get(j)!=xArray.get(j)){</span><br><span class="line">                       distance++;</span><br><span class="line">                   }</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    <span class="keyword">if</span>(xArray.get(j)!=<span class="number">0</span>){</span><br><span class="line">                        distance++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> distance;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我一开始使用的暴力破解法。但觉得暴力破解法太麻烦了。所以就去看了官方的解题教程，发现位运算这一方法更为简单和高效。</p>
</body></html>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode将有序数组转化为二叉搜索树</title>
    <url>/2020/12/20/LeetCode%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<html><head></head><body><h1 id="一、将有序数组转化为二叉搜索树"><a href="#一、将有序数组转化为二叉搜索树" class="headerlink" title="一、将有序数组转化为二叉搜索树"></a>一、将有序数组转化为二叉搜索树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://img-blog.csdnimg.cn/20201219235754380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70#id=a4Uzj&amp;originHeight=547&amp;originWidth=573&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"><br><strong>详情链接：</strong><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">有序数组转二叉树</a></p>
<h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><h2 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1.解题思路"></a>1.解题思路</h2><p>将当前数组的中间值用于创建当前的节点，然后中间值左边的数，分为一个新的子数组，这里我们暂且叫左子数组，将右边的分为右子数组。将左子数组放入当前节点的左子树。右子树组，放入当前节点的右子树。重复上述步骤即可。</p>
<h2 id="2-解题步骤"><a href="#2-解题步骤" class="headerlink" title="2.解题步骤"></a>2.解题步骤</h2><ol>
<li>创建一个新的节点节点值为数组的中位值 。</li>
<li>判断当前子数组大小是否为 1。</li>
</ol>
<ul>
<li>如果为 1，则直接返回该节点。</li>
<li>反之执行第三步。</li>
</ul>
<ol>
<li>判断当前数组的 <strong>(中间值得索引-1)&gt;=0</strong>， <strong>就是判断当前节点是否存在左子树</strong>。</li>
</ol>
<ul>
<li><pre><code>如果大于0，创建一个新的数组命名为左子数组，值为当前数组的中间值左边的所有数值。然后将将左子数组传入当前函数执行。
</code></pre>
</li>
<li>反之，则表明数组越界。直接执行第四步</li>
</ul>
<ol>
<li>判断当前数组的**(中间值的索引是+1)&lt;=当前数组的长度** ，就是判断当前节点是否存在右子树。</li>
</ol>
<ul>
<li>如果小于的话，创建一个新的数组命名为右子数组，值为当前数组的中间值右边的所有数值。然后将将右子数组传入当前函数执行。</li>
<li>反之，执行第五步</li>
</ul>
<ol>
<li>返回当前节点。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }{</span><br><span class="line">            <span class="keyword">return</span> arrrayToBST(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">arrrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start ,<span class="keyword">int</span> end)</span></span>{</span><br><span class="line">       <span class="keyword">int</span> length=end-start+<span class="number">1</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(nums[start+length/<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(start==end){</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(length/<span class="number">2</span>-<span class="number">1</span>&gt;=<span class="number">0</span>){</span><br><span class="line"></span><br><span class="line">                root.left=arrrayToBST(nums,start,start+length/<span class="number">2</span>-<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(length/<span class="number">2</span>+<span class="number">1</span>&lt;=length-<span class="number">1</span>){</span><br><span class="line"></span><br><span class="line">                root.right=arrrayToBST(nums,start+length/<span class="number">2</span>+<span class="number">1</span>,end);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>树的问题一般是通过递归和三种遍历方式来解决。目前我所写的很多树的比较简单的题目都是通过递归和树的三种遍历方式来实现的。</p>
<p><strong>各位大佬们看完后觉得我写得很差的的话，可以在评论去疯狂踩踏我蹂躏我。但是最最为重要的事就是不要白嫖！！！！虽然我知道在看的各位都是白嫖党！！！！</strong></p>
</body></html>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode递增顺序查找树</title>
    <url>/2021/01/04/LeetCode%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<html><head></head><body><h1 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h1><p><img src="https://img-blog.csdnimg.cn/20210104232857846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70#id=sJMFS&amp;originHeight=560&amp;originWidth=770&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"><br><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">题目详情链接</a></p>
<h1 id="一、解题思路"><a href="#一、解题思路" class="headerlink" title="一、解题思路"></a>一、解题思路</h1><p>将原树进行中序遍历将树中的节点的非空值放入到一个 list 集合中，创建一棵新树然后通过递归的方式将不断生成的新的右子树直到集合遍历完。</p>
<h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1.对原树进行中序遍历。将非空树的值一次放入到List集合中。</span><br><span class="line">2.创建一个函数用于对集合进行遍历，将每次遍历得到的值用来创建当前树的值。</span><br><span class="line">  在集合遍历完之前，继续递归该函数，将传递的实参改为当前树的右子树。</span><br></pre></td></tr></tbody></table></figure>

<h1 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>){</span><br><span class="line">           ArrayList array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Solution s=<span class="keyword">new</span> Solution();</span><br><span class="line">            s.inOrderTraversal(root,array);</span><br><span class="line">           root=s.toTree(<span class="keyword">null</span>,array,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">//通过递归的方式不断将集合中的值有做新的右子树的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">toTree</span><span class="params">(TreeNode root,List&lt;Integer&gt; array,<span class="keyword">int</span> length)</span></span>{</span><br><span class="line">        root=<span class="keyword">new</span> TreeNode(array.get(length));</span><br><span class="line">        root.left=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;array.size()-<span class="number">1</span>){</span><br><span class="line">            length++;</span><br><span class="line">            root.right=toTree(root.right,array,length);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraversal</span><span class="params">(TreeNode root,List&lt;Integer&gt; array)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>){</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">           inOrderTraversal(root.left,array);</span><br><span class="line">           array.add(root.val);</span><br><span class="line">           inOrderTraversal(root.right,array);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在我看来树的重点需要掌握的就是树的遍历方式。前序、中序、后序、层序。基本上许多和树有关的题目都会涉及到他的遍历方式。这些方式都可以通过递归的方式来实现。</p>
</body></html>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql技术内幕-第一章</title>
    <url>/2021/12/11/Mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<html><head></head><body><h1 id="1-定义数据库和实例"><a href="#1-定义数据库和实例" class="headerlink" title="1. 定义数据库和实例"></a>1. 定义数据库和实例</h1><h3 id="​"><a href="#​" class="headerlink" title="​"></a>​</h3><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​</p>
<ol>
<li>数据库**： **操作系统或者是内存中数据库类型文件的集合。</li>
</ol>
<p>​</p>
<ol start="2">
<li>实例： 数据库实例是真正操作数据库的对象。通过数据库实例完成对数据库文件的增删改查。</li>
</ol>
<p>​</p>
<p>​</p>
<p>MySQL 是一个单进程多线程的数据库。MySQL 数据库实例在系统上表现的就是一个进程。<br>​</p>
<p>​</p>
<h1 id="2-MySQL-体系结构"><a href="#2-MySQL-体系结构" class="headerlink" title="2. MySQL 体系结构"></a>2. MySQL 体系结构</h1><h2 id="1-结构图"><a href="#1-结构图" class="headerlink" title="1. 结构图"></a>1. 结构图</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635610498443-00dd90e5-027b-45cc-9abd-453e79201f37.png#clientId=u65aa59ec-0f7c-4&amp;from=paste&amp;height=297&amp;id=u870f042c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=593&amp;originWidth=916&amp;originalType=binary&amp;ratio=1&amp;size=162280&amp;status=done&amp;style=none&amp;taskId=u84e62d2d-ba28-4b0e-b986-287bccf284f&amp;width=458" alt="image.png"></p>
<h2 id="2-MySQL-组成部分"><a href="#2-MySQL-组成部分" class="headerlink" title="2. MySQL 组成部分"></a>2. MySQL 组成部分</h2><h3 id="1-8-大组成部分"><a href="#1-8-大组成部分" class="headerlink" title="1. 8 大组成部分"></a>1. 8 大组成部分</h3><ol>
<li>连接池</li>
<li>管理服务和工具组件</li>
<li>Sql 接口组件</li>
<li>查询分析器</li>
<li>优化器</li>
<li>缓存</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ol>
<p><strong>存储引擎是基于表的，而不是数据库。</strong><br>​</p>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<h1 id="3-MySQL-存储引擎"><a href="#3-MySQL-存储引擎" class="headerlink" title="3. MySQL 存储引擎"></a>3. MySQL 存储引擎</h1><h2 id="1-InnoDB-存储引擎-最常用的-5-5-8-后默认存储引擎"><a href="#1-InnoDB-存储引擎-最常用的-5-5-8-后默认存储引擎" class="headerlink" title="1. InnoDB 存储引擎(最常用的 5.5.8 后默认存储引擎)"></a>1. InnoDB 存储引擎(最常用的 5.5.8 后默认存储引擎)</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><ol>
<li><strong>行锁设计</strong></li>
<li><strong>支持外键</strong></li>
<li><strong>类似于 Oracle 的非锁定读</strong></li>
</ol>
<p>​</p>
<p>​</p>
<h3 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2. 主要功能"></a>2. 主要功能</h3><ol>
<li>InnoDB 使用<strong>多版本并发控制（MVCC）来实现高并发性。</strong></li>
<li><strong>实现了 4 种隔离级别</strong>。默认的为 REPEATABLE 级别</li>
<li>使用<strong>next-key locking 策略来避免幻读现象</strong></li>
<li>提供了插入缓冲（insert buffer）、二次写、自适应哈希索引、预读等高性能和高可用功能</li>
<li>数据的存储的采用了<strong>聚集的方式</strong>，表的数据存储按主键的顺序存放。如果没有主键会默认每行生成一个 ROWID 作为主键。</li>
</ol>
<p>​</p>
<h3 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3. 面向对象"></a>3. 面向对象</h3><p>设计目标主要面向<strong>在线事务处理应用。</strong><br><strong>​</strong></p>
<p><strong>​</strong></p>
<h2 id="2-MyISAM-存储引擎（5-58-之前默认存储引擎）"><a href="#2-MyISAM-存储引擎（5-58-之前默认存储引擎）" class="headerlink" title="2. MyISAM 存储引擎（5.58 之前默认存储引擎）"></a>2. MyISAM 存储引擎（5.58 之前默认存储引擎）</h2><h3 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1. 特点"></a>1. 特点</h3><ol>
<li><strong>不支持事务、表锁/行锁</strong></li>
<li><strong>支持全文索引</strong></li>
<li><strong>缓冲池只缓存索引文件</strong>，不缓存数据。</li>
<li>MyISAM 存储引擎表的由 MYD 和 MYI 两种文件存储。MYD 存储数据，MYI 存储索引。</li>
</ol>
<p>​</p>
<p>​</p>
<h2 id="3-NDB-存储引擎-集群存储引擎"><a href="#3-NDB-存储引擎-集群存储引擎" class="headerlink" title="3. NDB 存储引擎(集群存储引擎)"></a>3. NDB 存储引擎(集群存储引擎)</h2><h3 id="1-特点-2"><a href="#1-特点-2" class="headerlink" title="1. 特点"></a>1. 特点</h3><ol>
<li><strong>数据全部放在内存中</strong>，5.1 后，可将非索引数据存放到磁盘上。</li>
<li><strong>主键查找速度极快</strong></li>
<li>通过增加 NDB 数据存储节点，可以线性提高数据性能。是高可用、高性能集群系统</li>
<li><strong>查询速度慢</strong>。由于 NDB 存储引擎连接操作在数据库层完成，导致需要巨大网络开销。</li>
</ol>
<h2 id="4-Memory-存储引擎"><a href="#4-Memory-存储引擎" class="headerlink" title="4. Memory 存储引擎"></a>4. Memory 存储引擎</h2><h3 id="1-特点-3"><a href="#1-特点-3" class="headerlink" title="1. 特点"></a>1. 特点</h3><ol>
<li><strong>数据存放在内存中</strong></li>
<li><strong>默认使用哈希索引</strong></li>
<li><strong>只支持表锁，并发性能差</strong></li>
<li><strong>不支持 TEXT 和 BLOBl 乐行</strong></li>
<li><strong>浪费内存，存储 varchar 是按照 char 的方式存储。</strong></li>
</ol>
<p><strong>​</strong></p>
<h2 id="5-存储引擎的比较"><a href="#5-存储引擎的比较" class="headerlink" title="5. 存储引擎的比较"></a>5. 存储引擎的比较</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635613196777-e8e4aa9e-8031-41f7-9c6b-2759e7734602.png#clientId=u0834a0c7-dbbe-4&amp;from=paste&amp;height=288&amp;id=ub63fdd4b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=576&amp;originWidth=858&amp;originalType=binary&amp;ratio=1&amp;size=96128&amp;status=done&amp;style=none&amp;taskId=u8a3c4e80-50ac-4e4b-94fd-03638655320&amp;width=429" alt="image.png"></p>
<h1 id="4-连接-MySQL"><a href="#4-连接-MySQL" class="headerlink" title="4. 连接 MySQL"></a>4. 连接 MySQL</h1><p>本质： MySQL 实例和连接进程的进行通信。<br>进程间的通信方式：TCP/IP 套接字，UNIX 域套接字、管道、命名管道。<br>​</p>
<p>​</p>
<h3 id="1-TCP-IP（常用）"><a href="#1-TCP-IP（常用）" class="headerlink" title="1. TCP/IP（常用）"></a>1. TCP/IP（常用）</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635613490753-6a0743d1-db16-4a40-867b-8e10c6b131bb.png#clientId=u0834a0c7-dbbe-4&amp;from=paste&amp;height=65&amp;id=u2b227af7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=130&amp;originWidth=781&amp;originalType=binary&amp;ratio=1&amp;size=12153&amp;status=done&amp;style=none&amp;taskId=ub2eb1b22-c425-4278-a08b-e32c658f8b5&amp;width=390.5" alt="image.png"><br>客户端通过向 MySQL 服务器发送 TCP/IP 连接请求，连接成功后。MySQL 数据库会查权限视图，判断用户的客户端 IP 是否连接到 MySQL 实例。</p>
<h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h1><ol>
<li>介绍了实例和数据库的区别。实例是操作数据库的对象，数据库是所有数据库类型文件的集合</li>
<li>MySQL 的体系结构和其中的组件<ol>
<li>连接池</li>
<li>管理服务和工具组件</li>
<li>Sql 接口</li>
<li>查询和分析器</li>
<li>优化器</li>
<li>缓存</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ol>
</li>
<li>MySQL 主流的存储引擎及其特点<ol>
<li>InnoDB 支持行锁、事务\外键</li>
<li>MyISAM 不支持行表锁、事务。支持全文索引</li>
<li>Memory 支持哈希索引、表锁、不支持 BLOB、TEXT 类型。varchar 定长.</li>
<li>NDB 数据存放在内存中</li>
</ol>
</li>
</ol>
<p>​</p>
<p>​</p>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql技术内幕-第二章</title>
    <url>/2022/01/11/Mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<html><head></head><body><h1 id="1-InnoDB-体系架构"><a href="#1-InnoDB-体系架构" class="headerlink" title="1. InnoDB 体系架构"></a>1. InnoDB 体系架构</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635692260786-270228fe-31a7-4258-b9c1-87c52f516e08.png#clientId=u2d86973c-b20b-4&amp;from=paste&amp;height=227&amp;id=ua9f959a7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=454&amp;originWidth=736&amp;originalType=binary&amp;ratio=1&amp;size=30916&amp;status=done&amp;style=none&amp;taskId=u899d9abe-da7d-4e86-8256-0126b55682e&amp;width=368" alt="image.png"><br><strong>​</strong></p>
<h3 id="1-InnoDB-存储引擎作用"><a href="#1-InnoDB-存储引擎作用" class="headerlink" title="1. InnoDB 存储引擎作用"></a>1. InnoDB 存储引擎作用</h3><ol>
<li><strong>缓存磁盘上的数据</strong>，方便快速读取。对<strong>磁盘数据修改之前也做缓存。</strong></li>
<li><strong>redo log 缓冲</strong></li>
<li>维护进程、线程需要访问的多个内部数据结构</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>​</p>
<p>​</p>
<h2 id="1-后台线程"><a href="#1-后台线程" class="headerlink" title="1. 后台线程"></a>1. 后台线程</h2><p>InnoDB 存储引擎是多线程模型，负责处理不同的任务<br>​</p>
<h3 id="1-MasterThread"><a href="#1-MasterThread" class="headerlink" title="1. MasterThread"></a>1. MasterThread</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>将数据异步刷新到磁盘。其中包括脏页刷新、合并插入缓冲、UNDO 页回收。<br>​</p>
<p>​</p>
<h3 id="2-IO-Thread"><a href="#2-IO-Thread" class="headerlink" title="2. IO Thread"></a>2. IO Thread</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>InnoDB 使用了大量的<strong>异步 IO</strong> 来处理 IO 请求。作用是<strong>提高数据库的性能</strong>。<br>IO Thread 的作用是负责<strong>IO 请求的回调处理</strong><br><strong>​</strong></p>
<p><strong>​</strong></p>
<h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h4><p>IOThread 主要分为 4 种</p>
<ul>
<li><code>write thread</code>(默认 4 个)</li>
<li><code>read thread</code>(默认 4 个)</li>
<li><code>insert buffer thread</code></li>
<li><code>log io thread </code></li>
</ul>
<p>​</p>
<p>write 和 read Thread 可以通过 <code>innnodb_read_io_threads </code>和<code>innodb_write_io_threads</code>设置线程数<br><strong>​</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635693324015-367ec145-45e4-4614-87a4-0c8acb2a6e1e.png#clientId=u2d86973c-b20b-4&amp;from=paste&amp;height=101&amp;id=u0203448e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=201&amp;originWidth=916&amp;originalType=binary&amp;ratio=1&amp;size=44417&amp;status=done&amp;style=none&amp;taskId=u5737c692-8eaa-4bca-becf-305455ba63f&amp;width=458" alt="image.png"></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">//可以通过该命令查看innodb 中的io Thread</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash">show engine innodb  status ;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635693491056-13f94aba-301d-4a04-a8fa-9002fa135a97.png#clientId=u2d86973c-b20b-4&amp;from=paste&amp;height=118&amp;id=u0f6a553d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=235&amp;originWidth=567&amp;originalType=binary&amp;ratio=1&amp;size=29125&amp;status=done&amp;style=none&amp;taskId=u2646bf68-d485-4625-a513-b5ea7fdc815&amp;width=283.5" alt="image.png"></p>
<h3 id="3-Purge-Thread"><a href="#3-Purge-Thread" class="headerlink" title="3. Purge Thread"></a>3. Purge Thread</h3><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p><strong>作用：回收事务提交后的使用的 undo 页</strong>。<br>分配到独立的线程中进行，减少 Master Thread 工作。同时用户可以也可以通过<code>innnodb_purge_threads</code> 设置线程数，默认为 1.<br>​</p>
<p>​</p>
<h3 id="4-Page-Cleaner-Thread"><a href="#4-Page-Cleaner-Thread" class="headerlink" title="4. Page Cleaner Thread"></a>4. Page Cleaner Thread</h3><p>​</p>
<p>作用：脏页刷新操作。<br>从而减少了 Master Thread 工作和查询线程线程的阻塞。提高了 InnoDB 性能。<br>​</p>
<p>​</p>
<h3 id="5-后台线程作用"><a href="#5-后台线程作用" class="headerlink" title="5. 后台线程作用"></a>5. 后台线程作用</h3><ol>
<li>刷新内存池中的数据，保证缓存的是最新的数据</li>
<li>将已修改的数据文件刷新到磁盘中</li>
<li>保证数据库发生异常恢复正常</li>
</ol>
<h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h2><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="1-缓冲池"><a href="#1-缓冲池" class="headerlink" title="1. 缓冲池"></a>1. 缓冲池</h3><h4 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>用来<strong>解决 cpu 速度和磁盘速度之间的鸿沟</strong><br><strong>​</strong></p>
<p><strong>​</strong></p>
<h4 id="2-执行流程"><a href="#2-执行流程" class="headerlink" title="2. 执行流程"></a>2. 执行流程</h4><p>数据库读取页时，将磁盘读取到的页放在缓冲池中。下一次再次读取该数据页时，直接从池中读取。否则从磁盘上读取。</p>
<p>数据库修改页操作时，首先修改缓冲池的页，然后通过<code>check point </code>机制将数据页刷新到磁盘中。<br>​</p>
<h4 id="3-缓冲池大小配置"><a href="#3-缓冲池大小配置" class="headerlink" title="3. 缓冲池大小配置"></a>3. 缓冲池大小配置</h4><p><strong>​</strong></p>
<p>通过 innnodb_buffer_pool_size 来设置缓冲池大小。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635694963515-e0b21fec-317a-400c-ac75-263527738b5a.png#clientId=u2d86973c-b20b-4&amp;from=paste&amp;height=74&amp;id=u4b5d0c0c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=147&amp;originWidth=588&amp;originalType=binary&amp;ratio=1&amp;size=10538&amp;status=done&amp;style=none&amp;taskId=u89b99578-855f-48e2-a253-4720f96a6fb&amp;width=294" alt="image.png"><br>​</p>
<p>​</p>
<h4 id="4-存储对象"><a href="#4-存储对象" class="headerlink" title="4. 存储对象"></a>4. 存储对象</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635695049116-4482036d-9fb4-4114-86c0-d6bc26b0bb12.png#clientId=u2d86973c-b20b-4&amp;from=paste&amp;height=170&amp;id=ua8111efd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=339&amp;originWidth=782&amp;originalType=binary&amp;ratio=1&amp;size=36170&amp;status=done&amp;style=none&amp;taskId=ud1cc8c94-5846-4f28-9046-31ccee4f486&amp;width=391" alt="image.png"></p>
<ol>
<li>索引页</li>
<li>数据页</li>
<li>插入缓冲</li>
<li>undo 页</li>
<li>自适应哈希索引</li>
<li>锁信息</li>
<li>数据字典信息</li>
</ol>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<h3 id="2-缓存算法"><a href="#2-缓存算法" class="headerlink" title="2. 缓存算法"></a>2. 缓存算法</h3><h4 id="1-LRU（最近最少使用淘汰）"><a href="#1-LRU（最近最少使用淘汰）" class="headerlink" title="1. LRU（最近最少使用淘汰）"></a>1. LRU（最近最少使用淘汰）</h4><p>将经常使用的页放在 LRU 列表的最前端，最少使用页放在列表尾端。将新读取的页放到 midpoint 位置（距离尾端的 3/8 出）。可以通过<code>innodb_old_blocks_pct</code>控制插入位置。<br><code>midpoint</code> 之前的 new 列表，之后的为 old 列表。new 列表中数据为活跃的数据。<br>​</p>
<p>​</p>
<p>为什么不直接把读取的新页放在列表首部？<br>​</p>
<p>部分 sql 操作（索引、数据扫描操作）导致缓冲池中页被刷出，影响缓冲池效率。需要读入大量的数据页，导致许多活跃数据页从列表中移除。<br>innodb 可以通过设置<code>innodb_old_blocks_time</code>来决定新加入的页从 mid 到列表头部需要等待多久。<br>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="3-redo-日志缓冲（-redo-log-buffer）"><a href="#3-redo-日志缓冲（-redo-log-buffer）" class="headerlink" title="3. redo 日志缓冲（ redo log buffer）"></a>3. redo 日志缓冲（ redo log buffer）</h3><p>用于暂时存放 redo log 信息，然后 Innodb 以一定频率刷新到 redo log 文件中。<br>可以通过 <code>innnodb_log_buffer_size</code>设置缓冲大小。<br>​</p>
<p><strong>三种日志刷新到 redo log 文件情况</strong></p>
<ol>
<li>Master Thread 每秒刷新</li>
<li>事务提交时刷新</li>
<li>日志缓冲空间小于一半</li>
</ol>
<p>​</p>
<h1 id="2-Checkpoint-技术"><a href="#2-Checkpoint-技术" class="headerlink" title="2. Checkpoint 技术"></a>2. Checkpoint 技术</h1><p><strong>解决问题</strong></p>
<ol>
<li>缩短数据恢复时间</li>
<li>缓冲池不够时，将脏页刷新到磁盘</li>
<li>redo log 日志缓冲不够时，刷新脏页</li>
</ol>
<h2 id="1-Check-Point-分类："><a href="#1-Check-Point-分类：" class="headerlink" title="1. Check Point 分类："></a>1. Check Point 分类：</h2><ol>
<li>Sharp Checkpoint</li>
<li>Fuzzy Checkpoing</li>
</ol>
<p>​</p>
<p>​</p>
<h2 id="2-Sharp-Checkpoint"><a href="#2-Sharp-Checkpoint" class="headerlink" title="2. Sharp Checkpoint"></a>2. Sharp Checkpoint</h2><p>默认将<strong>数据库关闭时将所有脏页刷新到磁盘中</strong>，<br>参数是 innodb_fast_shutdown=1.</p>
<p>​</p>
<h2 id="3-Fuzzy-Checkpoint"><a href="#3-Fuzzy-Checkpoint" class="headerlink" title="3. Fuzzy Checkpoint"></a>3. Fuzzy Checkpoint</h2><h3 id="1-Master-Thread-checkpoint"><a href="#1-Master-Thread-checkpoint" class="headerlink" title="1. Master Thread checkpoint"></a>1. Master Thread checkpoint</h3><p>每 1 或 10 秒将缓冲池中的部分脏页异步刷新到磁盘</p>
<h3 id="2-Async-Sync-Flush-checkpoint"><a href="#2-Async-Sync-Flush-checkpoint" class="headerlink" title="2. Async/Sync Flush checkpoint"></a>2. Async/Sync Flush checkpoint</h3><p>在重做日志不可用情况下强制刷新一部分页会磁盘。</p>
<h1 id="3-InnoDB-关键特性"><a href="#3-InnoDB-关键特性" class="headerlink" title="3. InnoDB 关键特性"></a>3. InnoDB 关键特性</h1><h2 id="1-插入缓冲"><a href="#1-插入缓冲" class="headerlink" title="1. 插入缓冲"></a>1. 插入缓冲</h2><h3 id="1-Insert-Buffer"><a href="#1-Insert-Buffer" class="headerlink" title="1. Insert Buffer"></a>1. Insert Buffer</h3><p>原理： 当对<strong>非聚集索</strong>引进<strong>行插入或更新</strong>操作时，若<strong>索引页在缓冲池</strong>中，则直接<strong>更新索引页</strong>。反之，先<strong>放到 Insert Buffer <strong>中，然后以一定频率将 Insert Buffer 中的数据和辅助索引页进行</strong>merge 操作</strong>。<br>​</p>
<p>​</p>
<p>前提：<strong>不是唯一索引的辅助索引</strong><br>问题：为什么不能是唯一索引？<br>因为唯一索引在更新时，需要将索引页加载进缓冲池中，判断索引是否唯一。将索引页加入了缓冲池中，就失去了使用 Insert Buffer 的意义。<br>作用：提高插入性能，因为每次插入时不需要立即将数据 merge 到索引页中。<br>​</p>
<p>本质：将非聚集索引的写操作缓冲起来，然后将写操作批量 merge 到索引页中。<br>​</p>
<p>缺点：写密集情况下会暂用大量缓冲池内存<br>可以通过 IBUF_POOL_SIZE_PER_MAX_SIZE 设置 Insert buffer 占缓冲池的比例<br>​</p>
<h3 id="2-change-buffer"><a href="#2-change-buffer" class="headerlink" title="2. change buffer"></a>2. change buffer</h3><p>insert buffer 的升级版，支持 insert 、delete、 update 语句缓冲。通过 Insert Buffer、 Delete Buffer 、Purge Buffer 来实现缓冲。</p>
<p>Update 语句的实现过程</p>
<ol>
<li>数据的记录标记为删除</li>
<li>数据真正删除</li>
</ol>
<p>​</p>
<p>将数据记录标记位删除通过，通过 Delete Buffer 来实现。然后通过 Purge Buffer 将数据真正删除。<br>​</p>
<p>​</p>
<p>​</p>
<h3 id="3-Insert-Buffer-内部实现"><a href="#3-Insert-Buffer-内部实现" class="headerlink" title="3. Insert Buffer 内部实现"></a>3. Insert Buffer 内部实现</h3><p>Insert Buffer 的数据结构是一颗 B+树。<br>非叶节点存放的查询的 search key .<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635779623534-a1a111a7-ba6f-4e06-9b28-2805adb882e1.png#clientId=u147b5b0d-e61f-4&amp;from=paste&amp;height=51&amp;id=u23ae932e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=102&amp;originWidth=545&amp;originalType=binary&amp;ratio=1&amp;size=7625&amp;status=done&amp;style=none&amp;taskId=u8a8fadad-c07e-4ea8-a65f-6252e61e696&amp;width=272.5" alt="image.png"></p>
<ul>
<li>space 表示数据插入的表的<strong>表空间 id（用于确定插入数据是哪张表）</strong></li>
<li>marker 兼容老版本的 Insert Buffer</li>
<li>offset 数据页在表中的偏移量（位置）（用于确定是辅助索引的哪一页）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635780351139-02db6f9a-d6eb-43b8-b2c3-006e96cac8da.png#clientId=u147b5b0d-e61f-4&amp;from=paste&amp;height=74&amp;id=u85fb66e2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=147&amp;originWidth=742&amp;originalType=binary&amp;ratio=1&amp;size=20005&amp;status=done&amp;style=none&amp;taskId=uf11cb2c4-21ca-4099-a07a-63bd4da678e&amp;width=371" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635780853424-d8b9a379-1c69-4fdb-bcb0-b7b93b0b0a50.png#clientId=u147b5b0d-e61f-4&amp;from=paste&amp;height=86&amp;id=u6590f1f8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=172&amp;originWidth=968&amp;originalType=binary&amp;ratio=1&amp;size=15357&amp;status=done&amp;style=none&amp;taskId=ud2fa6c63-6633-4abc-92bb-c812946d476&amp;width=484" alt="image.png"></p>
<p>metadata 中记录信息插入的顺序以及插入信息的类型<br>​</p>
<p>​</p>
<p>Insert Buffer 通过 space 和 offset 确定更新数据的表和辅助索引具体页。<br>​</p>
<p>​</p>
<h3 id="4-Merge-Insert-Buffer"><a href="#4-Merge-Insert-Buffer" class="headerlink" title="4. Merge Insert Buffer"></a>4. Merge Insert Buffer</h3><h5 id="​"><a href="#​" class="headerlink" title="​"></a>​</h5><ol>
<li>辅助索引页读取到缓冲池中</li>
<li>Insert Buffer Bitmap 页发现辅助索引页无可用空间时。</li>
<li>Master Thread 定时进行 Merge</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. 命令</h3><h4 id="1-innodb-change-buffering"><a href="#1-innodb-change-buffering" class="headerlink" title="1. innodb_change_buffering"></a>1. <code>innodb_change_buffering</code></h4><p>作用： 选择开启哪些缓冲，参数为<img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635779173141-60283c22-3b4a-4307-9afb-d2b31f2ecf19.png#clientId=u147b5b0d-e61f-4&amp;from=paste&amp;height=21&amp;id=u50f1346f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=41&amp;originWidth=472&amp;originalType=binary&amp;ratio=1&amp;size=3875&amp;status=done&amp;style=none&amp;taskId=uf0bc3b34-e529-4b4e-91b5-9d2fc61f89c&amp;width=236" alt="image.png"></p>
<h4 id="2-innodb-change-buffer-max-size"><a href="#2-innodb-change-buffer-max-size" class="headerlink" title="2. innodb_change_buffer_max_size"></a>2. innodb_change_buffer_max_size</h4><p>作用：控制 change buffer 最大内存使用量<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635779232140-aea89c5b-1c60-420c-ad21-7455d07c85ef.png#clientId=u147b5b0d-e61f-4&amp;from=paste&amp;height=23&amp;id=ubfd3b6b4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=45&amp;originWidth=880&amp;originalType=binary&amp;ratio=1&amp;size=9395&amp;status=done&amp;style=none&amp;taskId=u5e544fdf-c639-4141-8cea-ffb33be97fc&amp;width=440" alt="image.png"><br><strong>最大值为 50.</strong></p>
<p>​</p>
<h2 id="2-两次写"><a href="#2-两次写" class="headerlink" title="2. 两次写"></a>2. 两次写</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1636031467126-3252bdd4-ab40-4f6e-9266-86cd36868636.png#clientId=uecbbc78a-62fa-4&amp;from=paste&amp;height=255&amp;id=u11158e89&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=510&amp;originWidth=816&amp;originalType=binary&amp;ratio=1&amp;size=174039&amp;status=done&amp;style=none&amp;taskId=ueb092f1b-bb82-4392-9efa-7d478b9f7a8&amp;width=408" alt="image.png"></p>
<h3 id="1-流程"><a href="#1-流程" class="headerlink" title="1. 流程"></a>1. 流程</h3><ol>
<li>InnoDB 将脏页写到内存中的 Double write buffer 中</li>
<li>然后 DWB 将数据现在写入磁盘上 DWB</li>
<li>内存中的 DWB 再将数据刷到磁盘中</li>
</ol>
<p>​</p>
<p>​</p>
<h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><p>通过将脏页数据进行缓存，可以保证数据库异常关闭的情况下，脏页数据未完全写入磁盘时，无法通过 redo log 进行数据的恢复。可以通过 DWB 中之前保存的脏页数据，将数据页写入到磁盘中，然后 redo log 根据脏页进行数据的恢复。<br>​</p>
<p><a href="https://developer.aliyun.com/article/743889?spm=a2c6h.14164896.0.0.7d52783blX00fB">double write buffer 深度</a><br>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="3-自适应哈希索引（AHI）"><a href="#3-自适应哈希索引（AHI）" class="headerlink" title="3. 自适应哈希索引（AHI）"></a>3. 自适应哈希索引（AHI）</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>由于哈希是一种时间复杂度为 O(1)的查找方法。可以通过在 B+树种建立哈希索引提高查询速度。<br>​</p>
<p>自适应哈希索引：存储引擎通过监控索引页的查询条件和频率，来选择是否建立哈希索引。<br>原理：通过缓冲池中的页</p>
<h3 id="2-前提"><a href="#2-前提" class="headerlink" title="2. 前提"></a>2. 前提</h3><ol>
<li>连续使用的查询条件一样</li>
<li>查询条件使用了 100 次</li>
<li>数据页通过该查询条件访问了（页中记录/16）次。</li>
</ol>
<p>​</p>
<h3 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h3><ol>
<li>提高了读取和写入速度</li>
<li>只能用来等值查询，不能范围查询</li>
</ol>
<p>​</p>
<p>​</p>
<h2 id="4-异步-IO"><a href="#4-异步-IO" class="headerlink" title="4. 异步 IO"></a>4. 异步 IO</h2><h3 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1. 作用"></a>1. 作用</h3><ol>
<li>异步执行 IO 操作</li>
<li>IO 合并</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="2-异步-IO-操作"><a href="#2-异步-IO-操作" class="headerlink" title="2. 异步 IO 操作"></a>2. 异步 IO 操作</h3><p>同步 IO: 用户发出 IO 请求后，需要等待 IO 请求完成，才能继续发送下一个 IO 请求。<br>异步 IO: 用户发出 IO 请求后不需要等待 IO 操作完成，可以继续发出 IO 请求。直到所有的 IO 请求发送完后，等待 IO 操作完成。<br>​</p>
<p>​</p>
<h3 id="3-IO-合并"><a href="#3-IO-合并" class="headerlink" title="3. IO 合并"></a>3. IO 合并</h3><p>AIO:将多个 IO 请求合并为一个 IO 请求。<br>​</p>
<p>例如： 用户需要访问多个连续页时（8,6）、（8,7）、（8,8）可以将多个 IO 操作合并成一个 IO 操作。<br>​</p>
<p>（page,offset）指代某个表的某一页。<br>​</p>
<h2 id="5-刷新临接页"><a href="#5-刷新临接页" class="headerlink" title="5. 刷新临接页"></a>5. 刷新临接页</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1636369637440-accdf8fa-3eba-4dfa-a7bd-ca3a30b7af22.png#clientId=udb988001-8bfa-4&amp;from=paste&amp;height=285&amp;id=u6fd4ce86&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=569&amp;originWidth=1027&amp;originalType=binary&amp;ratio=1&amp;size=95537&amp;status=done&amp;style=none&amp;taskId=u91c37abd-0f4c-4431-84d0-0657b3bb723&amp;width=513.5" alt="image.png"></p>
<p>工作原理：刷新脏页时，会检测所在区的所有分页，然后通过 AIO 一起进行刷新。<br>​</p>
<p>建议机械硬盘开启特性，固态硬盘由于有着高性能的 IO 读写可以关闭。<br>​</p>
<p>​</p>
<h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><p>​</p>
<h3 id="​-1"><a href="#​-1" class="headerlink" title="​"></a>​</h3></body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity中执行表单登录认证时无法执行loadUserByUsername方法</title>
    <url>/2021/05/13/SpringSecurity%E4%B8%AD%E6%89%A7%E8%A1%8C%E8%A1%A8%E5%8D%95%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E6%97%B6%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8CloadUserByUsername%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<html><head></head><body><p>​</p>
<p>​</p>
<h1 id="项目场景："><a href="#项目场景：" class="headerlink" title="项目场景："></a>项目场景：</h1><p>执行表单登录认证时配置了 loginProcessUrl 和 loginPage。但是执行登录认证时并不执行 UserDetailsService 接口的 loadByUsername 方法。导致认证失败。</p>
<h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><h2 id="1-表单登录页面"><a href="#1-表单登录页面" class="headerlink" title="1. 表单登录页面"></a>1. 表单登录页面</h2><p><img src="https://img-blog.csdnimg.cn/20210513173942750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70#id=vD5Kl&amp;originHeight=213&amp;originWidth=806&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"></p>
<h2 id="2-配置类"><a href="#2-配置类" class="headerlink" title="2. 配置类"></a>2. 配置类</h2><p><img src="https://img-blog.csdnimg.cn/20210513173201531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70#id=jxOTr&amp;originHeight=285&amp;originWidth=983&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"></p>
<h2 id="3-loadUserByUsername-方法"><a href="#3-loadUserByUsername-方法" class="headerlink" title="3. loadUserByUsername 方法"></a>3. loadUserByUsername 方法</h2><p><img src="https://img-blog.csdnimg.cn/20210513173433199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70#id=msIDN&amp;originHeight=219&amp;originWidth=1217&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"></p>
<h4 id="所有都配置好了，但是进行登录认证的时候还是认证失败跳回登录页。并且控制台未打印-loadUserByUsername-方法中的日志。"><a href="#所有都配置好了，但是进行登录认证的时候还是认证失败跳回登录页。并且控制台未打印-loadUserByUsername-方法中的日志。" class="headerlink" title="所有都配置好了，但是进行登录认证的时候还是认证失败跳回登录页。并且控制台未打印 loadUserByUsername 方法中的日志。"></a>所有都配置好了，但是进行登录认证的时候还是认证失败跳回登录页。并且控制台未打印 loadUserByUsername 方法中的日志。</h4><p><img src="https://img-blog.csdnimg.cn/20210513173819188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70#id=CEEDw&amp;originHeight=259&amp;originWidth=902&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"><br><img src="https://img-blog.csdnimg.cn/20210513173839414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODIwODk2,size_16,color_FFFFFF,t_70#id=n9Noa&amp;originHeight=227&amp;originWidth=1798&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"></p>
<h1 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h1><p>因此判断是 loginProcessUrl 方法的问题。进入 loginProcessUrl 方法内部发现。关键信息<br><img src="https://img-blog.csdnimg.cn/20210513174339209.png#id=h0HbJ&amp;originHeight=117&amp;originWidth=1070&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"><br>登录表单申请方式必须为 post 才行，springsecurity 才会进行登录认证。</p>
<hr>
<h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><h2 id="将登录表单中提交方法更改为-post-方式即可"><a href="#将登录表单中提交方法更改为-post-方式即可" class="headerlink" title="将登录表单中提交方法更改为 post 方式即可"></a>将登录表单中提交方法更改为 post 方式即可</h2></body></html>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringSecurity</tag>
        <tag>开发问题</tag>
      </tags>
  </entry>
  <entry>
    <title>了解Mysql查询语句执行流程</title>
    <url>/2022/01/11/%E4%BA%86%E8%A7%A3Mysql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<html><head></head><body><p>​</p>
<p><strong>MySQL 逻辑架构图</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1629176680362-2a25040b-16f9-402a-895d-3c6fdfd78a1f.png#clientId=u444c9418-ad4f-4&amp;from=paste&amp;height=335&amp;id=bsas8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=670&amp;originWidth=898&amp;originalType=binary&amp;ratio=1&amp;size=243581&amp;status=done&amp;style=none&amp;taskId=u046362f2-96e4-4be8-9205-33faa94f32d&amp;width=449" alt="image.png"></p>
<h2 id="1-Server-层"><a href="#1-Server-层" class="headerlink" title="1. Server 层"></a>1. Server 层</h2><h4 id="​"><a href="#​" class="headerlink" title="​"></a>​</h4><p>Server 层包括连接器、分析器、优化器、执行器、查询缓存。<br>​</p>
<h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h3><p>作用：</p>
<ol>
<li><strong>负责跟客户端建立连接</strong></li>
<li><strong>获取权限</strong></li>
<li><strong>维持和管理连接</strong></li>
</ol>
<p>​</p>
<p>连接指令</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h$ip <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p</span><br></pre></td></tr></tbody></table></figure>

<p>获取权限：通过 TCP 握手后，连接器验证身份，通过输入的用户名和密码。查询 MySQL 数据库中的 user 表。查询对应的用户权限。<br>​</p>
<p><strong>长连接和短链接</strong><br>​</p>
<p>长连接：连接成功后，如果客户端持续有请求，则一直使用该连接<br>​</p>
<p>短连接：每次执行完几次查询就断开连接，下次查询在重新建立连接。<br>​</p>
<p>​</p>
<p>建议使用长连接，因为建立连接过程比较复杂，尽量减少建立连接的动作。<br>​</p>
<p>但是建立长连接也会导致内存消耗增加。因为 Mysql 在执行时使用的内存是在连接对象里面的。这些资源会在断开时释放。<br>如果长连接累计下来，可能导致内存占用太大。<br>​</p>
<p>解决方法</p>
<ol>
<li>定期断开长连接</li>
<li>执行 mysql_reset_connectionc 初始化连接资源。针对 5.7 以后。</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2. 查询缓存"></a>2. 查询缓存</h3><p>​</p>
<p><strong>作用：用于做缓存</strong><br>Mysql 拿到请求后会先去缓存中，查看是否有对应的查询语句。缓存以 key-value 的形式存储。<br>查询语句作为 key ,查询结果作为 value 存入缓存中。<br>但是不建议使用查询缓存。因为缓存数据失效的很频繁。<br><strong>8.0 之后 MySQL 删掉了查询缓存</strong><br><strong>​</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>缓存查询</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  SQL_CACHE <span class="operator">*</span>  <span class="keyword">from</span> T ;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 不查询缓存</span><br><span class="line"><span class="keyword">select</span>   DEMAND <span class="operator">*</span>  <span class="keyword">from</span> T ;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>​</strong></p>
<h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h3><p>​</p>
<p><strong>作用： 进行 sql 语句的解析</strong>。<br>​</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>词法分析</li>
</ol>
<p>通过关键字 **select **识别为查询语句。将对应的 T 识别成对应的表名 T，将字符串”ID” 识别成列”ID”.<br>​</p>
<ol start="2">
<li>语法分析</li>
</ol>
<p>​</p>
<p>判断 Sql 语句是否满足 Mysql 语法。如果语句不对，则会受到错误提醒。<br>​</p>
<p>​</p>
<p>​</p>
<h3 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h3><p><strong>作用：决定执行方案</strong></p>
<ol>
<li><strong>决定使用哪个索引，多个索引情况下。</strong></li>
<li><strong>决定各表连接顺序，多个表关联的情况下。</strong></li>
</ol>
<p>​</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID) <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li>
<li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li>
</ul>
<p>​</p>
<p>优化器会决定执行哪种方案。<br>​</p>
<p>​</p>
<h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h3><p><strong>作用：执行 sql 语句</strong><br>​</p>
<ol>
<li>判断用户对这个表有无查询权限</li>
<li>根据表引擎提供的接口执行查询</li>
</ol>
<ul>
<li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ul>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h3><ol>
<li>连接器主要作用让客户端和服务端建立连接、获取登录用户权限、维持和管理连接。</li>
<li>查询缓存用于通过查询的 sql 语句作为 key，判断是否存在对应的 key,如果存在直接返回缓存中存储的查询结果。</li>
<li>分析器用于<strong>判断 sql 语句语法是否正确</strong>！将查询的 sql 语句的字段名解析成对应的数据库中对应的字段和表</li>
<li>分析器作用<strong>优化查询条件</strong>。查询条件判断使用哪种索引进行查询以及各表的连接顺序</li>
<li>执行器用于<strong>执行 sql 语句</strong>。</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro官方文档笔记</title>
    <url>/2021/06/26/Shiro%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<html><head></head><body><p>​</p>
<p>​</p>
<h1 id="1-核心架构"><a href="#1-核心架构" class="headerlink" title="1. 核心架构"></a>1. 核心架构</h1><h2 id="1-核心流程"><a href="#1-核心流程" class="headerlink" title="1. 核心流程"></a>1. 核心流程</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/f0ce7abbc21ee54f870ed39a960ba893.png#id=m154o&amp;originHeight=267&amp;originWidth=504&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"></p>
<h3 id="1-Subject"><a href="#1-Subject" class="headerlink" title="1. &nbsp;Subject"></a>1. &nbsp;Subject</h3><p>指需要认证的用户信息实体，subject 需要通过 securityManager 指定 Realm 来查询是否存在改用户信息和给用户进行授权的操作</p>
<h3 id="2-SecurityManager"><a href="#2-SecurityManager" class="headerlink" title="2. SecurityManager"></a>2. SecurityManager</h3><p>shiro 体系的核心。协调内部安全组件。如：Realm 等。</p>
<h3 id="3-Realm"><a href="#3-Realm" class="headerlink" title="3. Realm"></a>3. Realm</h3><p>通过查询特定的数据源：数据库、LDAP 等。来对 Subject 进行认证和授权操作。</p>
<h2 id="2-核心架构"><a href="#2-核心架构" class="headerlink" title="2. 核心架构"></a>2. 核心架构</h2><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FMppfyoU-1624680171088)(<a href="https://i.loli.net/2021/06/25/tADiGzO3lZpfrYW.png">https://i.loli.net/2021/06/25/tADiGzO3lZpfrYW.png</a>)]</p>
<h3 id="1-Authenticator-认证器"><a href="#1-Authenticator-认证器" class="headerlink" title="1. Authenticator 认证器"></a>1. Authenticator 认证器</h3><p>对 Subject 中的信息进行认证。通过将 Subject 的信息传入 Realm 查询指定数据源来进行认证判断。<br>当用户尝试登录时，执行认证器。</p>
<h3 id="2-AuthenticationStrategy-认证策略器"><a href="#2-AuthenticationStrategy-认证策略器" class="headerlink" title="2. AuthenticationStrategy 认证策略器"></a>2. AuthenticationStrategy 认证策略器</h3><p>如果配置了多个多个 Realm，则通过认证策略器来决定认证成功和认证失败的情况。</p>
<h3 id="3-Authorizer-授权器"><a href="#3-Authorizer-授权器" class="headerlink" title="3. Authorizer 授权器"></a>3. Authorizer 授权器</h3><p>用于对认证成功后的 Subject 进行授权操作。通过 Realm 查询到用户的对应信息给用户授予对应的权力</p>
<h3 id="4-SessionManager-会话管理器"><a href="#4-SessionManager-会话管理器" class="headerlink" title="4. SessionManager 会话管理器"></a>4. SessionManager 会话管理器</h3><p>Shiro 自带的会话管理器。能够创建和管理用户的 Session 生命周期。提供一种可靠的会话体验。默认情况下，Shiro 使用现有的会话机制机制如 Servlet 容器。</p>
<h3 id="5-SessionDao-会话持久器"><a href="#5-SessionDao-会话持久器" class="headerlink" title="5. SessionDao 会话持久器"></a>5. SessionDao 会话持久器</h3><p>将 Session Manager 中的 Session 对象进行 CRUD 操作将其存储起来。</p>
<h3 id="6-CacheManager-缓存管理器"><a href="#6-CacheManager-缓存管理器" class="headerlink" title="6. CacheManager 缓存管理器"></a>6. CacheManager 缓存管理器</h3><p>用于缓存 Shiro 中的 Realm 中的数据</p>
<h3 id="7-Crypto-加密"><a href="#7-Crypto-加密" class="headerlink" title="7. Crypto 加密"></a>7. Crypto 加密</h3><p>Shiro 中一个简单易用的加密包。针对于 Java 的加密机制，Shiro 的加密 Api 更加简单易用。</p>
<h3 id="8-Realm-领域"><a href="#8-Realm-领域" class="headerlink" title="8. Realm 领域"></a>8. Realm 领域</h3><p>用于查询数据数据源的信息。通过将查询到用户信息返回给认证器和授权器。进行认证和授权。</p>
<p>Security Manager 中的默认实现的功能</p>
<ul>
<li>Authentication 认证</li>
<li>Authorization 授权</li>
<li>Session Management &nbsp; 会话管理</li>
<li>Cache Management 缓存管理</li>
<li><a href="https://shiro.apache.org/realm.html">Realm</a> coordination &nbsp; 领域协调</li>
<li>Event propagation 事件传播</li>
<li>“Remember Me” Services &nbsp; 记住我服务</li>
<li>Subject creation Subject 对象的创建</li>
<li>Logout &nbsp; 注销</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="2-身份认证"><a href="#2-身份认证" class="headerlink" title="2. 身份认证"></a>2. 身份认证</h1><p>Subject 的构成</p>
<ol>
<li>principals</li>
</ol>
<p>通俗点来说就是用户的用户名，可以用来表示用户身份的证明。当然并不是唯一的。</p>
<ol start="2">
<li>credentials</li>
</ol>
<p>可以用来证明该用户身份的证据。通常指的是密码或证书等。</p>
<h2 id="1-认证-Subjects"><a href="#1-认证-Subjects" class="headerlink" title="1. 认证 Subjects"></a>1. 认证 Subjects</h2><ol>
<li>获取 Subject 中的 principals 和 Credentials</li>
<li>提交 principals 和 credentials 来进行认证操作</li>
<li>认证成功，则允许访问。反之阻止访问和进行新的认证</li>
</ol>
<p>实例演示：</p>
<ol>
<li><strong>获取 principals 和 credentials</strong></li>
</ol>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">//Example using most common scenario of username/password pair:</span><br><span class="line">UsernamePasswordToken token = new UsernamePasswordToken(username, password);</span><br><span class="line">//"Remember Me" built-in: token.setRememberMe(true);</span><br></pre></td></tr></tbody></table></figure>

<p>UsernamePasswordToken 是用来进行 Shiro 进行认证的接口对象。Shiro 中的认证需要认证的信息都要封装成 AuthenticationToken 接口的对象。UsernamePassowrdToken 是其接口的实现。<br>**</p>
<ol start="2">
<li>** 提交 priincipals 和 credentials**</li>
</ol>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject(); currentUser.login(token);</span><br></pre></td></tr></tbody></table></figure>

<p>** **subject 对象通过 login 方法将认证信息进行认证提交</p>
<ol start="3">
<li><strong>认证成功或失败</strong></li>
</ol>
<p>**<br>当认证成功后即可成功访问，如果失败 Shiro 会抛出异常。通过异常可以知道认证失败的原因。</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">try { currentUser.login(token); } catch ( UnknownAccountException uae ) { ... }</span><br><span class="line">catch ( IncorrectCredentialsException ice ) { ... } catch (</span><br><span class="line">LockedAccountException lae ) { ... } catch ( ExcessiveAttemptsException eae ) {</span><br><span class="line">... } ... catch your own ... } catch ( AuthenticationException ae ) {</span><br><span class="line">//unexpected error? } //No problems, continue on as expected...</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-Remember-Me-和-Authenticated"><a href="#2-Remember-Me-和-Authenticated" class="headerlink" title="2. Remember Me 和 Authenticated"></a>2. Remember Me 和 Authenticated</h2><ol>
<li><strong>Remember me</strong></li>
</ol>
<ul>
<li>使用的是先前会话的 Subject</li>
<li>并且 Subject 是非匿名的</li>
<li>通过调用 isRemembered 方法返回的 true</li>
</ul>
<ol start="2">
<li><strong>Authenticated</strong></li>
</ol>
<ul>
<li>当前认证成功的 subject</li>
<li>调用 isAuthenticated 返回 true</li>
</ul>
<p><strong>记住和已认证两种状态不能同时发生在同一 subject 上。</strong></p>
<h3 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h3><p>以下是一个相当常见的场景，有助于说明为什么记住和已认证之间的区别很重要。<br>假设您使用的是<a href="https://www.amazon.com/">Amazon.com</a>。您已成功登录，并已在购物车中添加了几本书。但是您必须参加会议，但忘记注销。会议结束时，该回家了，您离开办公室了。<br>第二天上班时，您发现自己还没有完成购买，因此回到 amazon.com。这次，亚马逊“记住”您的身份，以名字向您打招呼，并仍然为您提供一些个性化的书本推荐。对于亚马逊，<code>subject.isRemembered()</code>将返回<code>true</code>。<br>但是，如果您尝试访问帐户以更新信用卡信息以购买图书，会发生什么情况？当亚马逊“记住”您(<code>isRemembered()</code> == <code>true</code>)时，它不能保证您实际上就是您(例如，某个同事正在使用您的计算机)。<br>因此，在您执行敏感操作(如更新信用卡信息)之前，亚马逊会强迫您登录，以便他们保证您的身份。登录后，您的身份已通过验证，并且到亚马逊的<code>isAuthenticated()</code>现在为<code>true</code>。<br>这种情况在许多类型的应用程序中经常发生，因此该功能是 Shiro 内置的，因此您可以将其用于自己的应用程序。现在，是否使用<code>isRemembered()</code>或<code>isAuthenticated()</code>来定制视图和工作流已由您决定，但是 Shiro 将保留此基本状态，以备不时之需。</p>
<h2 id="3-注销"><a href="#3-注销" class="headerlink" title="3. 注销"></a>3. 注销</h2><p>当 Subject 调用 logout 方法后任何现有的 Session 都将失效并且任何身份都会被取消关联。</p>
<h2 id="4-认证流程"><a href="#4-认证流程" class="headerlink" title="4. 认证流程"></a>4. 认证流程</h2><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WFk3b6E6-1624680171090)(<a href="https://i.loli.net/2021/06/25/qGAUkvJCdIhjpFw.png">https://i.loli.net/2021/06/25/qGAUkvJCdIhjpFw.png</a>)]</p>
<p><strong>step1：</strong><br>调用 login 方法提交认证信息</p>
<p><strong>step2：</strong><br>调用 security Mangager.login（token）来通过 securityManager 开始真正的身份认证</p>
<p><strong>step3:</strong><br>securityManager 接收 token 并调用 authenticator.authenticate(token)将认证信息提供给认证器进行认证。<br><strong>step4：</strong></p>
<p>shiro 默认使用的 MoularRealmAuthenticator 实例通过 Realm 进行认证。如果配置了多个 Realm 则使用认证策略其，来进行多次的 Realm 认证。来决定认证成功和失败的条件。<br><strong>只有一个 Realm 的话不需要认证策略器</strong><br>**<br><strong>step5:</strong><br>咨询已配置的 Realm，通过使用 supports 方法判断其是否支持验证其身份信息，如果返回 true。则调用 Realm 的 getAuthenticationInfo 方法获取认证信息。</p>
<p>**<br>**</p>
<h1 id="3-授权"><a href="#3-授权" class="headerlink" title="3. 授权"></a>3. 授权</h1><h2 id="1-授权要素"><a href="#1-授权要素" class="headerlink" title="1. 授权要素"></a>1. 授权要素</h2><ul>
<li>权限：在程序中，表示用户可以执行什么动作或行为</li>
<li>角色：是一个或多个权限的集合实体。</li>
<li>用户：是一个或多个角色的集合实体。</li>
</ul>
<h2 id="2-授权-Subjects"><a href="#2-授权-Subjects" class="headerlink" title="2.授权 Subjects"></a>2.授权 Subjects</h2><h3 id="1-编程授权"><a href="#1-编程授权" class="headerlink" title="1. 编程授权"></a>1. 编程授权</h3><h4 id="1-基于角色的授权"><a href="#1-基于角色的授权" class="headerlink" title="1. 基于角色的授权"></a>1. 基于角色的授权</h4><p>通过用户是否含有特定角色，来执行角色检查</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject(); if</span><br><span class="line">(currentUser.hasRole("administrator")) { //show the admin button } else {</span><br><span class="line">//don't show the button? Grey it out? } Subject currentUser =</span><br><span class="line">SecurityUtils.getSubject(); //guarantee that the current user is a bank teller</span><br><span class="line">and //therefore allowed to open the account:</span><br><span class="line">currentUser.checkRole("bankTeller"); openBankAccount();</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/c3804a3a99297afbbe4a0b3a0a22edf6.png#id=coNW4&amp;originHeight=342&amp;originWidth=1008&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0fddec08dec8177dfa97498c8f147800.png#id=rHpDE&amp;originHeight=325&amp;originWidth=1024&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"></p>
<h4 id="2-基于权限的授权"><a href="#2-基于权限的授权" class="headerlink" title="2. 基于权限的授权"></a>2. 基于权限的授权</h4><p>与基于角色类似<img src="https://img-blog.csdnimg.cn/img_convert/045518ca2b12eaf21f9b4aa2faf2611a.png#id=z00tC&amp;originHeight=371&amp;originWidth=976&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6f2894b3d16202e20863f31d4b10a6ff.png#id=rO1PU&amp;originHeight=335&amp;originWidth=951&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"></p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dUuiGDuP-1624680171097)(<a href="https://i.loli.net/2021/06/25/ZKQJUnhEvT6a5ky.png">https://i.loli.net/2021/06/25/ZKQJUnhEvT6a5ky.png</a>)]</p>
<h3 id="2-基于注解授权"><a href="#2-基于注解授权" class="headerlink" title="2. 基于注解授权"></a>2. 基于注解授权</h3><p><strong>前提：</strong><br>需要在程序中开启 Aop 支持</p>
<h4 id="1-RequiresAuthentication-注解"><a href="#1-RequiresAuthentication-注解" class="headerlink" title="1. RequiresAuthentication 注解"></a>1. RequiresAuthentication 注解</h4><p>调用该方法时要求用户在当前会话期间认证过</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">@RequiresAuthentication public void updateAccount(Account userAccount) { //this</span><br><span class="line">method will only be invoked by a //Subject that is guaranteed authenticated ...</span><br><span class="line">} //等价于 public void updateAccount(Account userAccount) { if</span><br><span class="line">(!SecurityUtils.getSubject().isAuthenticated()) { throw new</span><br><span class="line">AuthorizationException(...); } //Subject is guaranteed authenticated here ... }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-RequiresGuest-注解"><a href="#2-RequiresGuest-注解" class="headerlink" title="2. RequiresGuest 注解"></a>2. RequiresGuest 注解</h4><p>不需要身份认证即可访问的方法</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">@RequiresGuest public void signUp(User newUser) { //this method will only be</span><br><span class="line">invoked by a //Subject that is unknown/anonymous ... } //等价于 public void</span><br><span class="line">signUp(User newUser) { Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">PrincipalCollection principals = currentUser.getPrincipals(); if (principals !=</span><br><span class="line">null &amp;&amp; !principals.isEmpty()) { //known identity - not a guest: throw new</span><br><span class="line">AuthorizationException(...); } //Subject is guaranteed to be a 'guest' here ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-RequiresPermissions-注解"><a href="#3-RequiresPermissions-注解" class="headerlink" title="3. RequiresPermissions 注解"></a>3. RequiresPermissions 注解</h4><p>要求用户必须有该权限才能调用</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">@RequiresPermissions("account:create") public void createAccount(Account</span><br><span class="line">account) { //this method will only be invoked by a Subject //that is permitted</span><br><span class="line">to create an account ... } public void createAccount(Account account) { Subject</span><br><span class="line">currentUser = SecurityUtils.getSubject(); if</span><br><span class="line">(!subject.isPermitted("account:create")) { throw new</span><br><span class="line">AuthorizationException(...); } //Subject is guaranteed to be permitted here ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-RequiresRoles-注解"><a href="#4-RequiresRoles-注解" class="headerlink" title="4. RequiresRoles 注解"></a>4. RequiresRoles 注解</h4><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">@RequiresRoles("administrator") public void deleteUser(User user) { //this</span><br><span class="line">method will only be invoked by an administrator ... } public void</span><br><span class="line">deleteUser(User user) { Subject currentUser = SecurityUtils.getSubject(); if</span><br><span class="line">(!subject.hasRole("administrator")) { throw new AuthorizationException(...); }</span><br><span class="line">//Subject is guaranteed to be an 'administrator' here ... }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-RequiresUser-注解"><a href="#5-RequiresUser-注解" class="headerlink" title="5. RequiresUser 注解"></a>5. RequiresUser 注解</h4><p>要求用户在当前会话期间进行了会话认证或者是是哦那个 Remember Me 服务被记住</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">@RequiresUser public void updateAccount(Account account) { //this method will</span><br><span class="line">only be invoked by a 'user' //i.e. a Subject with a known identity ... } public</span><br><span class="line">void updateAccount(Account account) { Subject currentUser =</span><br><span class="line">SecurityUtils.getSubject(); PrincipalCollection principals =</span><br><span class="line">currentUser.getPrincipals(); if (principals == null || principals.isEmpty()) {</span><br><span class="line">//no identity - they're anonymous, not allowed: throw new</span><br><span class="line">AuthorizationException(...); } //Subject is guaranteed to have a known identity</span><br><span class="line">here ... }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-基于-jsp-标签授权"><a href="#3-基于-jsp-标签授权" class="headerlink" title="3. 基于 jsp 标签授权"></a>3. 基于 jsp 标签授权</h3><h3 id="对应目录-jsp-标签库"><a href="#对应目录-jsp-标签库" class="headerlink" title="对应目录 jsp 标签库"></a>对应目录 jsp 标签库</h3><h2 id="3-授权流程"><a href="#3-授权流程" class="headerlink" title="3. 授权流程"></a>3. 授权流程</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/8b954ab61a6a1614a4029bbf0e7b17ea.png#id=WV4Hc&amp;originHeight=435&amp;originWidth=742&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"></p>
<p><strong>step1:</strong><br>subject 通过调用一些角色和权限的判断方法</p>
<p><strong>step2:</strong><br>securityManager 调用上面相同的角色和权限的方法</p>
<p><strong>step3:</strong><br>securityManager 调用 authorizer 默认实例 ModularRealmAuthorizer 实列</p>
<p><strong>step4:</strong><br>使用 Realm 获取用户对应的权限信息</p>
<h1 id="4-领域"><a href="#4-领域" class="headerlink" title="4. 领域"></a>4. 领域</h1><h2 id="1-领域认证"><a href="#1-领域认证" class="headerlink" title="1.领域认证"></a>1.领域认证</h2><h3 id="1-领域认证流程"><a href="#1-领域认证流程" class="headerlink" title="1. 领域认证流程"></a>1. 领域认证流程</h3><p>如果调用 Realm 方法支持提交的 AuthenticationToken，则调用 Realm 的 getAuthenticationInfo 方法。然后通过该方法可以获取对应 token 在领域数据源的数据。方法执行顺序为</p>
<ol>
<li>识别 token 中的 principal 信息</li>
<li>根据 principal 查找对应数据源中对应的数据</li>
<li>确保 token 中的 credentials 与对应数据库中的数据匹配</li>
<li>匹配返回 AuthenticationInfo 实例，反之则抛出 AuthenticationException</li>
</ol>
<p><strong>领域认证可以通过实现 AuthorizingRealm 抽象类来实现领域认证。</strong></p>
<h3 id="2-凭证匹配"><a href="#2-凭证匹配" class="headerlink" title="2. 凭证匹配"></a>2. 凭证匹配</h3><p>在领域认证流程中领域必须验证 Subject 提交的 credentials 和数据库中存储的凭据是否匹配。如果匹配在身份验证成功。<br>凭证匹配通过 AuthenticatingRealm 和子类 CredentialsMatcher 来实现凭据的比较</p>
<p>Shiro 提供了 CredentialsMatcher 的实现。例如 SimpleCredentialsMatcher 和 HashedCredentialsMatcher 的实现类。也可以自己自定义证书匹配的规则。</p>
<h4 id="1-SimpleCredentialsMatcher"><a href="#1-SimpleCredentialsMatcher" class="headerlink" title="1. SimpleCredentialsMatcher"></a>1. SimpleCredentialsMatcher</h4><p>Shiro 中所有的 Realm 默认使用的都是 SimpleCredentialsMatcher。SimpleCredentialsMatcher 对存储的凭据和 AuthenticationToken 中进行直接相等性检查。</p>
<h4 id="2-HashedCredentialsMatcher"><a href="#2-HashedCredentialsMatcher" class="headerlink" title="2. HashedCredentialsMatcher"></a>2. HashedCredentialsMatcher</h4><p>当用户需要存储一些比较密码等一些重要的凭证时，不是直接存入数据库中而是先 hash 一次然后再存入数据库中。<br>这样用户存储的凭证更加安全也没有人知道原始值。</p>
<h2 id="2-领域授权"><a href="#2-领域授权" class="headerlink" title="2. 领域授权"></a>2. 领域授权</h2><p>SeurityManager 将权限和角色的检查任务交给授权器。默认的授权器为 ModularRealmAuthorizer。</p>
<h3 id="1-基于角色的授权流程"><a href="#1-基于角色的授权流程" class="headerlink" title="1. 基于角色的授权流程"></a>1. 基于角色的授权流程</h3><ol>
<li>Subject 委托 SecurityManager 以确定是否分配给定的角色</li>
<li>SecurityManager 委托授权器</li>
<li>授权器逐个使用所有领域，直到找到 Subject 指定角色。如果都没有则返回 false</li>
<li>如果在领域中成功找到则掉哦那个 AuthenticationInfo.getRoles 返回给定角色。并授予访问权限。</li>
</ol>
<h4 id="2-基于权限的授权流程"><a href="#2-基于权限的授权流程" class="headerlink" title="2. 基于权限的授权流程"></a>2. 基于权限的授权流程</h4><ol>
<li>Subject 委托 SecurityManager 授予或拒绝授予权限</li>
<li>SecurityManager 委托给授权器</li>
<li>授权器查找所有领域，如果查找到对应全新啊，则授予权限。反之则拒绝授予权限</li>
</ol>
<h1 id="5-会话管理"><a href="#5-会话管理" class="headerlink" title="5. 会话管理"></a>5. 会话管理</h1><p><strong>特性：</strong></p>
<ol>
<li>轻松自定义会话存储</li>
<li>支持 web</li>
<li>可用于 sso</li>
</ol>
<h2 id="1-使用-Session"><a href="#1-使用-Session" class="headerlink" title="1. 使用 Session"></a>1. 使用 Session</h2><p>Session 的获取</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject(); Session session =</span><br><span class="line">currentUser.getSession(); session.setAttribute( "someKey", someValue);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/10fc819bbfd3c78fdeb94ea7f5007ba9.png#id=YfoSQ&amp;originHeight=220&amp;originWidth=1030&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none"></p>
<h2 id="2-会话管理器"><a href="#2-会话管理器" class="headerlink" title="2. 会话管理器"></a>2. 会话管理器</h2><p>Shiro 中会话管理器可以对应用中的 Session 进行创建、删除、验证等操作。<br>Shiro 中提供了默认的会话管理器 DefaultSessionManager。提供了 Session 的验证和清楚等</p>
<h2 id="3-会话存储"><a href="#3-会话存储" class="headerlink" title="3. 会话存储"></a>3. 会话存储</h2><p>当每次创建、更新或删除长时间未使用的 Session 时，未来避免 Session 存储空间耗尽。SessionManager 将 Session 的创建、读取、更新、删除操作委派给<br>组件 SesssionDao。<br>SessionDao 的特点将所有你只需要实现这个接口姐可以实现任何数据的储存在任何地方。这意味着你可以将 Session 数据存储在内存中、关系数据库、NoSql 数据库中。</p>
<p>Shiro 中默认的 Session 存储在内存中。可以通过配置 EHCacheSessionDao 或者是实现自定以的 SessionDao。</p>
<h3 id="1-EHCache-SessionDao"><a href="#1-EHCache-SessionDao" class="headerlink" title="1. EHCache SessionDao"></a>1. EHCache SessionDao</h3><p>默认情况下未开启。如需开启需要在会话管理器中开启 EHCache 支持。EHCache SessionDao 会将 Sesssion 存储在会话中。如果内存不够了，则会其他的 Session 存储在磁盘中。<br>除了存储 Session 外，还以缓存身份验证和授权数据</p>
<h3 id="2-EHCacheSessionDao-配置"><a href="#2-EHCacheSessionDao-配置" class="headerlink" title="2.EHCacheSessionDao 配置"></a>2.EHCacheSessionDao 配置</h3><p>默认情况下 Shiro 中的 EhCacheManager 使用的 Shiro 自带的 ehcache.xml 来设置缓存配置。</p>
<h1 id="6-JSP-标签库"><a href="#6-JSP-标签库" class="headerlink" title="6. JSP 标签库"></a>6. JSP 标签库</h1><h2 id="1-标签库配置"><a href="#1-标签库配置" class="headerlink" title="1. 标签库配置"></a>1. 标签库配置</h2><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix="shiro" uri="http://shiro.apache.org/tags" %&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-访客标签"><a href="#2-访客标签" class="headerlink" title="2. 访客标签"></a>2. 访客标签</h2><p>不需要认证就可以生效的标签</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:guest</span>&gt;</span></span><br><span class="line">  Hi there! Please <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"login.jsp"</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">a</span>&gt;</span> or</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"signup.jsp"</span>&gt;</span>Signup<span class="tag">&lt;/<span class="name">a</span>&gt;</span> today!</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:guest</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-用户标签"><a href="#3-用户标签" class="headerlink" title="3. 用户标签"></a>3. 用户标签</h2><p>当用户被认证过或者说是被记住了的话才生效的标签</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:user</span>&gt;</span></span><br><span class="line">    Welcome back John!  Not John? Click <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"login.jsp"</span>&gt;</span>here<span class="tag">&lt;<span class="name">a</span>&gt;</span> to login.</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:user</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-认证标签"><a href="#3-认证标签" class="headerlink" title="3. 认证标签"></a>3. 认证标签</h2><p>用户只有被认证过才生效的标签</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:authenticated</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"updateAccount.jsp"</span>&gt;</span>Update your contact information<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:authenticated</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-认证失败标签"><a href="#4-认证失败标签" class="headerlink" title="4. 认证失败标签"></a>4. 认证失败标签</h2><p>用户认证失败的生效标签</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:notAuthenticated</span>&gt;</span></span><br><span class="line">  Please <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"login.jsp"</span>&gt;</span>login<span class="tag">&lt;/<span class="name">a</span>&gt;</span> in order to update your credit card</span><br><span class="line">  information.</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:notAuthenticated</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-principal-标签"><a href="#5-principal-标签" class="headerlink" title="5.principal 标签"></a>5.principal 标签</h2><p>获取用户的 priincipal 属性<br>shiro:principa 标签可以简化为 principal</p>
<p>principal 等价于 subject.getPrincipal()方法</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">Hello, <span class="tag">&lt;<span class="name">shiro:principal</span> /&gt;</span>, how are you today? //等价于 Hello, &lt;%=</span><br><span class="line">SecurityUtils.getSubject().getPrincipal().toString() %&gt;, how are you today? User</span><br><span class="line">ID: <span class="tag">&lt;<span class="name">principal</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">User ID: &lt;%=</span><br><span class="line">SecurityUtils.getSubject().getPrincipals().oneByType(Integer.class).toString()</span><br><span class="line">%&gt; Hello, <span class="tag">&lt;<span class="name">shiro:principal</span> <span class="attr">property</span>=<span class="string">"firstName"</span> /&gt;</span>, how are you today? Hello,</span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:principal</span> <span class="attr">type</span>=<span class="string">"com.foo.User"</span> <span class="attr">property</span>=<span class="string">"firstName"</span> /&gt;</span>, how are you today?</span><br><span class="line">Hello, &lt;%= SecurityUtils.getSubject().getPrincipal().getFirstName().toString()</span><br><span class="line">%&gt;, how are you today?</span><br></pre></td></tr></tbody></table></figure>

<h2 id="6-hasRole-标签"><a href="#6-hasRole-标签" class="headerlink" title="6. hasRole 标签"></a>6. hasRole 标签</h2><p>当用户拥有某个权限才会生效的标签</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"administrator"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"admin.jsp"</span>&gt;</span>Administer the system<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="7-misssingRole-标签"><a href="#7-misssingRole-标签" class="headerlink" title="7.misssingRole 标签"></a>7.misssingRole 标签</h2><p>与 hasRole 标签作用相反</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:lacksRole</span> <span class="attr">name</span>=<span class="string">"administrator"</span>&gt;</span></span><br><span class="line">  Sorry, you are not allowed to administer the system.</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:lacksRole</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="8-hasAnyRole-标签"><a href="#8-hasAnyRole-标签" class="headerlink" title="8.hasAnyRole 标签"></a>8.hasAnyRole 标签</h2><p>用户只要含有任意一个角色就生效的标签</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasAnyRoles</span> <span class="attr">name</span>=<span class="string">"developer, project manager, administrator"</span>&gt;</span></span><br><span class="line">  You are either a developer, project manager, or administrator.</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasAnyRoles</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="9-hasPermission-标签"><a href="#9-hasPermission-标签" class="headerlink" title="9.hasPermission 标签"></a>9.hasPermission 标签</h2><p>用户拥有某项权限才生效的标签</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"user:create"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"createUser.jsp"</span>&gt;</span>Create a new User<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="10-missingsPermisssion-标签"><a href="#10-missingsPermisssion-标签" class="headerlink" title="10. missingsPermisssion 标签"></a>10. missingsPermisssion 标签</h2><p>与 hasPermission 作用相反</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:lacksPermission</span> <span class="attr">name</span>=<span class="string">"user:delete"</span>&gt;</span></span><br><span class="line">  Sorry, you are not allowed to delete user accounts.</span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:lacksPermission</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</body></html>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/2021/12/18/JUC/</url>
    <content><![CDATA[<html><head></head><body><p>​</p>
<h1 id="1-并发基础"><a href="#1-并发基础" class="headerlink" title="1. 并发基础"></a>1. 并发基础</h1><h2 id="1-多线程实现"><a href="#1-多线程实现" class="headerlink" title="1. 多线程实现"></a>1. 多线程实现</h2><h3 id="1-实现方法分类"><a href="#1-实现方法分类" class="headerlink" title="1. 实现方法分类"></a>1. 实现方法分类</h3><ol>
<li>继承 Thread 类，重写 run 方法</li>
<li>实现 Runnable 接口，实现 run 方法</li>
</ol>
<p>​</p>
<h3 id="2-两种方法对比"><a href="#2-两种方法对比" class="headerlink" title="2.两种方法对比"></a>2.两种方法对比</h3><ul>
<li>实现 runnable 接口更好</li>
</ul>
<ol>
<li> Java 只支持单继承，继承 Thread 类导致程序拓展性不好</li>
<li> 解耦，将创建线程和线程任务调度分离了</li>
</ol>
<ul>
<li>两种方法本质区别对比</li>
</ul>
<ol>
<li>继承 Thread 类是通过重写 Thread 类的方法</li>
<li>实现 Runnable 是在 Thread 类中调用 Runnable 实现类的 run 方法</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1632972177969-fad65c06-bcc6-44e4-b2b1-6ca907ef17f6.png#clientId=uc78e1191-c90c-4&amp;from=paste&amp;height=88&amp;id=u87fc8e3c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=175&amp;originWidth=798&amp;originalType=binary&amp;ratio=1&amp;size=17698&amp;status=done&amp;style=none&amp;taskId=ue1385ff3-9acf-4f86-9c7b-9dc189b4937&amp;width=399" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1632975139265-558c5dc8-a5c9-4d7e-a3a2-f7776812b1d3.png#clientId=uc78e1191-c90c-4&amp;from=paste&amp;height=179&amp;id=uf1f15e3b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=358&amp;originWidth=911&amp;originalType=binary&amp;ratio=1&amp;size=208968&amp;status=done&amp;style=none&amp;taskId=u470653a7-2d58-4d6c-8e55-e0f0f3b1a54&amp;width=455.5" alt="image.png"></p>
<p><strong>思考题：同时使用两种方法实现多线程</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BothRunnableThread</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="comment">//实现Runnable接口的方法</span></span><br><span class="line">            System.out.println(<span class="string">"我来自Runnable"</span>);</span><br><span class="line">        }) {</span><br><span class="line">            <span class="comment">//重写Thread类的run方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"我来自Thread"</span>);</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>结果<br>​</p>
<p>我来自 Thread<br>​</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p><strong>实现线程创建的方法:只有一种通过 Thread 类来创建线程</strong><br><strong>实现线程执行方法：</strong></p>
<ol>
<li><strong>实现 Runnable 接口的 run 方法，并把接口实例传给 Thread 类在其 Thread 类中的 run 方法中调用</strong></li>
<li><strong>重写 Thread 类的 run 方法</strong></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1632972177969-fad65c06-bcc6-44e4-b2b1-6ca907ef17f6.png#clientId=uc78e1191-c90c-4&amp;from=paste&amp;height=88&amp;id=E0Gbe&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=175&amp;originWidth=798&amp;originalType=binary&amp;ratio=1&amp;size=17698&amp;status=done&amp;style=none&amp;taskId=ue1385ff3-9acf-4f86-9c7b-9dc189b4937&amp;width=399" alt="image.png"><br>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="错误观点"><a href="#错误观点" class="headerlink" title="错误观点"></a>错误观点</h3><ol>
<li>线程池也是创建线程的一种方式（其本质还是通过 Thread 类来创建线程）</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1632973964491-96ae041b-cac4-4e5c-9c8f-5a06fcf1da7f.png#clientId=uc78e1191-c90c-4&amp;from=paste&amp;height=152&amp;id=u79391c98&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=304&amp;originWidth=951&amp;originalType=binary&amp;ratio=1&amp;size=42157&amp;status=done&amp;style=none&amp;taskId=u93535749-5529-4f24-9947-c8d937f09d8&amp;width=475.5" alt="image.png"></p>
<ol start="2">
<li>Callable 也是创建线程的一种方式（本质是调用其创建一个内部线程执行 run 方法在 run 方法内部调用 callable 的 call 方法）</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1632976285825-263a51fb-e842-4cec-8206-67a41403c8ac.png#clientId=uc78e1191-c90c-4&amp;from=paste&amp;height=312&amp;id=u645da87e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=624&amp;originWidth=917&amp;originalType=binary&amp;ratio=1&amp;size=58810&amp;status=done&amp;style=none&amp;taskId=ufa52c3d1-c751-48ce-a2ed-806eaadbca4&amp;width=458.5" alt="image.png"><a href="https://blog.csdn.net/xzongyuan/article/details/71378769">FutureTask 与 Callable 的本质</a><br>​</p>
<p>​</p>
<h3 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h3><h4 id="1-多少种线程实现方法"><a href="#1-多少种线程实现方法" class="headerlink" title="1. 多少种线程实现方法"></a>1. 多少种线程实现方法</h4><p>参考总结</p>
<h4 id="2-Runnable-和-Thread-类那种方法实现多线程更好"><a href="#2-Runnable-和-Thread-类那种方法实现多线程更好" class="headerlink" title="2. Runnable 和 Thread 类那种方法实现多线程更好"></a>2. Runnable 和 Thread 类那种方法实现多线程更好</h4><p>Runnable 好</p>
<ol>
<li>职责分离： Runnable 定义了执行内容，Thread 类用于创建线程权责分明</li>
<li>提高性能：每次执行一次任务，都需要新建一个独立的线程，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类，整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。如果我们使用实现 Runnable 接口的方式，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。</li>
<li>Java 只支持单继承</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="2-线程的启动"><a href="#2-线程的启动" class="headerlink" title="2. 线程的启动"></a>2. 线程的启动</h2><h3 id="1-start-和-run-方法比较"><a href="#1-start-和-run-方法比较" class="headerlink" title="1. start 和 run 方法比较"></a>1. start 和 run 方法比较</h3><h4 id="1-start-方法"><a href="#1-start-方法" class="headerlink" title="1. start 方法"></a>1. start 方法</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol>
<li> 启动新线程</li>
<li> 新线程的准备工作</li>
</ol>
<h5 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h5><p><strong>执行流程</strong></p>
<ol>
<li><strong>判断线程状态</strong></li>
<li><strong>将线程加入线程组</strong></li>
<li><strong>调用 start0 方法</strong></li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Causes this thread to begin execution; the Java Virtual Machine</span></span><br><span class="line"><span class="comment">    * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The result is that two threads are running concurrently: the</span></span><br><span class="line"><span class="comment">    * current thread (which returns from the call to the</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;run&lt;/code&gt; method).</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * It is never legal to start a thread more than once.</span></span><br><span class="line"><span class="comment">    * In particular, a thread may not be restarted once it has completed</span></span><br><span class="line"><span class="comment">    * execution.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span>  IllegalThreadStateException  if the thread was already</span></span><br><span class="line"><span class="comment">    *               started.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        #run()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        #stop()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">        * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">        * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">        * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">        * and the group's unstarted count can be decremented. */</span></span><br><span class="line">       group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           start0();</span><br><span class="line">           started = <span class="keyword">true</span>;</span><br><span class="line">       } <span class="keyword">finally</span> {</span><br><span class="line">           <span class="keyword">try</span> {</span><br><span class="line">               <span class="keyword">if</span> (!started) {</span><br><span class="line">                   group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">               }</span><br><span class="line">           } <span class="keyword">catch</span> (Throwable ignore) {</span><br><span class="line">               <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                 it will be passed up the call stack */</span></span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-run-方法"><a href="#2-run-方法" class="headerlink" title="2. run 方法"></a>2. run 方法</h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><ol>
<li>执行该线程任务</li>
</ol>
<p>​</p>
<p>​</p>
<h5 id="源码解读-1"><a href="#源码解读-1" class="headerlink" title="源码解读"></a>源码解读</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * If this thread was constructed using a separate</span></span><br><span class="line"><span class="comment">  * &lt;code&gt;Runnable&lt;/code&gt; run object, then that</span></span><br><span class="line"><span class="comment">  * &lt;code&gt;Runnable&lt;/code&gt; object's &lt;code&gt;run&lt;/code&gt; method is called;</span></span><br><span class="line"><span class="comment">  * otherwise, this method does nothing and returns.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>     #start()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>     #stop()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>     #Thread(ThreadGroup, Runnable, String)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">     <span class="keyword">if</span> (target != <span class="keyword">null</span>) {</span><br><span class="line">         target.run();</span><br><span class="line">     }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-面试题"><a href="#3-面试题" class="headerlink" title="3. 面试题"></a>3. 面试题</h4><p>​</p>
<ol>
<li>两次调用 start 方法会出现什么情况？</li>
</ol>
<p>参考 start 方法源码解读</p>
<ol start="2">
<li>为什么不能直接调用 run 方法</li>
</ol>
<p>start 方法用于创建新的线程，如果直接调用 run 方法则是有 main 线程调用 run 方法<br>​</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartAndRunMethod</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Runnable runnable = () -&gt; {</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        };</span><br><span class="line">        runnable.run();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">main</span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-停止线程"><a href="#3-停止线程" class="headerlink" title="3. 停止线程"></a>3. 停止线程</h2><p><strong>interupt 停止线程原理：通知线程停止，但是不强制停止线程。由线程的 run 方法决定是否停止。</strong></p>
<h3 id="1-正确停止线程"><a href="#1-正确停止线程" class="headerlink" title="1. 正确停止线程"></a>1. 正确停止线程</h3><p>方法 1</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) {</span><br><span class="line">                System.out.println(<span class="string">"线程中断程序结束"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"go"</span>);</span><br><span class="line">            throwInMethod();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">throwInMethod</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//sleep()、wait()等会抛中断异常的方法在抛出异常之前会清除线程的中断标识</span></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>方法 2</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            System.out.println(<span class="string">"go"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                throwInMethod();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">throwInMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd2());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-错误的停止方法"><a href="#2-错误的停止方法" class="headerlink" title="2. 错误的停止方法"></a>2. 错误的停止方法</h3><ol>
<li>调用 stop 方法</li>
<li>用 volatile 设置 boolean 标记位</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatile</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        BlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">30</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (!consumer.needMoreNums()) {</span><br><span class="line"></span><br><span class="line">                producer.canceled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            Object take = blockingQueue.take();</span><br><span class="line">            System.out.println(<span class="string">"消费者开始消费"</span> + take);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue blockingQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue blockingQueue)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">10000</span> &amp;&amp; !canceled) {<span class="comment">//线程中断的地方</span></span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) {</span><br><span class="line"></span><br><span class="line">                    blockingQueue.put(num);<span class="comment">//导致线程不能中断的地方是由于put一直处于阻塞状态</span></span><br><span class="line">                    System.out.println(<span class="string">"生产者生产完成"</span> + num);</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                }</span><br><span class="line">                num++;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"生产结束"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 概率约为95%的随机消费</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">double</span> random = Math.random();</span><br><span class="line">        <span class="keyword">if</span> (random &gt; <span class="number">0.96</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue blockingQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue blockingQueue)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-线程的生命周期"><a href="#4-线程的生命周期" class="headerlink" title="4. 线程的生命周期"></a>4. 线程的生命周期</h2><h3 id="1-线程的-6-种状态"><a href="#1-线程的-6-种状态" class="headerlink" title="1. 线程的 6 种状态"></a>1. 线程的 6 种状态</h3><ul>
<li>New 创建了线程但是没有执行 start 方法</li>
<li>Runnable 调用了 start 方法后变成 Runnable 状态</li>
<li>Blocked 线程进入<strong>Synchronized 修饰的方法或者代码块</strong>但是锁被其他线程拿走</li>
<li>Waiting wait() 、Thread.join() 、LockSupport.park() 只能等待唤醒信号唤醒</li>
<li>Timed Waiting wait(time) sleep(time) join(time) parkNanos(time) parkUntiil(time) 等待信号唤醒或超时</li>
<li>Terminated</li>
</ul>
<p>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1632994078056-1d0b44a7-e1ec-4a61-b1f4-7357293c0a0a.png#clientId=uc78e1191-c90c-4&amp;from=paste&amp;height=431&amp;id=u441c7a4d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=861&amp;originWidth=803&amp;originalType=binary&amp;ratio=1&amp;size=307491&amp;status=done&amp;style=none&amp;taskId=u5a1795f8-b0dd-45e6-bbb3-ffcafc2e65e&amp;width=401.5" alt="image.png"></p>
<h3 id="2-阻塞状态"><a href="#2-阻塞状态" class="headerlink" title="2. 阻塞状态"></a>2. 阻塞状态</h3><p>Blocked、Waiting、TimedWaiting</p>
<h2 id="5-Thread-类和-Object-类线程方法详解"><a href="#5-Thread-类和-Object-类线程方法详解" class="headerlink" title="5. Thread 类和 Object 类线程方法详解"></a>5. Thread 类和 Object 类线程方法详解</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633157925874-a5caca19-3c10-41d3-b92f-393282718634.png#clientId=ud9dfac8a-0ab2-4&amp;from=paste&amp;height=388&amp;id=u2fd4f1a0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=775&amp;originWidth=1590&amp;originalType=binary&amp;ratio=1&amp;size=962383&amp;status=done&amp;style=none&amp;taskId=u92fdbb0c-ee29-4830-89c4-fdac321aa81&amp;width=795" alt="image.png"></p>
<h3 id="1-wait、notify、notifyAll-方法详解"><a href="#1-wait、notify、notifyAll-方法详解" class="headerlink" title="1. wait、notify、notifyAll 方法详解"></a>1. wait、notify、notifyAll 方法详解</h3><ol>
<li>阻塞阶段</li>
</ol>
<p>执行 wait 方法进入阻塞阶段</p>
<p>唤醒方法</p>
<ul>
<li>其他线程调用 notify 方法刚好唤醒阻塞线程</li>
<li>调用 notifyAll 唤醒所有阻塞线程</li>
<li>过了超时时间，自动唤醒</li>
<li>线程自身调用 interupt 方法</li>
</ul>
<p>​</p>
<ol start="2">
<li>唤醒阶段</li>
</ol>
<p>通过调用 notify 或者 notifyAll 方法<br>​</p>
<ol start="3">
<li>遇到中断</li>
</ol>
<h3 id="2-wait、notify、notifyAll-特点和性质"><a href="#2-wait、notify、notifyAll-特点和性质" class="headerlink" title="2. wait、notify、notifyAll 特点和性质"></a>2. wait、notify、notifyAll 特点和性质</h3><ul>
<li>调用 wait 方法之前必须要拥有 monitor</li>
<li>notify 只能唤醒其中一个</li>
<li>都属于 object 类</li>
</ul>
<h3 id="3-wait-原理"><a href="#3-wait-原理" class="headerlink" title="3. wait 原理"></a>3. wait 原理</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633185389200-d6496003-0e72-419a-ada9-11f03a0eadd2.png#clientId=ud9dfac8a-0ab2-4&amp;from=paste&amp;height=347&amp;id=u54b8a244&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=693&amp;originWidth=739&amp;originalType=binary&amp;ratio=1&amp;size=390644&amp;status=done&amp;style=none&amp;taskId=u8858d183-b105-4207-a257-d1802c0f057&amp;width=369.5" alt="image.png"></p>
<ol>
<li>线程进入线程节点集</li>
<li>线程节点集中的节点尝试获取锁</li>
<li>调用 wait 方法释放锁进入等待集</li>
<li>等待集中的线程等待其他线程调用 notify、notifyAll 方法将线程唤醒（线程由等待状态转为 Blocked）</li>
<li>重新唤醒的线程尝试重新获取锁</li>
<li>释放锁并退出</li>
</ol>
<h3 id="4-join-方法"><a href="#4-join-方法" class="headerlink" title="4. join 方法"></a>4. join 方法</h3><ol>
<li>作用</li>
</ol>
<p>因为新的线程要加入我们，所以我们等他执行完再执行</p>
<ol start="2">
<li>用法</li>
</ol>
<p>主线程等待需要加入的线程执行完毕<br>​</p>
<p>​</p>
<h2 id="6-线程未被捕获异常"><a href="#6-线程未被捕获异常" class="headerlink" title="6. 线程未被捕获异常"></a>6. 线程未被捕获异常</h2><h3 id="1-异常处理器解决方法"><a href="#1-异常处理器解决方法" class="headerlink" title="1. 异常处理器解决方法"></a>1. 异常处理器解决方法</h3><ol>
<li>在 run 方法中捕获异常并处理</li>
<li>实现 UncaughtExceptionHandler 接口</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633315130302-db04aac5-f7b3-47cd-a64d-27568b1185d0.png#clientId=u23d15eed-d2bc-4&amp;from=paste&amp;height=165&amp;id=u7bb4f8b8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=330&amp;originWidth=789&amp;originalType=binary&amp;ratio=1&amp;size=49802&amp;status=done&amp;style=none&amp;taskId=udbf3fc47-8b17-486c-a35f-833cd6c5e81&amp;width=394.5" alt="image.png"></p>
<p>源码解析<br>​</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>{</span><br><span class="line">    <span class="comment">//判断线程是否存在父线程的异常处理器</span></span><br><span class="line">       <span class="keyword">if</span> (parent != <span class="keyword">null</span>) {</span><br><span class="line">           parent.uncaughtException(t, e);</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">           <span class="comment">//获取线程默认异常处理器</span></span><br><span class="line">           Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">               Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">           <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) {</span><br><span class="line">              <span class="comment">//调用线程默认异常处理器</span></span><br><span class="line">               ueh.uncaughtException(t, e);</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) {</span><br><span class="line">               <span class="comment">//没有直接打印异常</span></span><br><span class="line">               System.err.print(<span class="string">"Exception in thread \""</span></span><br><span class="line">                                + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">               e.printStackTrace(System.err);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-自定义异常处理器"><a href="#2-自定义异常处理器" class="headerlink" title="2. 自定义异常处理器"></a>2. 自定义异常处理器</h3><ol>
<li>实现 Thread.UncaughtExceptionHandler 的 uncaught 方法</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>{</span><br><span class="line">        Logger logger=Logger.getAnonymousLogger();</span><br><span class="line">        logger.log(Level.WARNING,<span class="string">"自定义异常处理器"</span>+t.getName(),e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>设置线程异常处理器</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseOwnUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseOwnUncaughtExceptionHandler());</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseOwnUncaughtExceptionHandler());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseOwnUncaughtExceptionHandler());</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="7-线程安全"><a href="#7-线程安全" class="headerlink" title="7. 线程安全"></a>7. 线程安全</h2><h3 id="1-什么是线程安全"><a href="#1-什么是线程安全" class="headerlink" title="1. 什么是线程安全"></a>1. 什么是线程安全</h3><p><strong>多个线程访问某个对象或方法时，在编写方法或对象的业务逻辑时，不需要做额外的处理（可以像单线程编程一样），程序可以正常运行（不会因为多线程而出错）</strong><br><strong>​</strong></p>
<h3 id="2-线程安全问题"><a href="#2-线程安全问题" class="headerlink" title="2. 线程安全问题"></a>2. 线程安全问题</h3><ol>
<li>运行结果错误：a++多线程问题</li>
<li>活跃性问题：死锁、活锁、饥饿</li>
<li>对象发布和初始化安全问题</li>
</ol>
<p><strong>​</strong></p>
<h2 id="8-死锁"><a href="#8-死锁" class="headerlink" title="8. 死锁"></a>8. 死锁</h2><h3 id="1-死锁概念"><a href="#1-死锁概念" class="headerlink" title="1. 死锁概念"></a>1. 死锁概念</h3><p>特点</p>
<ul>
<li>发生在并发中</li>
<li>互不相让</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633750091741-d8a67152-fa3d-4dc5-9ae7-e7092e9bbd04.png#clientId=u71005f6c-83ec-4&amp;from=paste&amp;height=301&amp;id=uf260c5fc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=602&amp;originWidth=1298&amp;originalType=binary&amp;ratio=1&amp;size=98661&amp;status=done&amp;style=none&amp;taskId=ubca3f96e-a8ce-4c24-806c-6610f5939f4&amp;width=649" alt="image.png"></p>
<h3 id="2-死锁事例"><a href="#2-死锁事例" class="headerlink" title="2. 死锁事例"></a>2. 死锁事例</h3><ol>
<li>两个用户转账</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/10/9</span></span><br><span class="line"><span class="comment"> * 转账时遇到死锁情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoney</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Account from = <span class="keyword">new</span> Account(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">static</span> Account to = <span class="keyword">new</span> Account(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        TransferMoney user1 = <span class="keyword">new</span> TransferMoney();</span><br><span class="line">        TransferMoney user2 = <span class="keyword">new</span> TransferMoney();</span><br><span class="line">        user1.flag = <span class="number">0</span>;</span><br><span class="line">        user2.flag = <span class="number">1</span>;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(user1);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(user2);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        thread1.join();</span><br><span class="line">        System.out.println(from.balance);</span><br><span class="line">        System.out.println(to.balance);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) {</span><br><span class="line">            transferMoney(from, to, <span class="number">200</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) {</span><br><span class="line">            transferMoney(to, from, <span class="number">200</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account from, Account to, <span class="keyword">int</span> account)</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (from) {</span><br><span class="line">            <span class="keyword">synchronized</span> (to) {</span><br><span class="line">                <span class="keyword">if</span> (from.balance - account &lt; <span class="number">0</span>) {</span><br><span class="line">                    System.out.println(from + <span class="string">"转账用户余额不足"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                from.balance -= account;</span><br><span class="line">                to.balance += account;</span><br><span class="line">                System.out.println(from + <span class="string">"转账成功"</span> + account + <span class="string">"元"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>{</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.balance = balance;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>多个用户转账</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/10/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiTransferMoney</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账户数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMS_ACCOUNT = <span class="number">500</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账户初始化金额数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMS_MONEY = <span class="number">10000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMS_TRANSFERS = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_THREDS = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Random rdm = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TransferMoney.Account[] accounts = <span class="keyword">new</span> TransferMoney.Account[NUMS_ACCOUNT];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMS_ACCOUNT; i++) {</span><br><span class="line">            accounts[i] = <span class="keyword">new</span> TransferMoney.Account(NUMS_MONEY);</span><br><span class="line">        }</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREDS; i++) {</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> TransferMoneyThread());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoneyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMS_TRANSFERS; i++) {</span><br><span class="line">                <span class="keyword">int</span> accountFromIndex;</span><br><span class="line">                <span class="keyword">int</span> accountToIndex;</span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    accountFromIndex = rdm.nextInt(NUMS_ACCOUNT);</span><br><span class="line">                    accountToIndex = rdm.nextInt(NUMS_ACCOUNT);</span><br><span class="line">                } <span class="keyword">while</span> (accountFromIndex == accountToIndex);</span><br><span class="line">                <span class="keyword">int</span> money = rdm.nextInt(NUMS_MONEY);</span><br><span class="line">                TransferMoney.transferMoney(accounts[accountFromIndex], accounts[accountToIndex], money);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"转账结束"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-死锁条件"><a href="#3-死锁条件" class="headerlink" title="3. 死锁条件"></a>3. 死锁条件</h3><ol>
<li>**互斥条件 **</li>
<li><strong>请求与保持条件</strong></li>
<li><strong>不剥夺条件</strong></li>
<li><strong>循环等待条件</strong></li>
</ol>
<h3 id="4-定位死锁"><a href="#4-定位死锁" class="headerlink" title="4. 定位死锁"></a>4. 定位死锁</h3><h4 id="1-Jstack"><a href="#1-Jstack" class="headerlink" title="1. Jstack"></a>1. Jstack</h4><ol>
<li>通过 jps 获取 Java 运行程序的 pid</li>
<li>通过 jstack pid 查看对应程序的死锁情况</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">J:\JavaBase\cocurrency_tools_practice&gt;jps</span><br><span class="line">16672 TransferMoney</span><br><span class="line">17784</span><br><span class="line">19592 Jps</span><br><span class="line">4236 Launcher</span><br><span class="line"></span><br><span class="line">J:\JavaBase\cocurrency_tools_practice&gt;jstack 16672</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-修复死锁"><a href="#5-修复死锁" class="headerlink" title="5. 修复死锁"></a>5. 修复死锁</h3><h3 id="1-避免策略"><a href="#1-避免策略" class="headerlink" title="1. 避免策略"></a>1. 避免策略</h3><h1 id="2-并发高级"><a href="#2-并发高级" class="headerlink" title="2. 并发高级"></a>2. 并发高级</h1><h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><h3 id="1-线程池的停止"><a href="#1-线程池的停止" class="headerlink" title="1. 线程池的停止"></a>1. 线程池的停止</h3><ol>
<li>shutdown** 关闭线程池，但是线程池需要正在执行的任务和队列中的任务执行完之后关闭**</li>
<li>shutdownNow 立刻关闭线程池，并返回任务队列中的任务。同时中断正在执行的任务</li>
<li>isShutdown 判断线程是否关闭</li>
<li>isTerminated 判断线程池是否终止运行</li>
<li>awaitTermination 判断线程池在判断延后的时间范围内线程池是否终止</li>
</ol>
<p>​</p>
<h3 id="2-拒绝策略"><a href="#2-拒绝策略" class="headerlink" title="2. 拒绝策略"></a>2. 拒绝策略</h3><ul>
<li>AbortPolicy 直接抛出异常</li>
<li>DiscardPolicy 直接抛弃任务</li>
<li>DiscardOldestPolicy 直接抛弃执行时间最长的任务</li>
<li>CallerRunsPolicy 直接返回给调用者</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h3><h4 id="1-组成部分"><a href="#1-组成部分" class="headerlink" title="1. 组成部分"></a>1. 组成部分</h4><ul>
<li>线程池管理器</li>
<li>工作线程</li>
<li>任务队列</li>
<li>任务接口</li>
</ul>
<p>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633444509426-74410e03-652a-40bb-98dd-0dedffb69f41.png#clientId=u23d15eed-d2bc-4&amp;from=paste&amp;height=276&amp;id=u332b0768&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=551&amp;originWidth=909&amp;originalType=binary&amp;ratio=1&amp;size=125603&amp;status=done&amp;style=none&amp;taskId=u9bf42bec-bf47-4811-bca8-b174bdd8f30&amp;width=454.5" alt="image.png"></p>
<p><strong>线程池架构图</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633444552891-52b344e1-6a04-43cd-adc0-bca35a432040.png#clientId=u23d15eed-d2bc-4&amp;from=paste&amp;height=213&amp;id=u2e1fbaed&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=425&amp;originWidth=623&amp;originalType=binary&amp;ratio=1&amp;size=63702&amp;status=done&amp;style=none&amp;taskId=u366f33eb-8333-4327-b1f0-d1db3fe43f4&amp;width=311.5" alt="image.png"></p>
<ul>
<li>Executor 线程池顶级接口</li>
<li>ExecutorService 线程池业务接口</li>
</ul>
<p>​</p>
<p><strong>线程池任务复用原理</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      	<span class="comment">//获取线程池状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        }</span><br><span class="line">      <span class="comment">//判断线程池状态以及任务队列是否满了</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) {</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"> <span class="comment">//调用addWorker创建新的工作线程</span></span><br><span class="line">   <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) {</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) {</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后调用runWorker执行当前线程的任务</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>{</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) {</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        task.run();</span><br><span class="line">                    } <span class="keyword">catch</span> (RuntimeException x) {</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    } <span class="keyword">catch</span> (Error x) {</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    } <span class="keyword">catch</span> (Throwable x) {</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    } <span class="keyword">finally</span> {</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p><strong>线程池状态</strong></p>
<ul>
<li>Running 接受新任务并排队处理任务</li>
<li>Shutdown 不接受新任务，但处理正在运行任务</li>
<li>Stop 不接受新任务 ，也不处理队列任务，并中断正在运行任务</li>
<li>Tidying 所有任务都终止，所有工作线程为 0 并接下来执行 terminated（）钩子方法</li>
<li>Terminated 运行完成</li>
</ul>
<h2 id="2-ThreadLocal"><a href="#2-ThreadLocal" class="headerlink" title="2. ThreadLocal"></a>2. ThreadLocal</h2><h3 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1. 使用场景"></a>1. 使用场景</h3><p>​</p>
<ol>
<li>每个线程需要一个独享的对象（工具类对象 SimpleDateFormat 和 Random）</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> threadlocal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.SimpleFormatter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/10/4</span></span><br><span class="line"><span class="comment"> * ThreadLocal 存放工日期格式化具类对象</span></span><br><span class="line"><span class="comment"> * 每个线程都需要存放一个独享的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreadLocalNormalUsage</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String &gt; dateSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">100</span>, <span class="number">100</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            poolExecutor.execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    dateParse(finalI);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dateParse</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">                    Date date = <span class="keyword">new</span> Date(<span class="number">1000</span> * i);</span><br><span class="line">                    SimpleDateFormat dateFormat = ThreadLocalDateFormatter.dateFormatThreadLocal.get();</span><br><span class="line">                    dateSet.add(dateFormat.format(date));</span><br><span class="line">                    System.out.println(dateFormat.format(date));</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(dateSet.size());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDateFormatter</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal =</span><br><span class="line">            ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>每个线程内需要保存全局变量，可以不同方法直接使用，避免传递参数的麻烦</li>
</ol>
<h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><ol>
<li>多线程，对象数据数据隔离</li>
<li>多线程下，轻松获取获取全局变量</li>
</ol>
<p>​</p>
<h3 id="3-好处"><a href="#3-好处" class="headerlink" title="3. 好处"></a>3. 好处</h3><ul>
<li>线程安全</li>
<li>不需要加锁，提高效率</li>
<li>线程池的情况下，节省内存开销</li>
<li>免去多线程情况下传参麻烦</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="3-原理-、源码分析"><a href="#3-原理-、源码分析" class="headerlink" title="3. 原理 、源码分析"></a>3. 原理 、源码分析</h3><p><strong>主要方法</strong><br>​</p>
<ol>
<li><strong>initialValue()</strong></li>
</ol>
<ul>
<li>返回当前线程对应的初始值，延迟加载只有第一次调用 get 时候才会触发。</li>
<li>当线程先前调用了 set()，则不会调用 initialValue()方法</li>
<li>线程最多只能调用一次该方法，除非调用 remove()删除了对应的数据，在调用 get</li>
<li>不重写默认返回 null</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前线程的ThreadLocalMap</span></span><br><span class="line">     ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//如果对应的map不为空</span></span><br><span class="line">     <span class="keyword">if</span> (map != <span class="keyword">null</span>) {</span><br><span class="line">         <span class="comment">//通过map获取对应的值</span></span><br><span class="line">         ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) {</span><br><span class="line">             <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">             T result = (T)e.value;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line">    <span class="comment">//反之则调用初始化方法</span></span><br><span class="line">     <span class="keyword">return</span> setInitialValue();</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p><strong>​</strong></p>
<p><strong>​</strong></p>
<ol start="2">
<li><strong>set()</strong></li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>{</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>ThreadLocalMap 类</strong><br><strong>​</strong></p>
<p><strong>键：ThreadLocal 对象</strong><br><strong>值：存储对应的值</strong><br><strong>​</strong></p>
<p><strong>ThreadLocal 哈希冲突解决办法：线性探测法（发生冲突判断下一个位置是否为空）</strong><br><strong>​</strong></p>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<h3 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4. 注意点"></a>4. 注意点</h3><ul>
<li><strong>内存泄漏问题</strong>（对象不在使用，但却无法回收）</li>
</ul>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="3-AQS"><a href="#3-AQS" class="headerlink" title="3. AQS"></a>3. AQS</h2><h3 id="1-原理解析"><a href="#1-原理解析" class="headerlink" title="1. 原理解析"></a>1. 原理解析</h3><h4 id="1-State-状态"><a href="#1-State-状态" class="headerlink" title="1. State 状态"></a>1. State 状态</h4><p>在不同的并发类中有不同的含义<br>Semaphore 剩余许可证的数量<br>CountDownLatch 需要倒数的数量<br>ReentrantLock 表示可重入锁的次数 当 state 表示锁不被任何线程持有</p>
<h4 id="2-FIFO-队列"><a href="#2-FIFO-队列" class="headerlink" title="2.FIFO 队列"></a>2.FIFO 队列</h4><ul>
<li>存放等待线程的双向队列</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633511736158-4641796b-4219-464d-af3b-079fff214722.png#clientId=u8f654df0-be2a-4&amp;from=paste&amp;height=89&amp;id=uab7d1c76&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=178&amp;originWidth=897&amp;originalType=binary&amp;ratio=1&amp;size=82969&amp;status=done&amp;style=none&amp;taskId=u6d281669-be18-4155-9118-8281cc4ac50&amp;width=448.5" alt="image.png"></p>
<h4 id="3-工具类实现的获取-释放方法"><a href="#3-工具类实现的获取-释放方法" class="headerlink" title="3. 工具类实现的获取/释放方法"></a>3. 工具类实现的获取/释放方法</h4><ol>
<li>获取方法（<strong>导致线程阻塞</strong>）</li>
</ol>
<ul>
<li>ReentrantLock 判断 state 是否为 0，如果不为为 0 则会阻塞</li>
<li>Semaphore 通过 acquire 方法获取到 state,判断 state 是否为正数，是则 state-1 可以获取一个许可证</li>
<li>CountDownLatch 通过 await 获取 state，判断是否等于 0，如果为 0 则唤醒，反之阻塞</li>
</ul>
<p>​</p>
<p>​</p>
<ol start="2">
<li>释放方法</li>
</ol>
<ul>
<li>Semaphore 通过使用 release 方法使 state+1</li>
<li>CountDownLatch countDown 方法</li>
</ul>
<p>​</p>
<p>​</p>
<p>​</p>
<h4 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4. 源码分析"></a>4. 源码分析</h4><h5 id="1-CountDownLatch-源码分析"><a href="#1-CountDownLatch-源码分析" class="headerlink" title="1. CountDownLatch 源码分析"></a>1. CountDownLatch 源码分析</h5><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633512858997-9e24ac55-ed62-41b7-a171-c921b56cec76.png#clientId=u8f654df0-be2a-4&amp;from=paste&amp;height=119&amp;id=uabb32415&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=237&amp;originWidth=672&amp;originalType=binary&amp;ratio=1&amp;size=49318&amp;status=done&amp;style=none&amp;taskId=ue0c7eba3-0a06-47bf-9d14-b1c1925f2f9&amp;width=336" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633573965910-d310e60f-33ca-4d66-be34-7e47a28dd28c.png#clientId=u5713b59d-1bde-4&amp;from=paste&amp;height=303&amp;id=u0979f993&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=605&amp;originWidth=917&amp;originalType=binary&amp;ratio=1&amp;size=221272&amp;status=done&amp;style=none&amp;taskId=u1e32547a-e975-4d63-bd2b-a1a588f6639&amp;width=458.5" alt="image.png"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>{</span><br><span class="line">       <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">       <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">   }</span><br><span class="line"> 		Sync(<span class="keyword">int</span> count) {</span><br><span class="line">           setState(count);</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>{</span><br><span class="line">       state = newState;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>{</span><br><span class="line">           <span class="keyword">return</span> getState();</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程等待直到倒数结束</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">       sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">   }</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">       <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">     <span class="comment">//判断是否倒数结束</span></span><br><span class="line">       <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">           doAcquireSharedInterruptibly(arg);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">     <span class="comment">//将线程包装成一个node节点然后放入队列然后中断该线程</span></span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           <span class="keyword">for</span> (;;) {</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head) {</span><br><span class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) {</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           }</span><br><span class="line">       } <span class="keyword">finally</span> {</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-Semaphore-源码分析"><a href="#2-Semaphore-源码分析" class="headerlink" title="2. Semaphore 源码分析"></a>2. Semaphore 源码分析</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">	<span class="comment">//获取资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) {</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="comment">//如果state大于0则将线程放入阻塞队列</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) {</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">//公平锁的方式获取资源state</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//非公平锁的方式获取资源state</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3. ReentrantLock"></a>3. ReentrantLock</h5><p>​</p>
<p><strong>释放锁</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尝试释放当前线程的锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>{</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">//判断当前线程是否持有锁</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    		<span class="comment">//判断state是否为0</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            }</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<p>流程：<br>判断当前锁对应的线程是不是该线程如果是直接 state-1,不是抛出异常，减到 0 就返回 true。并且释放当前线程的锁</p>
<p><strong>加锁方法</strong><br><strong>​</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        sync.lock();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//非公平加锁的实现</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="comment">//通过cas判断其他线程是否持有锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//尝试获取锁</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="comment">//判断锁是否被持有</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">         <span class="comment">//判断锁的线程和当前线程是否是同一线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//公平锁加锁</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-实现简化版-ConuntDownLatch"><a href="#2-实现简化版-ConuntDownLatch" class="headerlink" title="2. 实现简化版 ConuntDownLatch"></a>2. 实现简化版 ConuntDownLatch</h3><p>步骤：</p>
<ol>
<li>创建一个类，实现获取/释放的方法</li>
<li>写一个内部类 Sync 继承 AbstractQueuedSynchronizer</li>
<li>根据锁是否独占来重写 tryAcquire/tryRelease 或 tryAcquireShared 和 tryReleaseShared 等方法</li>
</ol>
<p>​</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> aqs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/10/7</span></span><br><span class="line"><span class="comment"> * 自定义一次性门闩</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneShortLatch</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>{</span><br><span class="line">        sync.releaseShared(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>{</span><br><span class="line">        sync.acquireShared(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">            setState(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        OneShortLatch oneShortLatch = <span class="keyword">new</span> OneShortLatch();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"尝试获取latch"</span>);</span><br><span class="line">                oneShortLatch.await();</span><br><span class="line">                System.out.println(<span class="string">"门闩调用了放行方法"</span>);</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        oneShortLatch.signal();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>​</p>
</body></html>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>Java高级</tag>
      </tags>
  </entry>
</search>
