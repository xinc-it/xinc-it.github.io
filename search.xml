<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mysql-更新语句的执行</title>
    <url>/2022/11/06/2!%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<html><head></head><body><h2 id="1-更新语句执行流程"><a href="#1-更新语句执行流程" class="headerlink" title="1. 更新语句执行流程"></a>1. 更新语句执行流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630974533552-29681b12-3ee4-4012-ae23-882ab740984d.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=337&amp;id=u6f547220&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=674&amp;originWidth=928&amp;originalType=binary&amp;ratio=1&amp;size=239274&amp;status=done&amp;style=none&amp;taskId=u902b2c56-0159-4ac1-9ecc-7c0453d9054&amp;width=464" alt="image.png"></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; update T <span class="built_in">set</span> c=c+1 <span class="built_in">where</span> ID=2;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>客户端通过连接器连接 MySQL 服务器</li>
<li>将缓存中相关表的结果清空</li>
<li>分析器通过词法和语法分析判断是更新语句</li>
<li>优化器通过索引，决定使用 ID 的索引</li>
<li>执行器执行更新语句</li>
<li>进行 redo log 和 bin log 的修改</li>
</ol>
<p>​</p>
<h2 id="2-Redo-log-引擎日志"><a href="#2-Redo-log-引擎日志" class="headerlink" title="2.Redo log(引擎日志)"></a>2.Redo log(引擎日志)</h2><p>情景老板记账：先把借帐和还账记录写在黑板上，空闲时，再把黑板上账的写入到账本中。</p>
<p>作用： 用作数据库写入将数据磁盘的缓存，防止每次更新都要将数据写进磁盘，提高了更新效率。<br>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630975170760-0904cfb2-ee0b-4650-a584-bb831be94070.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=328&amp;id=u5e5e1dba&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=655&amp;originWidth=943&amp;originalType=binary&amp;ratio=1&amp;size=104067&amp;status=done&amp;style=none&amp;taskId=u353c490e-0715-407a-9113-50af777809c&amp;width=471.5" alt="image.png"><br>​</p>
<p>​</p>
<p>​</p>
<h3 id="1-WAL-Write-Ahead-Logging"><a href="#1-WAL-Write-Ahead-Logging" class="headerlink" title="1. WAL (Write-Ahead Logging)"></a>1. WAL (Write-Ahead Logging)</h3><p><strong>先写日志，再写磁盘</strong>。<br>InnoDB 引擎会把记录写道 redo log 中，并更新内存。然后更新就算完成。引擎会在空闲时间操作记录<br>写入磁盘。<br>如果 redo log 写满了，会把一部分记录更新到磁盘中。<br>通过 write pos 和 check point 两个指针来判断日志是否写满</p>
<h3 id="2-crash-safe"><a href="#2-crash-safe" class="headerlink" title="2. crash-safe"></a>2. crash-safe</h3><p>当数据库发生异常时，可以通过 redo log 可以获取到之前的提交记录。<br>通过提交记录可以将未同步到数据库中数据同步到数据库中。<br>​</p>
<p><strong>redo log 存储的是物理变更日志，用于记录磁盘中指定地方的数值修改记录。</strong><br>​</p>
<p>​</p>
<h3 id="3-特点"><a href="#3-特点" class="headerlink" title="3. 特点"></a>3. 特点</h3><p>​</p>
<ol>
<li> 存储的物理日志（记录的是数据页上数据的更改）</li>
<li> 先写日志，后写磁盘</li>
<li> 可以 crash safe 进行数据的修复</li>
<li> InnoDB 引擎层日志</li>
<li> 空间有限会用完，通过队列的实现循环写</li>
</ol>
<h2 id="3-binlog（Server-层日志）"><a href="#3-binlog（Server-层日志）" class="headerlink" title="3. binlog（Server 层日志）"></a>3. binlog（Server 层日志）</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><ol>
<li>服务层日志</li>
<li>存储的内容是逻辑日志（记录的是语句的原始逻辑）</li>
<li>空间无限，通过新增文件实现追加写</li>
</ol>
<h2 id="4-执行流程"><a href="#4-执行流程" class="headerlink" title="4. 执行流程"></a>4. 执行流程</h2><ol>
<li>执行引擎先找到 ID=2 的这一行数据，如果内存中存在直接返回给执行器，否则从磁盘读入内存然后返回给执行器</li>
<li>把值加上 1，然后调用引擎接口写入数据</li>
<li>引擎会将新数据更新到内存中，同时更新到 redo log 中。redo log 处于 prepare 状态，告诉执行器完成了，可以提交事务了。</li>
<li>执行器生成更新操作的 bin log,并把 bin log 写入磁盘</li>
<li>执行器调用引擎的事务接口，将写入的 redo log 改成 commit 状态</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634976756709-8dbcb97a-235f-4b93-a181-f46a29389d94.png#clientId=u359acdfd-faff-4&amp;from=paste&amp;height=525&amp;id=u4d800135&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1050&amp;originWidth=686&amp;originalType=binary&amp;ratio=1&amp;size=168644&amp;status=done&amp;style=none&amp;taskId=u39624d17-5f0a-4d9a-931c-683c5152009&amp;width=343" alt="image.png"></p>
<h2 id="5-两阶段提交"><a href="#5-两阶段提交" class="headerlink" title="5. 两阶段提交"></a>5. 两阶段提交</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630988222445-a6208d34-24c4-4e8d-89b2-8952bbb46186.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=198&amp;id=u6943ccfd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=396&amp;originWidth=651&amp;originalType=binary&amp;ratio=1&amp;size=113756&amp;status=done&amp;style=none&amp;taskId=udaf78fe9-6800-4ea4-af49-47d717da835&amp;width=325.5" alt="image.png"></p>
<p><strong>​</strong></p>
<p><strong>原因</strong></p>
<ol>
<li>如果发生 crash 导致系统崩溃的话，如果顺序不一致，可能导致之后无法通过 binlog 恢复到任一时刻的数据</li>
<li>可能导致 binlog 和 redo log 的数据不一致导致数据冲突。</li>
</ol>
<h2 id="6-两种日志的不同点"><a href="#6-两种日志的不同点" class="headerlink" title="6. 两种日志的不同点"></a>6. 两种日志的不同点</h2><ol>
<li>redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的</li>
<li>redo log 是物理日志，记录的是 <strong>在某个数据页上做了修改</strong>，binlog 是逻辑日志记录的是语句逻辑 <strong>给 ID=2 的数据进行加 1</strong></li>
<li>redo log 是循环写，空间大小固定。bin log 是追加写，当 bin log 文件到达一定大小后会切换到下一个，不会覆盖以前的日志</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><ol>
<li>更新语句的执行流程</li>
<li>Redo log 的作用是用来存储 MySQL 产生更新语句的物理日志。通过 WAL 技术先将日志写入 队列中然偶后通过指定条件写入磁盘中</li>
<li>bin log 的作用和特点</li>
<li>两种日志的不同点</li>
<li>两阶段提交的作用<ol>
<li>保证数据库的数据不冲突</li>
</ol>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-事务隔离</title>
    <url>/2022/11/07/3!%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<html><head></head><body><h2 id="1-隔离性和隔离级别"><a href="#1-隔离性和隔离级别" class="headerlink" title="1. 隔离性和隔离级别"></a>1. 隔离性和隔离级别</h2><h3 id="1-事务特性"><a href="#1-事务特性" class="headerlink" title="1. 事务特性"></a>1. 事务特性</h3><ol>
<li><strong>原子性</strong></li>
<li><strong>持久性</strong></li>
<li><strong>隔离性</strong></li>
<li><strong>一致性</strong></li>
</ol>
<h3 id="2-事务隔离级别"><a href="#2-事务隔离级别" class="headerlink" title="2. 事务隔离级别"></a>2. 事务隔离级别</h3><ol>
<li><strong>读已提交（事务未提交时，变更能被其它事务看到）</strong></li>
<li><strong>读未提交（事务提交后，其它事务才能看到变更）</strong></li>
<li><strong>可重复读（一个事务执行过程中，总是跟启动时看到的数据是一致的。未提交的变更对其它事务不可见）</strong></li>
<li><strong>串行化（同一行记录写会加写锁，读会读锁。当出现读写锁冲突时，后访问的事务，必须等前一个事务完成，才能执行）</strong></li>
</ol>
<p><strong>​</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1630988923063-4d56a761-7637-488b-951d-c443de806cb1.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=381&amp;id=uf414196c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=762&amp;originWidth=788&amp;originalType=binary&amp;ratio=1&amp;size=201874&amp;status=done&amp;style=none&amp;taskId=u19543944-dee4-4fbf-bf51-efae564dfae&amp;width=394" alt="image.png"></p>
<p>v1=v2=1,v3=2<br>四种事务得到的结果</p>
<ol>
<li>读未提交： v1、v2、v3=2</li>
<li>读已提交: v1=1 ，v2、v3=2</li>
<li>可重复读：v1=v2=1，v3=2</li>
<li>可串行化 ： v1=v2=1,v3=2</li>
</ol>
<p><strong>​</strong></p>
<p>​</p>
<h2 id="2-事务隔离的实现"><a href="#2-事务隔离的实现" class="headerlink" title="2. 事务隔离的实现"></a>2. 事务隔离的实现</h2><p>当一个值从 1 按顺序变成 2，3，3 那么他的日志里面就会有类似的回滚段记录<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631013980123-b4f659d1-a49a-4d6f-bffa-5c049fb7a4b5.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=259&amp;id=u4bd92b33&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=517&amp;originWidth=906&amp;originalType=binary&amp;ratio=1&amp;size=104426&amp;status=done&amp;style=none&amp;taskId=ub4313c28-1bd9-45bf-a56d-abe4cf1987a&amp;width=453" alt="image.png"><br>如图事务 A、B、C 修改记录导致一个字段对应多个值。<br>​</p>
<p>通过 MVCC 来实现一个数据的多个版本，通过 undo log 实现数据版本的回滚<br>通过 MVCC 和 undo log 来实现事务的隔离<br>具体可以参考</p>
<p><a href="https://www.yuque.com/sanxingalaxys9/gwxct1/lq01qk?view=doc_embed">Mysql 实战 45 讲</a></p>
<p>当回滚段日志过长时，系统会自动清除。<br>​</p>
<p>​</p>
<p>​</p>
<h2 id="3-事务的启动方式"><a href="#3-事务的启动方式" class="headerlink" title="3. 事务的启动方式"></a>3. 事务的启动方式</h2><ol>
<li>set autocommit=0 关闭自动提交，只要执行 select 语句自动开启事务</li>
<li>begin 或是 start transaction</li>
</ol>
<p>​</p>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><ol>
<li>四大特性和隔离级别</li>
<li>事务隔离的实现（通过 MVCC 和 undo log)</li>
<li>事务的启动方式<ol>
<li>自动启动 select 语句执行时自动启动</li>
<li>手动启动 begin、 start transaction</li>
</ol>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-锁</title>
    <url>/2021/11/10/5!%E9%94%81/</url>
    <content><![CDATA[<html><head></head><body><h2 id="1-锁的分类："><a href="#1-锁的分类：" class="headerlink" title="1. 锁的分类："></a>1. 锁的分类：</h2><p><strong>根据加锁范围：</strong></p>
<ol>
<li><strong>全局锁</strong></li>
<li><strong>表级锁</strong></li>
<li><strong>行锁</strong></li>
</ol>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<h2 id="2-全局锁"><a href="#2-全局锁" class="headerlink" title="2. 全局锁"></a>2. 全局锁</h2><p>全局读锁命令<br><strong>全局锁就是对整个数据库实例加锁，Mysql 提供了一个加全局读锁的命令。可以让整个数据库处于只读状态。</strong><br>导致数据的增删改、建表修改表语句、事务的提交语句失效。</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></tbody></table></figure>

<p>场景：<strong>全库的逻辑备份(也可以开启可重复读事务级别来进行备份)</strong><br>另一种方式是使用 mysqldump 工具使用参数-single-transaction 进行数据库备份。前提：数据库中所有的表支持可重复读。<br>​</p>
<p>​</p>
<p>场景：用户买课和买课后的余额。不加锁导致两个表的数据前后不一致。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631018821575-900c6793-130c-47c3-8b6c-b3533bf27c70.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=271&amp;id=u5e04065e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=542&amp;originWidth=882&amp;originalType=binary&amp;ratio=1&amp;size=204494&amp;status=done&amp;style=none&amp;taskId=uadb7ab82-ba93-48d1-a88f-e117005dcaf&amp;width=441" alt="image.png"></p>
<h2 id="3-表级锁"><a href="#3-表级锁" class="headerlink" title="3. 表级锁"></a>3. 表级锁</h2><ol>
<li>两种表锁</li>
</ol>
<p>​</p>
<ul>
<li>表锁</li>
<li>元数据锁</li>
</ul>
<p>​</p>
<p>​</p>
<p>​</p>
<ol start="2">
<li>表锁</li>
</ol>
<p>​</p>
<p>作用：<strong>锁定表只能进行读或读和写操作。不允许操作其他表。（处理并发的常用方式）</strong></p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">lock tables t1 read, t2 write;</span><br></pre></td></tr></tbody></table></figure>

<p>​</p>
<p>只能对 t1 表进行读，t2 表进行读和写。直到执行<strong>unlock tables</strong>之前不允许对其他表进行读写操作。<br>​</p>
<p>​</p>
<ol start="3">
<li>MDL ( meatadata lock)</li>
</ol>
<p>​</p>
<p>作用：保证读写的正确性。防止 DDL(加字段等修改表结构的操作)和 DML 冲突（增删改数据）<br>特点： 自动加上，不需要使用 sql 语句。在对表进行数据的增删改查操作时加读锁。修改表结构时，加写锁。<br>​</p>
<p>​</p>
<p>读读锁共存、读写锁、写写锁互斥。<br>​</p>
<p><strong>示例</strong><br><strong>​</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634388295266-c5897d57-05ac-4ac9-b910-e2d9950d6f1e.png#clientId=ubaf7a982-8eca-4&amp;from=paste&amp;height=261&amp;id=u0e8aeaeb&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=521&amp;originWidth=834&amp;originalType=binary&amp;ratio=1&amp;size=78640&amp;status=done&amp;style=none&amp;taskId=u2b78eb8a-f57d-433e-935f-d586ac65ede&amp;width=417" alt="image.png"></p>
<p>在多个事务开启且未结束的过程中给某个表添加个字段导致读写锁冲突。<br>​</p>
<p>解决方法<br>在 information_schema 库中 innodb_trx 表中查询出正在执行事务，可以暂停表变更事务、或者是长事务。<br>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><ol>
<li>全局锁主要是用来逻辑备份，有两种方式一种是通过命令 flush tables with read lock;。另一种需要支持库中所有的表支持可重复读事务，使用 mysqldump -single-transaction 进行备份。</li>
</ol>
<p>​</p>
<ol start="2">
<li>表锁通过 sql 语句限制指定表只能进行读、读/写操作,且不允许对其他表操作在解锁前。</li>
</ol>
<p>​</p>
<ol start="3">
<li>MDL 是自动加上的，不需要通过 sql 语句。存在读写锁、写写锁互斥情况。锁在事务提交后释放。作用是为了防止 DDL 和 DML 操作冲突。</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-行锁</title>
    <url>/2022/11/09/4!%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<html><head></head><body><h2 id="1-索引常见模型"><a href="#1-索引常见模型" class="headerlink" title="1.索引常见模型"></a>1.索引常见模型</h2><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631014492663-2fed2cf8-9707-4346-bf90-06ff2a5b0d4e.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=286&amp;id=u7fa963ac&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=572&amp;originWidth=848&amp;originalType=binary&amp;ratio=1&amp;size=173484&amp;status=done&amp;style=none&amp;taskId=u6e8f087d-7794-4326-8ff8-d1cb74fcb50&amp;width=424" alt="image.png"></p>
<p>通过 hash 算法将 key 换算成确定的位置，然后把 value 放入到这个数组的位置。如果数组已经存在值，<br>则通过拉链法，拉出一条链表。<br>​</p>
<p>​</p>
<p>优点：等值查询的情况下查询效率高<br>缺点：范围查询效率低下<br>​</p>
<h3 id="2-有序数组"><a href="#2-有序数组" class="headerlink" title="2. 有序数组"></a>2. 有序数组</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631014718687-07087e14-d4f9-4401-9bbd-bb4dd3a0bce5.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=219&amp;id=u6b2951af&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=437&amp;originWidth=898&amp;originalType=binary&amp;ratio=1&amp;size=108398&amp;status=done&amp;style=none&amp;taskId=uf49d5f91-1a3a-48ac-aca3-80d6aec3ace&amp;width=449" alt="image.png"><br>​</p>
<p>​</p>
<p>​</p>
<p>优点：等值和范围查询效率高<br>缺点：插入、删除数据效率低下<br>​</p>
<p>​</p>
<p>场景：只适用于静态存储引擎<br>​</p>
<p>​</p>
<h3 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3. 二叉搜索树"></a>3. 二叉搜索树</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631014893629-805c3a90-3ccf-4fff-98f4-51ec1671c6df.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=306&amp;id=u38010e60&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=612&amp;originWidth=865&amp;originalType=binary&amp;ratio=1&amp;size=178178&amp;status=done&amp;style=none&amp;taskId=u5614456c-9189-45ca-bfb2-5fbf49f84fc&amp;width=432.5" alt="image.png"></p>
<p>缺点：数据量大的情况下，导致树很高，需要进行多次磁盘读取数据，比较浪费时间。<br>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="2-InnoDB-索引模型"><a href="#2-InnoDB-索引模型" class="headerlink" title="2. InnoDB 索引模型"></a>2. InnoDB 索引模型</h2><p>B+树<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631015176574-c34b7b27-c5cc-4295-8de1-bdb466fe3700.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=226&amp;id=ud6c87e87&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=451&amp;originWidth=847&amp;originalType=binary&amp;ratio=1&amp;size=121005&amp;status=done&amp;style=none&amp;taskId=ue3c7c791-9710-400e-b106-8559a26769a&amp;width=423.5" alt="image.png"></p>
<h2 id="3-主键索引和非主键索引"><a href="#3-主键索引和非主键索引" class="headerlink" title="3. 主键索引和非主键索引"></a>3. 主键索引和非主键索引</h2><p><strong>InnoDB 里面主键索引也被称为聚簇索引</strong><br>​</p>
<p>非主键索引的叶子节点存储的是主键的值<br>​</p>
<p>主键索引和非主键索引的区别</p>
<ol>
<li>主键查询： 只需要查询主键索引的 B+树,查询出对应的数据</li>
<li>非主键索引：查询非主键索引的树，获得对应的主键值，然后通过主键值查询主键索引的 B+树</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="4-索引维护"><a href="#4-索引维护" class="headerlink" title="4. 索引维护"></a>4. 索引维护</h2><p>​</p>
<p>概念： 当数据页中数据存储满了，会生成一个新的数据页，然后原有数据也中的部分数据会移到新的数据也中。这种过程叫做页分裂。<br>​</p>
<p>同理页合并是两个数据页中的数据太少了，合并到一个数据页中。</p>
<p>​</p>
<p>​</p>
<h2 id="5-索引覆盖"><a href="#5-索引覆盖" class="headerlink" title="5. 索引覆盖"></a>5. 索引覆盖</h2><h3 id="1-回表"><a href="#1-回表" class="headerlink" title="1. 回表"></a>1. 回表</h3><p>select * from T where k between 3 and 5<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631016152383-0a030960-b98c-4af0-8eb5-c3e571988bc0.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=203&amp;id=QPjkB&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=406&amp;originWidth=847&amp;originalType=binary&amp;ratio=1&amp;size=119807&amp;status=done&amp;style=none&amp;taskId=uc4420736-4496-455c-a039-deaab42dce4&amp;width=423.5" alt="image.png"><br>执行流程</p>
<ol>
<li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li>
<li>再到 ID 索引树查到 ID=300 对应的 R3；</li>
<li>在 k 索引树取下一个值 k=5，取得 ID=500；</li>
<li>再回到 ID 索引树查到 ID=500 对应的 R4；</li>
<li>在 k 索引树取下一个值 k=6，不满足条件，循环结束</li>
</ol>
<p>​</p>
<p>​</p>
<p><strong>回表：非主键搜索完后，回到主键索引树进行搜索的过程</strong>。（步骤 2、4）<br>​</p>
<p>​</p>
<p>​</p>
<h3 id="2-索引覆盖"><a href="#2-索引覆盖" class="headerlink" title="2. 索引覆盖"></a>2. 索引覆盖</h3><p>select ID from T where k between 3 and 5<br>​</p>
<p>​</p>
<p>对于上述通过非主键索引查询主键索引信息，由于非主键索引存放了主键的信息。<br>导致我们不需要进行回表。<strong>由于索引 k 的值覆盖了查询的字段，我们称之为覆盖索引</strong><br><strong>​</strong></p>
<p><strong>​</strong></p>
<p><strong>优点：减少树的搜索次数，提升查询效率</strong><br>​</p>
<p>​</p>
<h2 id="6-最左前缀原则"><a href="#6-最左前缀原则" class="headerlink" title="6. 最左前缀原则"></a>6. 最左前缀原则</h2><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">CREATE TABLE `tuser` (</span><br><span class="line">  `id` int(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `id_card` varchar(<span class="number">32</span>) DEFAULT NULL,</span><br><span class="line">  `name` varchar(<span class="number">32</span>) DEFAULT NULL,</span><br><span class="line">  `age` int(<span class="number">11</span>) DEFAULT NULL,</span><br><span class="line">  `ismale` tinyint(<span class="number">1</span>) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `id_card` (`id_card`),</span><br><span class="line">  KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631016490840-0e048d5d-77e7-4191-83e7-026d3c1e3e6e.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=243&amp;id=u0182df12&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=486&amp;originWidth=916&amp;originalType=binary&amp;ratio=1&amp;size=185361&amp;status=done&amp;style=none&amp;taskId=ubb2ba15c-29fb-469e-bca4-35d9ccce47c&amp;width=458" alt="image.png"></p>
<p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。<br><strong>​</strong></p>
<p><strong>联合索引以第一个索引为基准进行排序，然后通过第一个索引的值来进行查询</strong><br><a href="https://www.cnblogs.com/ljl150/p/12934071.html">最左前缀原则</a><br><strong>​</strong></p>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<h2 id="7-索引下推"><a href="#7-索引下推" class="headerlink" title="7. 索引下推"></a>7. 索引下推</h2><p>Mysql5.6 引入索引下推，是在最左前缀的条件小，过滤调不不符合条件的记录减少回表的次数<br>​</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select * from tuser where name like '张 %' and age=<span class="number">10</span> and ismale=<span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631018210889-220345e3-dae5-4eb8-9170-5537631d52ef.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=194&amp;id=u671fa958&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=388&amp;originWidth=859&amp;originalType=binary&amp;ratio=1&amp;size=183225&amp;status=done&amp;style=none&amp;taskId=u26fcfa9c-8351-4a80-bb20-4dd098a028b&amp;width=429.5" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1631018215910-da87dcc1-a41f-46ae-b73b-cecf9db4cf0f.png#clientId=uf02e59f4-5d80-4&amp;from=paste&amp;height=198&amp;id=ue03b52df&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=395&amp;originWidth=869&amp;originalType=binary&amp;ratio=1&amp;size=189030&amp;status=done&amp;style=none&amp;taskId=u0df9d68d-5a7b-4383-babc-d022de12965&amp;width=434.5" alt="image.png"></p>
<h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h2><ol>
<li>索引的常见模型<ol>
<li>哈希表 （不支持范围查询）</li>
<li>有序数组（插入删除效率低）</li>
<li>二叉搜索树（数据量大，导致树的高度很高，需要进行多次磁盘读取）</li>
</ol>
</li>
<li>InnoDB 索引模型<ol>
<li>B+树支持范围查询，树的高度不会太高</li>
<li>查找数据消耗磁盘读取的时间相同</li>
</ol>
</li>
<li>主键索引和非主键索引<ol>
<li>在 InnoDB 主键索引存储索引行对应的数据</li>
<li>非主键索引存储的是主键索引的值，需要通过回表的方式，去查询一遍主键索引</li>
</ol>
</li>
<li>索引覆盖：通过非主键索引查询主键索引的值，导致不需要回到主键索引树再次进行查询的过程。</li>
<li>最左前缀原则</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-行锁</title>
    <url>/2022/11/11/6!%E8%A1%8C%E9%94%81/</url>
    <content><![CDATA[<html><head></head><body><p>​</p>
<h2 id="1-两阶段锁"><a href="#1-两阶段锁" class="headerlink" title="1. 两阶段锁"></a>1. 两阶段锁</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634436939942-730ba0be-6f13-45fd-9e43-01d1e21cdcae.png#clientId=u3b414356-8e51-4&amp;from=paste&amp;height=284&amp;id=tMiKr&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=568&amp;originWidth=857&amp;originalType=binary&amp;ratio=1&amp;size=76026&amp;status=done&amp;style=none&amp;taskId=u92c3677b-e488-453e-8a85-2b6bec9261e&amp;width=428.5" alt="image.png"><br>**下面的操作序列中，如果为两行数据加了行锁事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。</p>
<p><strong>​</strong></p>
<p>在 InnoDB 中，行锁是在需要的时候加上，在<strong>事务结束时释放。（</strong>最有可能造成锁冲突的行的读锁尽量往后放<strong>）</strong><br><strong>​</strong></p>
<p>示例：<br>顾客 A 在影院 B 买电影票<br>操作如下</p>
<ol>
<li>从顾客 A 账户余额中扣除电影票价；</li>
<li>给影院 B 的账户余额增加这张电影票价；</li>
<li>记录一条交易日志。</li>
</ol>
<p>​</p>
<p>其中多个顾客买票可能造成 B 的账户行数据冲突。因此将 B 的操作放在最后。最大程度减少了事务之间的锁等待。<br>​</p>
<p>​</p>
<h2 id="2-死锁和死锁检测"><a href="#2-死锁和死锁检测" class="headerlink" title="2. 死锁和死锁检测"></a>2. 死锁和死锁检测</h2><p>示例：当行锁同时锁住 id=1 和 2 的两行数据<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634437587628-d3672f2b-b62b-4ced-ac7b-dcc6de65eb02.png#clientId=u3b414356-8e51-4&amp;from=paste&amp;height=281&amp;id=uf1f2e0cc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=561&amp;originWidth=871&amp;originalType=binary&amp;ratio=1&amp;size=90990&amp;status=done&amp;style=none&amp;taskId=ub90e33fe-f5b8-4aab-ad45-1cf1dd6750d&amp;width=435.5" alt="image.png"><br>在这种情况下事务 A 等待 id=2 的行锁，事务 B 等待 id=1 的行锁。事务 A 和事务 B 互相都在等待对方无法释放的资源，从而进入了死锁。<br>​</p>
<p>​</p>
<p>解决方法</p>
<ul>
<li>设置获取锁等待时间：设置获取锁超时时间，如果超时则锁住的线程自动退出。通过 innodb_lock_wait_timeout 来设置等待时间默认为 50s</li>
<li>发起死锁检测：发现死锁后主动回滚争抢锁的某一个事务。让其他事务继续执行。通过 innodb_deadlock_detect 设置为 on 表示开启逻辑。</li>
</ul>
<p>死锁检测的缺点：</p>
<ol>
<li>确保业务不会出现死锁，关闭死锁检测</li>
<li>控制并发度</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><ol>
<li>读锁的两阶段协议：需要的时候加上、事务结束的时候释放。尽可能将影响并发度最大的锁往后放。减少其他锁的等待时间</li>
<li>死锁的形成，事务之间争抢不释放的锁资源。导致一直处于等待状态</li>
<li>死锁的解决方法：1. 设置锁等待时间 2. 开启死锁检测</li>
</ol>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<ul>
<li>第一种，直接执行 delete from T limit 10000;</li>
<li>第二种，在一个连接中循环执行 20 次 delete from T limit 500;</li>
<li>第三种，在 20 个连接中同时执行 delete from T limit 500。</li>
</ul>
<p>你会选择哪一种方法呢？为什么呢？<br>第二种，第三种容易造成死锁。第一种锁的范围太大导致获取锁的时间长。</p>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql技术内幕-第一章</title>
    <url>/2022/01/11/Mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<html><head></head><body><h1 id="1-定义数据库和实例"><a href="#1-定义数据库和实例" class="headerlink" title="1. 定义数据库和实例"></a>1. 定义数据库和实例</h1><h3 id="​"><a href="#​" class="headerlink" title="​"></a>​</h3><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​</p>
<ol>
<li>数据库**： **操作系统或者是内存中数据库类型文件的集合。</li>
</ol>
<p>​</p>
<ol start="2">
<li>实例： 数据库实例是真正操作数据库的对象。通过数据库实例完成对数据库文件的增删改查。</li>
</ol>
<p>​</p>
<p>​</p>
<p>MySQL 是一个单进程多线程的数据库。MySQL 数据库实例在系统上表现的就是一个进程。<br>​</p>
<p>​</p>
<h1 id="2-MySQL-体系结构"><a href="#2-MySQL-体系结构" class="headerlink" title="2. MySQL 体系结构"></a>2. MySQL 体系结构</h1><h2 id="1-结构图"><a href="#1-结构图" class="headerlink" title="1. 结构图"></a>1. 结构图</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635610498443-00dd90e5-027b-45cc-9abd-453e79201f37.png#clientId=u65aa59ec-0f7c-4&amp;from=paste&amp;height=297&amp;id=u870f042c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=593&amp;originWidth=916&amp;originalType=binary&amp;ratio=1&amp;size=162280&amp;status=done&amp;style=none&amp;taskId=u84e62d2d-ba28-4b0e-b986-287bccf284f&amp;width=458" alt="image.png"></p>
<h2 id="2-MySQL-组成部分"><a href="#2-MySQL-组成部分" class="headerlink" title="2. MySQL 组成部分"></a>2. MySQL 组成部分</h2><h3 id="1-8-大组成部分"><a href="#1-8-大组成部分" class="headerlink" title="1. 8 大组成部分"></a>1. 8 大组成部分</h3><ol>
<li>连接池</li>
<li>管理服务和工具组件</li>
<li>Sql 接口组件</li>
<li>查询分析器</li>
<li>优化器</li>
<li>缓存</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ol>
<p><strong>存储引擎是基于表的，而不是数据库。</strong><br>​</p>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<h1 id="3-MySQL-存储引擎"><a href="#3-MySQL-存储引擎" class="headerlink" title="3. MySQL 存储引擎"></a>3. MySQL 存储引擎</h1><h2 id="1-InnoDB-存储引擎-最常用的-5-5-8-后默认存储引擎"><a href="#1-InnoDB-存储引擎-最常用的-5-5-8-后默认存储引擎" class="headerlink" title="1. InnoDB 存储引擎(最常用的 5.5.8 后默认存储引擎)"></a>1. InnoDB 存储引擎(最常用的 5.5.8 后默认存储引擎)</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><ol>
<li><strong>行锁设计</strong></li>
<li><strong>支持外键</strong></li>
<li><strong>类似于 Oracle 的非锁定读</strong></li>
</ol>
<p>​</p>
<p>​</p>
<h3 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2. 主要功能"></a>2. 主要功能</h3><ol>
<li>InnoDB 使用<strong>多版本并发控制（MVCC）来实现高并发性。</strong></li>
<li><strong>实现了 4 种隔离级别</strong>。默认的为 REPEATABLE 级别</li>
<li>使用<strong>next-key locking 策略来避免幻读现象</strong></li>
<li>提供了插入缓冲（insert buffer）、二次写、自适应哈希索引、预读等高性能和高可用功能</li>
<li>数据的存储的采用了<strong>聚集的方式</strong>，表的数据存储按主键的顺序存放。如果没有主键会默认每行生成一个 ROWID 作为主键。</li>
</ol>
<p>​</p>
<h3 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3. 面向对象"></a>3. 面向对象</h3><p>设计目标主要面向<strong>在线事务处理应用。</strong><br><strong>​</strong></p>
<p><strong>​</strong></p>
<h2 id="2-MyISAM-存储引擎（5-58-之前默认存储引擎）"><a href="#2-MyISAM-存储引擎（5-58-之前默认存储引擎）" class="headerlink" title="2. MyISAM 存储引擎（5.58 之前默认存储引擎）"></a>2. MyISAM 存储引擎（5.58 之前默认存储引擎）</h2><h3 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1. 特点"></a>1. 特点</h3><ol>
<li><strong>不支持事务、表锁/行锁</strong></li>
<li><strong>支持全文索引</strong></li>
<li><strong>缓冲池只缓存索引文件</strong>，不缓存数据。</li>
<li>MyISAM 存储引擎表的由 MYD 和 MYI 两种文件存储。MYD 存储数据，MYI 存储索引。</li>
</ol>
<p>​</p>
<p>​</p>
<h2 id="3-NDB-存储引擎-集群存储引擎"><a href="#3-NDB-存储引擎-集群存储引擎" class="headerlink" title="3. NDB 存储引擎(集群存储引擎)"></a>3. NDB 存储引擎(集群存储引擎)</h2><h3 id="1-特点-2"><a href="#1-特点-2" class="headerlink" title="1. 特点"></a>1. 特点</h3><ol>
<li><strong>数据全部放在内存中</strong>，5.1 后，可将非索引数据存放到磁盘上。</li>
<li><strong>主键查找速度极快</strong></li>
<li>通过增加 NDB 数据存储节点，可以线性提高数据性能。是高可用、高性能集群系统</li>
<li><strong>查询速度慢</strong>。由于 NDB 存储引擎连接操作在数据库层完成，导致需要巨大网络开销。</li>
</ol>
<h2 id="4-Memory-存储引擎"><a href="#4-Memory-存储引擎" class="headerlink" title="4. Memory 存储引擎"></a>4. Memory 存储引擎</h2><h3 id="1-特点-3"><a href="#1-特点-3" class="headerlink" title="1. 特点"></a>1. 特点</h3><ol>
<li><strong>数据存放在内存中</strong></li>
<li><strong>默认使用哈希索引</strong></li>
<li><strong>只支持表锁，并发性能差</strong></li>
<li><strong>不支持 TEXT 和 BLOBl 乐行</strong></li>
<li><strong>浪费内存，存储 varchar 是按照 char 的方式存储。</strong></li>
</ol>
<p><strong>​</strong></p>
<h2 id="5-存储引擎的比较"><a href="#5-存储引擎的比较" class="headerlink" title="5. 存储引擎的比较"></a>5. 存储引擎的比较</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635613196777-e8e4aa9e-8031-41f7-9c6b-2759e7734602.png#clientId=u0834a0c7-dbbe-4&amp;from=paste&amp;height=288&amp;id=ub63fdd4b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=576&amp;originWidth=858&amp;originalType=binary&amp;ratio=1&amp;size=96128&amp;status=done&amp;style=none&amp;taskId=u8a3c4e80-50ac-4e4b-94fd-03638655320&amp;width=429" alt="image.png"></p>
<h1 id="4-连接-MySQL"><a href="#4-连接-MySQL" class="headerlink" title="4. 连接 MySQL"></a>4. 连接 MySQL</h1><p>本质： MySQL 实例和连接进程的进行通信。<br>进程间的通信方式：TCP/IP 套接字，UNIX 域套接字、管道、命名管道。<br>​</p>
<p>​</p>
<h3 id="1-TCP-IP（常用）"><a href="#1-TCP-IP（常用）" class="headerlink" title="1. TCP/IP（常用）"></a>1. TCP/IP（常用）</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635613490753-6a0743d1-db16-4a40-867b-8e10c6b131bb.png#clientId=u0834a0c7-dbbe-4&amp;from=paste&amp;height=65&amp;id=u2b227af7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=130&amp;originWidth=781&amp;originalType=binary&amp;ratio=1&amp;size=12153&amp;status=done&amp;style=none&amp;taskId=ub2eb1b22-c425-4278-a08b-e32c658f8b5&amp;width=390.5" alt="image.png"><br>客户端通过向 MySQL 服务器发送 TCP/IP 连接请求，连接成功后。MySQL 数据库会查权限视图，判断用户的客户端 IP 是否连接到 MySQL 实例。</p>
<h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h1><ol>
<li>介绍了实例和数据库的区别。实例是操作数据库的对象，数据库是所有数据库类型文件的集合</li>
<li>MySQL 的体系结构和其中的组件<ol>
<li>连接池</li>
<li>管理服务和工具组件</li>
<li>Sql 接口</li>
<li>查询和分析器</li>
<li>优化器</li>
<li>缓存</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ol>
</li>
<li>MySQL 主流的存储引擎及其特点<ol>
<li>InnoDB 支持行锁、事务\外键</li>
<li>MyISAM 不支持行表锁、事务。支持全文索引</li>
<li>Memory 支持哈希索引、表锁、不支持 BLOB、TEXT 类型。varchar 定长.</li>
<li>NDB 数据存放在内存中</li>
</ol>
</li>
</ol>
<p>​</p>
<p>​</p>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>了解Mysql查询语句执行流程</title>
    <url>/2022/01/11/%E4%BA%86%E8%A7%A3Mysql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<html><head></head><body><p>​</p>
<p><strong>MySQL 逻辑架构图</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1629176680362-2a25040b-16f9-402a-895d-3c6fdfd78a1f.png#clientId=u444c9418-ad4f-4&amp;from=paste&amp;height=335&amp;id=bsas8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=670&amp;originWidth=898&amp;originalType=binary&amp;ratio=1&amp;size=243581&amp;status=done&amp;style=none&amp;taskId=u046362f2-96e4-4be8-9205-33faa94f32d&amp;width=449" alt="image.png"></p>
<h2 id="1-Server-层"><a href="#1-Server-层" class="headerlink" title="1. Server 层"></a>1. Server 层</h2><h4 id="​"><a href="#​" class="headerlink" title="​"></a>​</h4><p>Server 层包括连接器、分析器、优化器、执行器、查询缓存。<br>​</p>
<h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h3><p>作用：</p>
<ol>
<li><strong>负责跟客户端建立连接</strong></li>
<li><strong>获取权限</strong></li>
<li><strong>维持和管理连接</strong></li>
</ol>
<p>​</p>
<p>连接指令</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h$ip <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p</span><br></pre></td></tr></tbody></table></figure>

<p>获取权限：通过 TCP 握手后，连接器验证身份，通过输入的用户名和密码。查询 MySQL 数据库中的 user 表。查询对应的用户权限。<br>​</p>
<p><strong>长连接和短链接</strong><br>​</p>
<p>长连接：连接成功后，如果客户端持续有请求，则一直使用该连接<br>​</p>
<p>短连接：每次执行完几次查询就断开连接，下次查询在重新建立连接。<br>​</p>
<p>​</p>
<p>建议使用长连接，因为建立连接过程比较复杂，尽量减少建立连接的动作。<br>​</p>
<p>但是建立长连接也会导致内存消耗增加。因为 Mysql 在执行时使用的内存是在连接对象里面的。这些资源会在断开时释放。<br>如果长连接累计下来，可能导致内存占用太大。<br>​</p>
<p>解决方法</p>
<ol>
<li>定期断开长连接</li>
<li>执行 mysql_reset_connectionc 初始化连接资源。针对 5.7 以后。</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2. 查询缓存"></a>2. 查询缓存</h3><p>​</p>
<p><strong>作用：用于做缓存</strong><br>Mysql 拿到请求后会先去缓存中，查看是否有对应的查询语句。缓存以 key-value 的形式存储。<br>查询语句作为 key ,查询结果作为 value 存入缓存中。<br>但是不建议使用查询缓存。因为缓存数据失效的很频繁。<br><strong>8.0 之后 MySQL 删掉了查询缓存</strong><br><strong>​</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>缓存查询</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  SQL_CACHE <span class="operator">*</span>  <span class="keyword">from</span> T ;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 不查询缓存</span><br><span class="line"><span class="keyword">select</span>   DEMAND <span class="operator">*</span>  <span class="keyword">from</span> T ;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>​</strong></p>
<h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h3><p>​</p>
<p><strong>作用： 进行 sql 语句的解析</strong>。<br>​</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>词法分析</li>
</ol>
<p>通过关键字 **select **识别为查询语句。将对应的 T 识别成对应的表名 T，将字符串”ID” 识别成列”ID”.<br>​</p>
<ol start="2">
<li>语法分析</li>
</ol>
<p>​</p>
<p>判断 Sql 语句是否满足 Mysql 语法。如果语句不对，则会受到错误提醒。<br>​</p>
<p>​</p>
<p>​</p>
<h3 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h3><p><strong>作用：决定执行方案</strong></p>
<ol>
<li><strong>决定使用哪个索引，多个索引情况下。</strong></li>
<li><strong>决定各表连接顺序，多个表关联的情况下。</strong></li>
</ol>
<p>​</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID) <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li>
<li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li>
</ul>
<p>​</p>
<p>优化器会决定执行哪种方案。<br>​</p>
<p>​</p>
<h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h3><p><strong>作用：执行 sql 语句</strong><br>​</p>
<ol>
<li>判断用户对这个表有无查询权限</li>
<li>根据表引擎提供的接口执行查询</li>
</ol>
<ul>
<li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ul>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h3><ol>
<li>连接器主要作用让客户端和服务端建立连接、获取登录用户权限、维持和管理连接。</li>
<li>查询缓存用于通过查询的 sql 语句作为 key，判断是否存在对应的 key,如果存在直接返回缓存中存储的查询结果。</li>
<li>分析器用于<strong>判断 sql 语句语法是否正确</strong>！将查询的 sql 语句的字段名解析成对应的数据库中对应的字段和表</li>
<li>分析器作用<strong>优化查询条件</strong>。查询条件判断使用哪种索引进行查询以及各表的连接顺序</li>
<li>执行器用于<strong>执行 sql 语句</strong>。</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql技术内幕-第二章</title>
    <url>/2022/01/11/Mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<html><head></head><body><h1 id="1-InnoDB-体系架构"><a href="#1-InnoDB-体系架构" class="headerlink" title="1. InnoDB 体系架构"></a>1. InnoDB 体系架构</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635692260786-270228fe-31a7-4258-b9c1-87c52f516e08.png#clientId=u2d86973c-b20b-4&amp;from=paste&amp;height=227&amp;id=ua9f959a7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=454&amp;originWidth=736&amp;originalType=binary&amp;ratio=1&amp;size=30916&amp;status=done&amp;style=none&amp;taskId=u899d9abe-da7d-4e86-8256-0126b55682e&amp;width=368" alt="image.png"><br><strong>​</strong></p>
<h3 id="1-InnoDB-存储引擎作用"><a href="#1-InnoDB-存储引擎作用" class="headerlink" title="1. InnoDB 存储引擎作用"></a>1. InnoDB 存储引擎作用</h3><ol>
<li><strong>缓存磁盘上的数据</strong>，方便快速读取。对<strong>磁盘数据修改之前也做缓存。</strong></li>
<li><strong>redo log 缓冲</strong></li>
<li>维护进程、线程需要访问的多个内部数据结构</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>​</p>
<p>​</p>
<h2 id="1-后台线程"><a href="#1-后台线程" class="headerlink" title="1. 后台线程"></a>1. 后台线程</h2><p>InnoDB 存储引擎是多线程模型，负责处理不同的任务<br>​</p>
<h3 id="1-MasterThread"><a href="#1-MasterThread" class="headerlink" title="1. MasterThread"></a>1. MasterThread</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>将数据异步刷新到磁盘。其中包括脏页刷新、合并插入缓冲、UNDO 页回收。<br>​</p>
<p>​</p>
<h3 id="2-IO-Thread"><a href="#2-IO-Thread" class="headerlink" title="2. IO Thread"></a>2. IO Thread</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>InnoDB 使用了大量的<strong>异步 IO</strong> 来处理 IO 请求。作用是<strong>提高数据库的性能</strong>。<br>IO Thread 的作用是负责<strong>IO 请求的回调处理</strong><br><strong>​</strong></p>
<p><strong>​</strong></p>
<h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h4><p>IOThread 主要分为 4 种</p>
<ul>
<li><code>write thread</code>(默认 4 个)</li>
<li><code>read thread</code>(默认 4 个)</li>
<li><code>insert buffer thread</code></li>
<li><code>log io thread </code></li>
</ul>
<p>​</p>
<p>write 和 read Thread 可以通过 <code>innnodb_read_io_threads </code>和<code>innodb_write_io_threads</code>设置线程数<br><strong>​</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635693324015-367ec145-45e4-4614-87a4-0c8acb2a6e1e.png#clientId=u2d86973c-b20b-4&amp;from=paste&amp;height=101&amp;id=u0203448e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=201&amp;originWidth=916&amp;originalType=binary&amp;ratio=1&amp;size=44417&amp;status=done&amp;style=none&amp;taskId=u5737c692-8eaa-4bca-becf-305455ba63f&amp;width=458" alt="image.png"></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">//可以通过该命令查看innodb 中的io Thread</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash">show engine innodb  status ;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635693491056-13f94aba-301d-4a04-a8fa-9002fa135a97.png#clientId=u2d86973c-b20b-4&amp;from=paste&amp;height=118&amp;id=u0f6a553d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=235&amp;originWidth=567&amp;originalType=binary&amp;ratio=1&amp;size=29125&amp;status=done&amp;style=none&amp;taskId=u2646bf68-d485-4625-a513-b5ea7fdc815&amp;width=283.5" alt="image.png"></p>
<h3 id="3-Purge-Thread"><a href="#3-Purge-Thread" class="headerlink" title="3. Purge Thread"></a>3. Purge Thread</h3><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p><strong>作用：回收事务提交后的使用的 undo 页</strong>。<br>分配到独立的线程中进行，减少 Master Thread 工作。同时用户可以也可以通过<code>innnodb_purge_threads</code> 设置线程数，默认为 1.<br>​</p>
<p>​</p>
<h3 id="4-Page-Cleaner-Thread"><a href="#4-Page-Cleaner-Thread" class="headerlink" title="4. Page Cleaner Thread"></a>4. Page Cleaner Thread</h3><p>​</p>
<p>作用：脏页刷新操作。<br>从而减少了 Master Thread 工作和查询线程线程的阻塞。提高了 InnoDB 性能。<br>​</p>
<p>​</p>
<h3 id="5-后台线程作用"><a href="#5-后台线程作用" class="headerlink" title="5. 后台线程作用"></a>5. 后台线程作用</h3><ol>
<li>刷新内存池中的数据，保证缓存的是最新的数据</li>
<li>将已修改的数据文件刷新到磁盘中</li>
<li>保证数据库发生异常恢复正常</li>
</ol>
<h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h2><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="1-缓冲池"><a href="#1-缓冲池" class="headerlink" title="1. 缓冲池"></a>1. 缓冲池</h3><h4 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>用来<strong>解决 cpu 速度和磁盘速度之间的鸿沟</strong><br><strong>​</strong></p>
<p><strong>​</strong></p>
<h4 id="2-执行流程"><a href="#2-执行流程" class="headerlink" title="2. 执行流程"></a>2. 执行流程</h4><p>数据库读取页时，将磁盘读取到的页放在缓冲池中。下一次再次读取该数据页时，直接从池中读取。否则从磁盘上读取。</p>
<p>数据库修改页操作时，首先修改缓冲池的页，然后通过<code>check point </code>机制将数据页刷新到磁盘中。<br>​</p>
<h4 id="3-缓冲池大小配置"><a href="#3-缓冲池大小配置" class="headerlink" title="3. 缓冲池大小配置"></a>3. 缓冲池大小配置</h4><p><strong>​</strong></p>
<p>通过 innnodb_buffer_pool_size 来设置缓冲池大小。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635694963515-e0b21fec-317a-400c-ac75-263527738b5a.png#clientId=u2d86973c-b20b-4&amp;from=paste&amp;height=74&amp;id=u4b5d0c0c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=147&amp;originWidth=588&amp;originalType=binary&amp;ratio=1&amp;size=10538&amp;status=done&amp;style=none&amp;taskId=u89b99578-855f-48e2-a253-4720f96a6fb&amp;width=294" alt="image.png"><br>​</p>
<p>​</p>
<h4 id="4-存储对象"><a href="#4-存储对象" class="headerlink" title="4. 存储对象"></a>4. 存储对象</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635695049116-4482036d-9fb4-4114-86c0-d6bc26b0bb12.png#clientId=u2d86973c-b20b-4&amp;from=paste&amp;height=170&amp;id=ua8111efd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=339&amp;originWidth=782&amp;originalType=binary&amp;ratio=1&amp;size=36170&amp;status=done&amp;style=none&amp;taskId=ud1cc8c94-5846-4f28-9046-31ccee4f486&amp;width=391" alt="image.png"></p>
<ol>
<li>索引页</li>
<li>数据页</li>
<li>插入缓冲</li>
<li>undo 页</li>
<li>自适应哈希索引</li>
<li>锁信息</li>
<li>数据字典信息</li>
</ol>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<p><strong>​</strong></p>
<h3 id="2-缓存算法"><a href="#2-缓存算法" class="headerlink" title="2. 缓存算法"></a>2. 缓存算法</h3><h4 id="1-LRU（最近最少使用淘汰）"><a href="#1-LRU（最近最少使用淘汰）" class="headerlink" title="1. LRU（最近最少使用淘汰）"></a>1. LRU（最近最少使用淘汰）</h4><p>将经常使用的页放在 LRU 列表的最前端，最少使用页放在列表尾端。将新读取的页放到 midpoint 位置（距离尾端的 3/8 出）。可以通过<code>innodb_old_blocks_pct</code>控制插入位置。<br><code>midpoint</code> 之前的 new 列表，之后的为 old 列表。new 列表中数据为活跃的数据。<br>​</p>
<p>​</p>
<p>为什么不直接把读取的新页放在列表首部？<br>​</p>
<p>部分 sql 操作（索引、数据扫描操作）导致缓冲池中页被刷出，影响缓冲池效率。需要读入大量的数据页，导致许多活跃数据页从列表中移除。<br>innodb 可以通过设置<code>innodb_old_blocks_time</code>来决定新加入的页从 mid 到列表头部需要等待多久。<br>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="3-redo-日志缓冲（-redo-log-buffer）"><a href="#3-redo-日志缓冲（-redo-log-buffer）" class="headerlink" title="3. redo 日志缓冲（ redo log buffer）"></a>3. redo 日志缓冲（ redo log buffer）</h3><p>用于暂时存放 redo log 信息，然后 Innodb 以一定频率刷新到 redo log 文件中。<br>可以通过 <code>innnodb_log_buffer_size</code>设置缓冲大小。<br>​</p>
<p><strong>三种日志刷新到 redo log 文件情况</strong></p>
<ol>
<li>Master Thread 每秒刷新</li>
<li>事务提交时刷新</li>
<li>日志缓冲空间小于一半</li>
</ol>
<p>​</p>
<h1 id="2-Checkpoint-技术"><a href="#2-Checkpoint-技术" class="headerlink" title="2. Checkpoint 技术"></a>2. Checkpoint 技术</h1><p><strong>解决问题</strong></p>
<ol>
<li>缩短数据恢复时间</li>
<li>缓冲池不够时，将脏页刷新到磁盘</li>
<li>redo log 日志缓冲不够时，刷新脏页</li>
</ol>
<h2 id="1-Check-Point-分类："><a href="#1-Check-Point-分类：" class="headerlink" title="1. Check Point 分类："></a>1. Check Point 分类：</h2><ol>
<li>Sharp Checkpoint</li>
<li>Fuzzy Checkpoing</li>
</ol>
<p>​</p>
<p>​</p>
<h2 id="2-Sharp-Checkpoint"><a href="#2-Sharp-Checkpoint" class="headerlink" title="2. Sharp Checkpoint"></a>2. Sharp Checkpoint</h2><p>默认将<strong>数据库关闭时将所有脏页刷新到磁盘中</strong>，<br>参数是 innodb_fast_shutdown=1.</p>
<p>​</p>
<h2 id="3-Fuzzy-Checkpoint"><a href="#3-Fuzzy-Checkpoint" class="headerlink" title="3. Fuzzy Checkpoint"></a>3. Fuzzy Checkpoint</h2><h3 id="1-Master-Thread-checkpoint"><a href="#1-Master-Thread-checkpoint" class="headerlink" title="1. Master Thread checkpoint"></a>1. Master Thread checkpoint</h3><p>每 1 或 10 秒将缓冲池中的部分脏页异步刷新到磁盘</p>
<h3 id="2-Async-Sync-Flush-checkpoint"><a href="#2-Async-Sync-Flush-checkpoint" class="headerlink" title="2. Async/Sync Flush checkpoint"></a>2. Async/Sync Flush checkpoint</h3><p>在重做日志不可用情况下强制刷新一部分页会磁盘。</p>
<h1 id="3-InnoDB-关键特性"><a href="#3-InnoDB-关键特性" class="headerlink" title="3. InnoDB 关键特性"></a>3. InnoDB 关键特性</h1><h2 id="1-插入缓冲"><a href="#1-插入缓冲" class="headerlink" title="1. 插入缓冲"></a>1. 插入缓冲</h2><h3 id="1-Insert-Buffer"><a href="#1-Insert-Buffer" class="headerlink" title="1. Insert Buffer"></a>1. Insert Buffer</h3><p>原理： 当对<strong>非聚集索</strong>引进<strong>行插入或更新</strong>操作时，若<strong>索引页在缓冲池</strong>中，则直接<strong>更新索引页</strong>。反之，先<strong>放到 Insert Buffer <strong>中，然后以一定频率将 Insert Buffer 中的数据和辅助索引页进行</strong>merge 操作</strong>。<br>​</p>
<p>​</p>
<p>前提：<strong>不是唯一索引的辅助索引</strong><br>问题：为什么不能是唯一索引？<br>因为唯一索引在更新时，需要将索引页加载进缓冲池中，判断索引是否唯一。将索引页加入了缓冲池中，就失去了使用 Insert Buffer 的意义。<br>作用：提高插入性能，因为每次插入时不需要立即将数据 merge 到索引页中。<br>​</p>
<p>本质：将非聚集索引的写操作缓冲起来，然后将写操作批量 merge 到索引页中。<br>​</p>
<p>缺点：写密集情况下会暂用大量缓冲池内存<br>可以通过 IBUF_POOL_SIZE_PER_MAX_SIZE 设置 Insert buffer 占缓冲池的比例<br>​</p>
<h3 id="2-change-buffer"><a href="#2-change-buffer" class="headerlink" title="2. change buffer"></a>2. change buffer</h3><p>insert buffer 的升级版，支持 insert 、delete、 update 语句缓冲。通过 Insert Buffer、 Delete Buffer 、Purge Buffer 来实现缓冲。</p>
<p>Update 语句的实现过程</p>
<ol>
<li>数据的记录标记为删除</li>
<li>数据真正删除</li>
</ol>
<p>​</p>
<p>将数据记录标记位删除通过，通过 Delete Buffer 来实现。然后通过 Purge Buffer 将数据真正删除。<br>​</p>
<p>​</p>
<p>​</p>
<h3 id="3-Insert-Buffer-内部实现"><a href="#3-Insert-Buffer-内部实现" class="headerlink" title="3. Insert Buffer 内部实现"></a>3. Insert Buffer 内部实现</h3><p>Insert Buffer 的数据结构是一颗 B+树。<br>非叶节点存放的查询的 search key .<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635779623534-a1a111a7-ba6f-4e06-9b28-2805adb882e1.png#clientId=u147b5b0d-e61f-4&amp;from=paste&amp;height=51&amp;id=u23ae932e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=102&amp;originWidth=545&amp;originalType=binary&amp;ratio=1&amp;size=7625&amp;status=done&amp;style=none&amp;taskId=u8a8fadad-c07e-4ea8-a65f-6252e61e696&amp;width=272.5" alt="image.png"></p>
<ul>
<li>space 表示数据插入的表的<strong>表空间 id（用于确定插入数据是哪张表）</strong></li>
<li>marker 兼容老版本的 Insert Buffer</li>
<li>offset 数据页在表中的偏移量（位置）（用于确定是辅助索引的哪一页）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635780351139-02db6f9a-d6eb-43b8-b2c3-006e96cac8da.png#clientId=u147b5b0d-e61f-4&amp;from=paste&amp;height=74&amp;id=u85fb66e2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=147&amp;originWidth=742&amp;originalType=binary&amp;ratio=1&amp;size=20005&amp;status=done&amp;style=none&amp;taskId=uf11cb2c4-21ca-4099-a07a-63bd4da678e&amp;width=371" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635780853424-d8b9a379-1c69-4fdb-bcb0-b7b93b0b0a50.png#clientId=u147b5b0d-e61f-4&amp;from=paste&amp;height=86&amp;id=u6590f1f8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=172&amp;originWidth=968&amp;originalType=binary&amp;ratio=1&amp;size=15357&amp;status=done&amp;style=none&amp;taskId=ud2fa6c63-6633-4abc-92bb-c812946d476&amp;width=484" alt="image.png"></p>
<p>metadata 中记录信息插入的顺序以及插入信息的类型<br>​</p>
<p>​</p>
<p>Insert Buffer 通过 space 和 offset 确定更新数据的表和辅助索引具体页。<br>​</p>
<p>​</p>
<h3 id="4-Merge-Insert-Buffer"><a href="#4-Merge-Insert-Buffer" class="headerlink" title="4. Merge Insert Buffer"></a>4. Merge Insert Buffer</h3><h5 id="​"><a href="#​" class="headerlink" title="​"></a>​</h5><ol>
<li>辅助索引页读取到缓冲池中</li>
<li>Insert Buffer Bitmap 页发现辅助索引页无可用空间时。</li>
<li>Master Thread 定时进行 Merge</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. 命令</h3><h4 id="1-innodb-change-buffering"><a href="#1-innodb-change-buffering" class="headerlink" title="1. innodb_change_buffering"></a>1. <code>innodb_change_buffering</code></h4><p>作用： 选择开启哪些缓冲，参数为<img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635779173141-60283c22-3b4a-4307-9afb-d2b31f2ecf19.png#clientId=u147b5b0d-e61f-4&amp;from=paste&amp;height=21&amp;id=u50f1346f&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=41&amp;originWidth=472&amp;originalType=binary&amp;ratio=1&amp;size=3875&amp;status=done&amp;style=none&amp;taskId=uf0bc3b34-e529-4b4e-91b5-9d2fc61f89c&amp;width=236" alt="image.png"></p>
<h4 id="2-innodb-change-buffer-max-size"><a href="#2-innodb-change-buffer-max-size" class="headerlink" title="2. innodb_change_buffer_max_size"></a>2. innodb_change_buffer_max_size</h4><p>作用：控制 change buffer 最大内存使用量<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1635779232140-aea89c5b-1c60-420c-ad21-7455d07c85ef.png#clientId=u147b5b0d-e61f-4&amp;from=paste&amp;height=23&amp;id=ubfd3b6b4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=45&amp;originWidth=880&amp;originalType=binary&amp;ratio=1&amp;size=9395&amp;status=done&amp;style=none&amp;taskId=u5e544fdf-c639-4141-8cea-ffb33be97fc&amp;width=440" alt="image.png"><br><strong>最大值为 50.</strong></p>
<p>​</p>
<h2 id="2-两次写"><a href="#2-两次写" class="headerlink" title="2. 两次写"></a>2. 两次写</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1636031467126-3252bdd4-ab40-4f6e-9266-86cd36868636.png#clientId=uecbbc78a-62fa-4&amp;from=paste&amp;height=255&amp;id=u11158e89&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=510&amp;originWidth=816&amp;originalType=binary&amp;ratio=1&amp;size=174039&amp;status=done&amp;style=none&amp;taskId=ueb092f1b-bb82-4392-9efa-7d478b9f7a8&amp;width=408" alt="image.png"></p>
<h3 id="1-流程"><a href="#1-流程" class="headerlink" title="1. 流程"></a>1. 流程</h3><ol>
<li>InnoDB 将脏页写到内存中的 Double write buffer 中</li>
<li>然后 DWB 将数据现在写入磁盘上 DWB</li>
<li>内存中的 DWB 再将数据刷到磁盘中</li>
</ol>
<p>​</p>
<p>​</p>
<h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><p>通过将脏页数据进行缓存，可以保证数据库异常关闭的情况下，脏页数据未完全写入磁盘时，无法通过 redo log 进行数据的恢复。可以通过 DWB 中之前保存的脏页数据，将数据页写入到磁盘中，然后 redo log 根据脏页进行数据的恢复。<br>​</p>
<p><a href="https://developer.aliyun.com/article/743889?spm=a2c6h.14164896.0.0.7d52783blX00fB">double write buffer 深度</a><br>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="3-自适应哈希索引（AHI）"><a href="#3-自适应哈希索引（AHI）" class="headerlink" title="3. 自适应哈希索引（AHI）"></a>3. 自适应哈希索引（AHI）</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>由于哈希是一种时间复杂度为 O(1)的查找方法。可以通过在 B+树种建立哈希索引提高查询速度。<br>​</p>
<p>自适应哈希索引：存储引擎通过监控索引页的查询条件和频率，来选择是否建立哈希索引。<br>原理：通过缓冲池中的页</p>
<h3 id="2-前提"><a href="#2-前提" class="headerlink" title="2. 前提"></a>2. 前提</h3><ol>
<li>连续使用的查询条件一样</li>
<li>查询条件使用了 100 次</li>
<li>数据页通过该查询条件访问了（页中记录/16）次。</li>
</ol>
<p>​</p>
<h3 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h3><ol>
<li>提高了读取和写入速度</li>
<li>只能用来等值查询，不能范围查询</li>
</ol>
<p>​</p>
<p>​</p>
<h2 id="4-异步-IO"><a href="#4-异步-IO" class="headerlink" title="4. 异步 IO"></a>4. 异步 IO</h2><h3 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1. 作用"></a>1. 作用</h3><ol>
<li>异步执行 IO 操作</li>
<li>IO 合并</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="2-异步-IO-操作"><a href="#2-异步-IO-操作" class="headerlink" title="2. 异步 IO 操作"></a>2. 异步 IO 操作</h3><p>同步 IO: 用户发出 IO 请求后，需要等待 IO 请求完成，才能继续发送下一个 IO 请求。<br>异步 IO: 用户发出 IO 请求后不需要等待 IO 操作完成，可以继续发出 IO 请求。直到所有的 IO 请求发送完后，等待 IO 操作完成。<br>​</p>
<p>​</p>
<h3 id="3-IO-合并"><a href="#3-IO-合并" class="headerlink" title="3. IO 合并"></a>3. IO 合并</h3><p>AIO:将多个 IO 请求合并为一个 IO 请求。<br>​</p>
<p>例如： 用户需要访问多个连续页时（8,6）、（8,7）、（8,8）可以将多个 IO 操作合并成一个 IO 操作。<br>​</p>
<p>（page,offset）指代某个表的某一页。<br>​</p>
<h2 id="5-刷新临接页"><a href="#5-刷新临接页" class="headerlink" title="5. 刷新临接页"></a>5. 刷新临接页</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1636369637440-accdf8fa-3eba-4dfa-a7bd-ca3a30b7af22.png#clientId=udb988001-8bfa-4&amp;from=paste&amp;height=285&amp;id=u6fd4ce86&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=569&amp;originWidth=1027&amp;originalType=binary&amp;ratio=1&amp;size=95537&amp;status=done&amp;style=none&amp;taskId=u91c37abd-0f4c-4431-84d0-0657b3bb723&amp;width=513.5" alt="image.png"></p>
<p>工作原理：刷新脏页时，会检测所在区的所有分页，然后通过 AIO 一起进行刷新。<br>​</p>
<p>建议机械硬盘开启特性，固态硬盘由于有着高性能的 IO 读写可以关闭。<br>​</p>
<p>​</p>
<h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><p>​</p>
<h3 id="​-1"><a href="#​-1" class="headerlink" title="​"></a>​</h3></body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
</search>
